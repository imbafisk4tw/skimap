<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Ski-P√§sse: Snow Card Tirol & SuperSkiCard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon-32.png" sizes="32x32">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">


  <style>
    
/* --- Unified Control Cards (Layer / Filter / Export) --- */
:root{
  --panel-bg: #ffffff;
  --panel-border: rgba(0,0,0,0.18);
  --panel-radius: 14px;
  --panel-shadow: 0 8px 22px rgba(0,0,0,0.16);
  --panel-pad: 10px 12px;
  --panel-title-size: 13px;
  --panel-title-weight: 700;
  --panel-muted: rgba(0,0,0,0.62);
  --control-gap: 10px;
}

.panel-card{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  box-sizing: border-box;
}

.panel-title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

.panel-group-title{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .02em;
  text-transform: uppercase;
  color: var(--panel-muted);
  margin: 10px 0 6px 0;
}

.panel-card label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
  user-select:none;
}
.panel-card input[type="checkbox"],
.panel-card input[type="radio"]{
  margin:0;
}

/* Desktop: rechte Control-Spalte sauber stapeln */
.leaflet-top.leaflet-right{
  display:flex;
  flex-direction:column;
  gap: var(--control-gap);
}

/* Desktop: rechte Control-Spalte darf scrollen (damit Filter nicht "verschwinden") */
@media (min-width: 721px){
  .leaflet-top.leaflet-right{
    max-height: calc(var(--app-h) - 18px);
    overflow-y: auto;
    padding-right: 4px;
  }
  .leaflet-top.leaflet-right::-webkit-scrollbar{ width: 8px; }
  .leaflet-top.leaflet-right::-webkit-scrollbar-thumb{
    background: rgba(0,0,0,0.18);
    border-radius: 10px;
  }
}
.leaflet-top.leaflet-right .leaflet-control{
  margin: 0 !important; /* gap regelt Abstand */
}

/* --- Filter-Box --- */
.filter-box.leaflet-control{
  width: 210px;
}
.filter-box.leaflet-control,
.export-box.leaflet-control{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  font-size: 13px;
  line-height: 1.35;
  box-sizing:border-box;
}
.filter-box .title,
.export-box .title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

/* Leaflet Layers Control wie Panel-Card */
.leaflet-control-layers{
  width: 210px;
  background: var(--panel-bg) !important;
  padding: var(--panel-pad) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--panel-radius) !important;
  box-shadow: var(--panel-shadow) !important;
}
.leaflet-control-layers .leaflet-control-layers-separator{
  border-top: 1px solid rgba(0,0,0,0.12);
  margin: 8px 0;
}
.leaflet-control-layers label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.leaflet-control-layers input{
  margin: 0;
}

/* Export Buttons etwas "ruhiger" */
.export-box button{
  width:100%;
  height: 32px;
  padding: 0 10px;
  margin: 6px 0 0 0;
  font-size: 12px;
  font-weight: 600;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,0.35);
  background:#f3f3f3;
  cursor:pointer;
}
.export-box button:hover{ background:#e9e9e9; }
.export-box .hint{
  margin-top:8px;
  font-size:11px;
  color: rgba(0,0,0,0.68);
}
html, body {
      height: 100%;
      margin: 0;
    }
    :root { --app-h: 100dvh; }
    @supports not (height: 100dvh) { :root { --app-h: 100vh; } }
    #map {
      height: var(--app-h);
      width: 100vw;
    }

    .legend-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
      background: white;
      padding: 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
    }
.search-box {
  position: fixed !important;
  top: 10px;
  left: 50px;
  z-index: 10000;
  background: white;
  padding: 10px 10px 12px 10px;
  width: 390px;
  max-width: calc(100vw - 40px);
  box-sizing: border-box;
  border: 1px solid #888;
  font-size: 13px;
  line-height: 1.35;
  box-shadow: 0 8px 22px rgba(0,0,0,0.16);
  border-radius: 12px;
}
.search-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
.search-box input {
  width: 100%;
  height: 36px;
  padding: 8px 10px;
  font-size: 14px;
  border: 1px solid #bbb;
  border-radius: 10px;
  box-sizing: border-box;
  outline: none;
}
.search-box input:focus {
  border-color: #777;
}
.search-row {
  display: flex;
  gap: 8px;
  align-items: stretch;
  flex-wrap: nowrap;
}
.search-row input {
      flex: 1 1 auto;
      min-width: 0;
    }
#search-btn {
  flex: 0 0 auto;
  height: 36px;
  padding: 0 12px;
  font-size: 13px;
  font-weight: 600;
  border: 1px solid #666;
  border-radius: 10px;
  background: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
}
#search-btn:hover{ background:#e0e0e0; }
#clear-verbund-btn {
  flex: 0 0 auto;
}
#clear-verbund-btn:disabled {
  opacity: 0.55;
  cursor: default;
}
#clear-verbund-btn:disabled {
      opacity: 0.55;
      cursor: default;
    }
.slider-box {
      position: fixed;
      bottom: 110px;        /* sitzt √ºber der Legende */
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px); /* mobil: passt sich an */
      box-sizing: border-box;
    }

    .slider-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .slider-box input[type="range"] {
      width: 100%;
    }
    .slider-box .time-label {
      margin-top: 4px;
      font-size: 12px;
      color: #444;
    }

    /* Box f√ºr Startadresse & Button */
    .home-box {
      position: fixed;
      bottom: 120px;           
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px);
      box-sizing: border-box;
    }

    /* Desktop: Home-Box ausblenden (Dropdown sitzt oben im Slider) */
    @media (min-width: 721px){
      .home-box{ display:none !important; }
    }

    .home-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
    .home-box input {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border: 1px solid #bbb;
      border-radius: 3px;
      box-sizing: border-box;
      margin-bottom: 6px;
    }
    .home-box button {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border-radius: 3px;
      border: 1px solid #666;
      background: #f0f0f0;
      cursor: pointer;
    }
    .home-box button:hover {
      background: #e0e0e0;
    }

    /* Counter unten rechts */
    .counter-box {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      background: white;
      padding: 6px 10px;
      border: 1px solid #888;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
    }
  
    /* Responsive: Mobile Layout */
    @media (max-width: 720px) {
      /* --- Strong overrides for mobile topbar layout --- */
      .search-box .search-row{ flex-wrap: nowrap !important; }
      #resort-search{ min-width: 0 !important; }
      #search-btn{ min-width: 56px; }
      #clear-verbund-btn,
      #mobile-panel-toggle{ width: 44px; min-width: 44px; height: 44px; padding: 0 !important; }
      #clear-verbund-btn{ border-radius: 10px !important; }

      /* Zoom: unten rechts √ºber dem Counter */
      .leaflet-control-zoom{
        position: fixed !important;
        right: 12px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 64px) !important;
        left: auto !important;
        top: auto !important;
        z-index: 4000 !important;
      }
      .leaflet-control-zoom a{
        width: 40px;
        height: 40px;
        line-height: 40px;
        font-size: 20px;
      }

      /* Auf Mobile aufr√§umen */
      .home-box { display: none !important; }               /* Startadresse ausblenden */
      .export-box.leaflet-control { display: none !important; } /* Export ausblenden */
      .legend-box { display: none !important; }             /* optional: Legende ausblenden */

      /* Suchleiste oben als "Card" */
      .search-box label{ display:none; }

      /* Top-Bar: Input + Go + X + Men√º in EINER Zeile */
      #search-btn{
        height: 44px;
        padding: 0 10px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
        min-width: 56px;
        flex: 0 0 auto !important;
      }
      #clear-verbund-btn,
      #mobile-panel-toggle{
        width: 44px;
        min-width: 44px;
        height: 44px;
        padding: 0 !important;
        flex: 0 0 auto !important;
      }
      /* falls irgendwo noch alte Flex-Regeln greifen */
      #clear-verbund-btn{ margin-left: 0 !important; }

      .search-box {
        top: calc(env(safe-area-inset-top, 0px) + 8px) !important;
        left: 8px !important;
        right: 8px !important;
        width: auto !important;
        max-width: none !important;
        padding: 8px 10px 10px 10px !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        backdrop-filter: blur(8px);
        background: rgba(255,255,255,0.92) !important;
      }
      .search-box label {
        display: block;
        font-size: 14px !important;
        margin-bottom: 6px !important;
      }

      .search-row { gap: 8px !important; flex-wrap: wrap !important; }

      #resort-search {
        flex: 1 1 220px !important;
        min-width: 180px;
        height: 44px;
        padding: 10px 12px !important;
        font-size: 16px !important; /* verhindert iOS auto-zoom */
        border-radius: 10px !important;
      }

      #search-btn,
      #clear-verbund-btn {
        height: 44px;
        padding: 0 12px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
      }
/* Leaflet Controls nicht unter der Suchbox verstecken */
      .leaflet-top.leaflet-right {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        right: 8px !important;
        z-index: 2000;
      }
      .leaflet-top.leaflet-left {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        left: 8px !important;
        z-index: 2000;
      }

      /* Filter-Box: scrollf√§hig und touch-freundlich */
      .filter-box.leaflet-control {
        width: min(52vw, 260px) !important;
        max-height: 48vh;
        overflow: auto;
        border-radius: 14px;
      }
      .filter-box label { padding: 8px 2px; }
      .filter-box input[type="checkbox"] { width: 20px; height: 20px; }

      /* Layer-Control: komfortabler auf Touch */
      .leaflet-control-layers {
        width: min(52vw, 260px) !important;
        border-radius: 14px;
        max-height: 48vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .leaflet-control-layers-toggle { width: 44px; height: 44px; }
      .leaflet-control-layers label { padding: 8px 2px; }

      /* Slider unten als "Bottom Bar" */
      .slider-box {
        left: 8px !important;
        right: 8px !important;
        width: auto !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        background: rgba(255,255,255,0.92) !important;
        backdrop-filter: blur(8px);
      }

      /* Counter √ºber dem Slider, damit nichts √ºberlappt */
      .counter-box {
        right: 8px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 92px) !important;
        border-radius: 12px !important;
      }
    }

    /* Layer-Control: nie "abschneiden" und scrollbar machen */
    .leaflet-top.leaflet-right { z-index: 2000; }
    .leaflet-control-layers { max-height: 70vh; overflow-y: auto; overflow-x: hidden; }


    /* A11y helpers */
    .sr-only{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }
.icon-btn{
  width:36px;
  height:36px;
  border:1px solid #666;
  border-radius:10px;
  background:#f0f0f0;
  cursor:pointer;
  font-size:16px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:0;
  flex: 0 0 auto;
}
.icon-btn:hover{ background:#e0e0e0; }

    /* Button text variants */
    #clear-verbund-btn .btn-short{ display:none; }
    #clear-verbund-btn .btn-full{ display:inline; }

    /* Mobile Slide-In Panel (Filter + Layer) */
    #mobile-panel-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 3500;
    }
    #mobile-panel{
      position: fixed;
      top: var(--search-bottom, 76px);
      right: 0;
      height: calc(100dvh - var(--search-bottom, 76px));
      width: min(84vw, 340px);
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(10px);
      box-shadow: -12px 0 28px rgba(0,0,0,0.22);
      transform: translateX(102%);
      transition: transform .22s ease;
      z-index: 3600;
      padding: 14px 12px calc(env(safe-area-inset-bottom, 0px) + 12px) 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #mobile-panel h3{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: .85;
    }
    #mobile-panel .panel-section{
      overflow: auto;
      border-radius: 14px;
    }
    body.mobile-panel-open #mobile-panel-backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.mobile-panel-open #mobile-panel{
      transform: translateX(0);
    }
    @media (min-width: 721px){
      #mobile-panel, #mobile-panel-backdrop, #mobile-panel-toggle{ display:none !important; }
    }

.control-select {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.2);
  background: white;
}




/* --- Fix: Legacy-Startpunkt-Box ausblenden (falls sie noch existiert) --- */
#homeSelectorBox,
.homeSelectorBox,
.leaflet-control.home-selector,
.leaflet-control.homeSelector {
  display: none !important;
}

/* --- Fix: Seite nicht scrollbar (verhindert wei√üen Leerraum unten auf Mobile) --- */
html, body {
  overflow: hidden;
}

/* --- Slider-Box wirklich als Overlay (nicht im Dokumentfluss) --- */
.slider-box {
  position: fixed !important;
  left: 20px;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
}

/* Mobile: etwas kompakter, damit nichts √ºberlappt */
@media (max-width: 640px){
  .slider-box{
    left: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    max-width: min(320px, calc(100vw - 24px));
    width: calc(100vw - 24px);
  }
}

/* Startpunkt (Dropdown) oberhalb des Sliders */
.startpoint-row{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.startpoint-title{
  font-weight:600;
  font-size:12px;
  opacity:.9;
}
.slider-sep{
  height:1px;
  background: rgba(0,0,0,.12);
  margin: 10px 0 8px 0;
}


/* Label + Fahrzeit in einer Zeile */
.time-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:6px;
}
.time-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
}
.time-value{
  font-weight:700;
  color:#1a73e8;
  white-space:nowrap;
}
</style>

</head>
<body>

<div id="map"></div>

<!-- Counter sichtbare Resorts -->
<div id="resort-counter" class="counter-box">
  0 / 0
</div>

<!-- Suchfeld -->
<form id="resort-search-form" class="search-box" autocomplete="off">
  <label for="resort-search" class="sr-only">Skigebiet suchen</label>
  <div class="search-row">
    <input
      id="resort-search"
      list="resort-datalist"
      type="search"
      inputmode="search"
      enterkeyhint="search"
      autocapitalize="off"
      placeholder="Name eingeben & Enter dr√ºcken..."
    />
    <button id="search-btn" type="submit" title="Suche ausf√ºhren">Go</button>
    <button id="clear-verbund-btn" type="button" disabled class="icon-btn icon-btn--danger" aria-label="Ansicht zur√ºcksetzen" title="Ansicht zur√ºcksetzen (Zoom / Suche)">‚úï</button>
    <button id="mobile-panel-toggle" class="icon-btn" type="button" aria-pressed="false" title="Filter & Layer" aria-label="Filter und Layer √∂ffnen">‚ò∞</button>
    </div>
  <datalist id="resort-datalist"></datalist>
</form>

<!-- Startadresse & Button -->
<div class="home-box">
  <label for="home-input">Startadresse (Adresse oder lat,lon)</label>
  <input
    id="home-input"
    type="text"
    placeholder="z.B. M√ºnchen, Marienplatz oder 48.12,11.57"
  />
  <button id="btn-calc-times" type="button">Fahrzeiten berechnen</button>
</div>

<!-- Fahrzeit-Slider + Startpunkt -->
<div class="slider-box">
  <div class="startpoint-row">    
    <select id="homeSelectSlider" class="control-select" aria-label="Startpunkt ausw√§hlen"></select>
  </div>

  <div class="slider-sep"></div>

  <div class="time-row">
  <label for="time-slider" id="time-slider-title">Max. Fahrzeit</label>
  <span id="time-slider-label" class="time-value">bis ca. 0h 00m</span>
</div>
<input id="time-slider" type="range" min="0" max="100" value="100" />
</div>

<!-- Home Selector Host (Placeholder f√ºr HomeRoutesSelector; Dropdown sitzt im Slider) -->
<div id="homeSelectorBox" class="filter-box leaflet-control" style="display:none;"></div>

<!-- isochroneControl -->
<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Protomaps Leaflet (PMTiles + Vector rendering) -->
<script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>


<!-- Wird sp√§ter f√ºr Live Travel Times im Profil gebraucht -->
<script src="js/config.js"></script>

<script src="js/searchFilter.js"></script>


<script src="js/treeRoutesOverlay.js"></script>
<script src="js/homeRoutesSelector.js"></script>
<script src="js/homeTravelTimes.js"></script>

<script>
  // --------- Basis-Einstellungen ---------
  // ORS_API_KEY wird aus config.js gelesen (nicht in Git einchecken).
  const ORS_API_KEY = (window.APP_CONFIG && window.APP_CONFIG.ORS_API_KEY) ? window.APP_CONFIG.ORS_API_KEY : "DEIN_ORS_API_KEY";

  const MUC_LAT = 48.137;
  const MUC_LON = 11.575;
  const AVG_SPEED_KMH = 70.0;
  
  function getResortNameFromInput(raw) {
    if (!raw) return '';
    const parts = raw.split(/\s[‚Äì-]\s/);
    return parts[0].trim();
  }

  function toRad(x) {
    return x * Math.PI / 180;
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371.0;
    const phi1 = toRad(lat1);
    const phi2 = toRad(lat2);
    const dphi = toRad(lat2 - lat1);
    const dlambda = toRad(lon2 - lon1);
    const a = Math.sin(dphi / 2) ** 2 +
              Math.cos(phi1) * Math.cos(phi2) * Math.sin(dlambda / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  
  function buildDriveText(r) {
    let distTxt = "";
    if (r.distKm != null && isFinite(r.distKm)) {
      distTxt = `${Math.round(r.distKm)} km`;
    }
    let timeTxt = "";
    if (r.travelHours != null && isFinite(r.travelHours)) {
      timeTxt = fmtTime(r.travelHours);
    }

    if (distTxt && timeTxt) return `${distTxt} ¬∑ ca. ${timeTxt}`;
    if (distTxt)           return distTxt;
    if (timeTxt)           return "ca. " + timeTxt;
    return "keine Angabe";
  }

  function makePopupHtml(r) {
    const passes = [];
    if (r.sct) passes.push("Snow Card Tirol");
    if (r.ssc) passes.push("SuperSkiCard");
    if (r.nearMuc && !r.sct && !r.ssc) passes.push("Weitere Gebiete s√ºdlich von M√ºnchen");
    const passesStr = passes.length ? passes.join(", ") : "‚Äì";

    const driveTxt = buildDriveText(r);
    const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;

    let websiteLine = "";
    if (r.website) {
      const url = r.website.startsWith("http") ? r.website : "https://" + r.website;
      const label = url.replace(/^https?:\/\//, "");
      websiteLine = `<b>Website:</b> <a href="${url}" target="_blank" rel="noopener noreferrer">${label}</a><br/>`;
    }

    return `
      <div style="font-size:13px">
        <b>${r.name}</b><br/>
        <b>P√§sse:</b> ${passesStr}<br/>
        <b>Gletscher:</b> ${r.glacier ? "Ja" : "Nein"}<br/>
        ${websiteLine}
        <b>Ab Zuhause:</b> ${driveTxt}<br/>
        <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer">
          In Google Maps √∂ffnen
        </a>
      </div>
    `;
  }
  
  function fmtTime(hoursFloat) {
    const totalMin = Math.round(hoursFloat * 60);
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return `${h}h ${m.toString().padStart(2, "0")}m`;
  }

  function norm(name) {
    return name
      .toLowerCase()
      .replace(/‚Äì/g, "-")
      .replace(/‚Äî/g, "-")
      .replace(/  +/g, " ")
      .trim();
  }

  // --------- Grunddaten ---------
  const sctList = [/* nur noch Referenz, echte Daten aus resorts.json */];
  const sscList = [];
  const nearMucList = [];

  const resorts = {};
  const resortMarkers = {};
  window.__resortsReady = false;
  let minHours = Infinity;
  let maxHours = 0;

  const travelTimeCache = {};
  let originMarker = null;
  
  // Gesamtzahl der Resorts
  let totalResorts = 0;

  // Karte
  const map = L.map("map").setView([47.2, 12.2], 9);
  // Debug/DevTools access
  window.map = map;

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap-Mitwirkende"
  });
  osm.addTo(map);

  // Optional: Topo-Look mit Relief (zeigt H√∂hen/Topologie etwas deutlicher)
  const topo = L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
    maxZoom: 17,
    attribution: "Map data: &copy; OpenStreetMap-Mitwirkende, SRTM | Map style: &copy; OpenTopoMap"
  });

  // --------- PMTiles Overlay (Pisten & Lifte) ---------
  // Lege die Dateien in deinem Projekt z.B. unter /tiles ab:
  //   ./tiles/pistes.pmtiles
  //   ./tiles/lifts.pmtiles
  const PMTILES_PISTES_URL = "./tiles/pistes.pmtiles";
  const PMTILES_LIFTS_URL  = "./tiles/lifts.pmtiles";

  // Protomaps rendert Vector-Tiles als Canvas-Kacheln in Leaflet.
  // (Sehr performant, ideal als Overlay. Interaktion auf einzelne Pisten ist nur eingeschr√§nkt.)
  class LineSymbolizer {
    constructor(styleFn) { this.styleFn = styleFn; }
    draw(ctx, geom, z, feature) {
      const s = this.styleFn(feature.props || {}, z);
      if (!s) return;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.globalAlpha = (s.opacity ?? 1);
      ctx.strokeStyle = s.color;
      ctx.lineWidth = s.width;
      if (s.dash) ctx.setLineDash(s.dash);
      else ctx.setLineDash([]);

      ctx.beginPath();
      // geom: Array<LineString>, each is Array<Point> with {x,y}
      for (const line of geom) {
        for (let i = 0; i < line.length; i++) {
          const p = line[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  // Wichtig: Diese Layernamen ("pistes" / "lifts") m√ºssen beim Erzeugen der PMTiles so gesetzt werden.
  // Wenn du sp√§ter andere Layernamen hast, einfach hier anpassen.
  const PISTES_RULES = [{
    dataLayer: "pistes",
    symbolizer: new LineSymbolizer((props, z) => {
      const d = (props["piste:difficulty"] || "").toLowerCase();
      const width = z < 10 ? 2.0 : z < 12 ? 3.0 : 4.4;

      if (d === "easy" || d === "novice" || d === "blue")  return { color: "#2b6cff", width, opacity: 0.95 };
      if (d === "intermediate" || d === "red")             return { color: "#e53935", width, opacity: 0.95 };
      if (d === "advanced" || d === "expert" || d === "black") return { color: "#111111", width, opacity: 0.95 };
      return { color: "#6f6f6f", width, opacity: 0.9 };
    })
  }];

  const LIFTS_RULES = [{
    dataLayer: "lifts",
    symbolizer: new LineSymbolizer((props, z) => {
      const width = z < 10 ? 1.2 : z < 12 ? 1.8 : 2.4;
      return { color: "#111111", width, opacity: 0.8, dash: [4, 3] };
    })
  }];

  // Overlay-Layer NICHT direkt hinzuf√ºgen (kommt per Layer-Control Checkbox)
  const pistesLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_PISTES_URL,
    paintRules: PISTES_RULES,
    labelRules: []
  }) : null;

  const liftsLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_LIFTS_URL,
    paintRules: LIFTS_RULES,
    labelRules: []
  }) : null;

// Ein Layer f√ºr alle Resort-Marker (Filter steuern Sichtbarkeit)
  const markerLayer = L.layerGroup().addTo(map);
  const COLOR_SCT   = "#9C2419";
  const COLOR_SSC   = "#004A8F";
  const COLOR_BOTH  = "#9C27B0";
  const COLOR_MUC   = "#2E7D32";
  const COLOR_OTHER = "#888888";

  // Counter aktualisieren
  function updateResortCounter() {
    const box = document.getElementById("resort-counter");
    if (!box) return;

    let visible = 0;
    Object.values(resortMarkers).forEach(marker => {
      if (map.hasLayer(marker)) {
        visible++;
      }
    });

    box.textContent = `${visible} / ${totalResorts}`;
  }
  function addResort(name, lat, lon, passType, isGlacier, nearMuc = false, website, groupId = null, groupName = null, entryType = null, entryName = null) {
    const key = norm(name);
    if (!resorts[key]) {
      resorts[key] = {
        name: name,
        lat: lat,
        lon: lon,
        sct: false,
        ssc: false,
        glacier: false,
        nearMuc: false,
        website: website || null,
        groupId: groupId || null,
        groupName: groupName || null,
        entryType: entryType || null,
        entryName: entryName || null
      };
    } else if (website && !resorts[key].website) {
      resorts[key].website = website;
    }
    
    // Gruppierung / Entrypoint (nur setzen, wenn noch nicht vorhanden)
    if (groupId && !resorts[key].groupId) resorts[key].groupId = groupId;
    if (groupName && !resorts[key].groupName) resorts[key].groupName = groupName;
    if (entryType && !resorts[key].entryType) resorts[key].entryType = entryType;
    if (entryName && !resorts[key].entryName) resorts[key].entryName = entryName;
if (passType === "SCT") resorts[key].sct = true;
    if (passType === "SSC") resorts[key].ssc = true;
    if (passType === "MUC") resorts[key].nearMuc = true;
    if (nearMuc) resorts[key].nearMuc = true;
    if (isGlacier) resorts[key].glacier = true;
  }

  function initResortsFromJson(list) {

    list.forEach(r => {
      const name    = r.name;
      const lat     = r.lat;
      const lon     = r.lon;

      const glacier = !!r.glacier;
      const sct     = !!r.sct;
      const ssc     = !!r.ssc;
      const nearMuc = !!r.nearMuc;

      const website = (typeof r.website === "string" && r.website.trim()) ? r.website.trim() : null;

      // Gruppierung / Entrypoints (neues Datenmodell)
      const groupId   = (typeof r.groupId === "string" && r.groupId.trim()) ? r.groupId.trim() : null;
      const groupName = (typeof r.groupName === "string" && r.groupName.trim()) ? r.groupName.trim() : null;
      const entryType = (typeof r.entryType === "string" && r.entryType.trim()) ? r.entryType.trim() : null;
      const entryName = (typeof r.entryName === "string" && r.entryName.trim()) ? r.entryName.trim() : null;

      if (sct) {
        addResort(name, lat, lon, "SCT", glacier, nearMuc, website, groupId, groupName, entryType, entryName);
      }
      if (ssc) {
        addResort(name, lat, lon, "SSC", glacier, nearMuc, website, groupId, groupName, entryType, entryName);
      }
      if (!sct && !ssc) {
        addResort(name, lat, lon, "MUC", glacier, nearMuc, website, groupId, groupName, entryType, entryName);
      }
    });
  }

  function loadResortsAndInit() {
    fetch("data/resorts.json")
      .then(resp => {
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        return resp.json();
      })
      .then(list => {
        initResortsFromJson(list);

        totalResorts = Object.keys(resorts).length;

        buildMarkers();
        window.__resortsReady = true;
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.onResortsReady === "function") {
          try { window.HomeTravelTimes.onResortsReady(); } catch (e) { console.warn(e); }
        }
if (typeof rebuildDatalist === "function") {
          rebuildDatalist();
        }
        updateTimeLabel(100);
        applyTimeFilter(100);
                if (typeof loadTravelTimesJson === "function") {
          loadTravelTimesJson();
        }
      })
      .catch(err => {
        console.error("Fehler beim Laden von resorts.json:", err);
        alert("Fehler beim Laden der Skigebiete (Details in Konsole).");
      });
  }

  function buildMarkers() {
    Object.values(resorts).forEach(r => {
      const passes = [];
      if (r.sct) passes.push("Snow Card Tirol");
      if (r.ssc) passes.push("SuperSkiCard");
      if (r.nearMuc && !r.sct && !r.ssc) passes.push("Extra: ab M√ºnchen");
      const passesStr = passes.length ? passes.join(", ") : "‚Äì";

      let color = COLOR_OTHER;
      if (r.sct && r.ssc)      color = COLOR_BOTH;
      else if (r.sct)          color = COLOR_SCT;
      else if (r.ssc)          color = COLOR_SSC;
      else if (r.nearMuc)      color = COLOR_MUC;

      const distKm   = haversineKm(MUC_LAT, MUC_LON, r.lat, r.lon);
      const estHours = distKm / AVG_SPEED_KMH;
      r.distKm = distKm;
      r.travelHours = estHours;
      if (estHours < minHours) minHours = estHours;
      if (estHours > maxHours) maxHours = estHours;

      const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;
      const driveTxt = `${Math.round(distKm)} km ¬∑ ca. ${fmtTime(estHours)}`;

      let marker;

      if (r.glacier) {
        const glacierIcon = L.divIcon({
          html: `
            <div style="
              width: 26px;
              height: 26px;
              border-radius: 50%;
              border: 2px solid ${color};
              background: white;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 16px;
            ">
              ‚ùÑ
            </div>
          `,
          className: "",
          iconSize: [26, 26],
          iconAnchor: [13, 13],
          popupAnchor: [0, -13]
        });

        marker = L.marker([r.lat, r.lon], { icon: glacierIcon });
      } else {
        marker = L.circleMarker([r.lat, r.lon], {
          radius: 8,
          color: color,
          fillColor: color,
          fillOpacity: 0.95,
          weight: 2
        });
      }

      marker
        .bindPopup(() => makePopupHtml(r))
        .bindTooltip(`${r.name} (${passesStr})`);
      markerLayer.addLayer(marker);
      resortMarkers[norm(r.name)] = marker;
    });

    // einmal initial nach Markerbau updaten
    updateResortCounter();
  }
  const timeSlider = document.getElementById("time-slider");
  

  const baseLayers = {
    "OSM": osm,
    "Topo (Relief)": topo
  };

  const overlays = {};
  if (pistesLayer) overlays["Pisten"] = pistesLayer;
  if (liftsLayer)  overlays["Lifte"]  = liftsLayer;

  window.layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);



// --- Panel: Layer-Control optisch/inhaltlich gliedern (Karte vs Overlays) ---
(function decorateLayerControl(){
  try{
    const lc = window.layerControl;
    const c = lc && lc.getContainer ? lc.getContainer() : document.querySelector('.leaflet-control-layers');
    if (!c) return;

    // Titel (nur einmal)
    if (!c.querySelector('.panel-title')){
      c.insertAdjacentHTML('afterbegin', '<div class="panel-title">Layer</div>');
    }

    // Gruppen√ºberschriften
    const base = c.querySelector('.leaflet-control-layers-base');
    const ov   = c.querySelector('.leaflet-control-layers-overlays');
    if (base && !(base.previousElementSibling && base.previousElementSibling.classList.contains('panel-group-title'))){
      base.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Karte</div>');
    }
    if (ov && !(ov.previousElementSibling && ov.previousElementSibling.classList.contains('panel-group-title'))){
      ov.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Overlays</div>');
    }
  } catch(e){
    console.warn('decorateLayerControl failed', e);
  }
})();
// --------- Suche & Filter initialisieren (ausgelagert in searchFilter.js) ---------
  const ui = window.initSearchAndFilters({
    map,
    resorts,
    resortMarkers,
    markerLayer,
    fmtTime,
    norm,
    getMinHours: () => minHours,
    getMaxHours: () => maxHours,
    updateResortCounter,
    createFilterControl: true,
    createExportControl: true
  });
  window.ui = ui;
// Alte Funktionsnamen weiterhin verf√ºgbar halten (damit bestehender Code unver√§ndert bleibt)
  window.rebuildDatalist   = ui.rebuildDatalist;
  window.updateTimeLabel   = ui.updateTimeLabel;
  window.applyTimeFilter   = ui.applyTimeFilter;
  window.focusResortByName = ui.focusResortByName;
  // Suche & Filter wurden in searchFilter.js ausgelagert.


  // --------- Tree Routes Overlay (Reachability "Chaos"-Layer) ---------
  // Erwartete Dateien: data/routes/home_<homeId>.geojson (z.B. home_muc.geojson)
  // Home-Auswahl erfolgt √ºber das Dropdown (HomeRoutesSelector) und l√§dt die passende Datei.
  let tree = null;
  let currentTreeHomeId = "muc"; // Fallback; wird bei Init vom Selector √ºberschrieben

  function pctToLimitHours(pct) {
    const p = Math.max(0, Math.min(100, Number(pct))) / 100;
    // minHours/maxHours werden aus travel_times.json (oder OSRM/ORS) gesetzt
    if (!isFinite(minHours) || !isFinite(maxHours) || minHours === Infinity) return Infinity;
    return minHours + p * (maxHours - minHours);
  }

  function syncTreeWithUi(uiObj, pct) {
    if (!tree || !uiObj) return;

    // 1) Zeitlimit aus Slider-Prozent
    const limitHours = (pct >= 99) ? Infinity : pctToLimitHours(pct);
    tree.setMaxHours(limitHours);

    // 2) Weitere Filter: Wir √ºbernehmen einfach die aktuell sichtbaren Resorts aus der UI
    //    und zeigen nur deren Routen an.
    const visible = uiObj.getVisibleResorts ? uiObj.getVisibleResorts() : [];
    const visibleSet = new Set(visible.map(r => norm(r.name)));

    tree.setPredicate((props) => {
      const nm = props && (props.name || props.resort_name || props.resort) ? String(props.name || props.resort_name || props.resort) : "";
      return visibleSet.has(norm(nm));
    });
  }

  // Tree Overlay (re-)initialisieren und (optional) in Layer-Control aufnehmen
  async function ensureTreeOverlayForHome(homeId) {
    if (!window.TreeRoutesOverlay) return null;
    const url = `data/routes/home_${homeId}.geojson`;

    // Enabled-Status merken
    const hadTree = !!(tree && tree.getLayer && tree.getLayer());
    const wasEnabled = hadTree ? map.hasLayer(tree.getLayer()) : true; // default: an

    // Alte Instanz entfernen (Layer + Eintrag im LayerControl)
    if (tree && tree.getLayer && tree.getLayer()) {
      const oldLayer = tree.getLayer();
      try { if (map.hasLayer(oldLayer)) map.removeLayer(oldLayer); } catch (_) {}
      try { if (window.layerControl && typeof window.layerControl.removeLayer === "function") window.layerControl.removeLayer(oldLayer); } catch (_) {}
    }

    // Neu initialisieren (preserve enabled state)
    const next = await window.TreeRoutesOverlay.init(map, {
      url,
      enabled: wasEnabled,   // bleibt an/aus wie vorher
      baseOpacity: 0.18
    });

    tree = next;
    currentTreeHomeId = homeId;
    window.treeOverlay = tree;

    // Eintrag (Checkbox) in Layer-Control hinzuf√ºgen (Leaflet setzt checked abh√§ngig von map.hasLayer)
    if (window.layerControl && tree.getLayer && tree.getLayer()) {
      window.layerControl.addOverlay(tree.getLayer(), "Tree Routes");
      // Default/Restore: wenn enabled, Layer auch wirklich auf die Karte legen (damit Checkbox checked ist)
      if (wasEnabled && tree.getLayer && tree.getLayer() && !map.hasLayer(tree.getLayer())) {
        map.addLayer(tree.getLayer());
      }
    }

    // applyFilters hooken: immer wenn Marker-Filter aktualisiert werden, Tree synchronisieren
    if (ui && typeof ui.applyFilters === "function") {
      const _apply = ui.applyFilters;
      if (!_apply.__treeHooked) {
        ui.applyFilters = function (pct) {
          _apply(pct);
          syncTreeWithUi(ui, pct);
        };
        ui.applyFilters.__treeHooked = true;

        // alte Alias-Funktion ebenfalls aktualisieren
        window.applyTimeFilter = ui.applyFilters;
        window.applyFilters = ui.applyFilters;
      }
    }

    // initial sync
    const initialPct = Number(timeSlider?.value ?? 100);
    syncTreeWithUi(ui, initialPct);

    return tree;
  }

  // Expose for home selector
  window.ensureTreeOverlayForHome = ensureTreeOverlayForHome;

  // Initial: versuche mit muc zu laden (wenn Datei fehlt, bleibt es still)
  (async () => {
    try {
      await ensureTreeOverlayForHome(currentTreeHomeId);
    } catch (err) {
      console.warn("TreeRoutesOverlay init skipped/failed:", err);
    }
  })();

  function applyTravelTimesFromMap(ttMap) {
    const resortList = Object.values(resorts);
    minHours = Infinity;
    maxHours = 0;

    resortList.forEach(r => {
      const tt = ttMap[r.name];
      if (tt && typeof tt.hours === "number" && typeof tt.km === "number") {
        r.travelHours = tt.hours;
        r.distKm = tt.km;
        if (tt.hours < minHours) minHours = tt.hours;
        if (tt.hours > maxHours) maxHours = tt.hours;
      }
    });

    if (typeof rebuildDatalist === "function") {
      rebuildDatalist();
    }
    if (typeof timeSlider !== "undefined" && timeSlider) {
      timeSlider.value = 100;
    }
    updateTimeLabel(100);
    applyTimeFilter(100);    
  }

  async function recalcTravelTimesFromOrigin() {
    const input = document.getElementById("home-input");
    const value = input.value.trim();

    let originLat;
    let originLon;

    if (!value) {
      originLat = MUC_LAT;
      originLon = MUC_LON;
    } else if (value.includes(",")) {
      const parts = value.split(",");
      originLat = parseFloat(parts[0]);
      originLon = parseFloat(parts[1]);
      if (!isFinite(originLat) || !isFinite(originLon)) {
        alert("Konnte Eingabe nicht als 'lat,lon' interpretieren.");
        return;
      }
    } else {
      if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
        alert("Bitte ORS_API_KEY in config.js eintragen.");
        return;
      }
      try {
        const url = "https://api.openrouteservice.org/geocode/search?api_key=" +
                    encodeURIComponent(ORS_API_KEY) +
                    "&text=" + encodeURIComponent(value) +
                    "&size=1";
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("Geocoding-Request fehlgeschlagen");
        }
        const data = await resp.json();
        const feats = data.features || [];
        if (!feats.length) {
          alert("Adresse konnte nicht gefunden werden.");
          return;
        }
        const coords = feats[0].geometry.coordinates;
        originLon = coords[0];
        originLat = coords[1];
      } catch (err) {
        console.error("Fehler beim Geocoding:", err);
        alert("Fehler beim Geocoding (Details in Konsole).");
        return;
      }
    }

    if (typeof map !== "undefined") {
      if (originMarker) {
        map.removeLayer(originMarker);
      }
      const originIcon = L.divIcon({
        html: `
          <div style="
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
          ">
            üè†
          </div>
        `,
        className: "",
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
      originMarker = L.marker([originLat, originLon], { icon: originIcon })
        .addTo(map)
        .bindTooltip("Startpunkt", { permanent: false });
    }

    const key = originLat.toFixed(3) + "," + originLon.toFixed(3);

    if (travelTimeCache[key]) {
      applyTravelTimesFromMap(travelTimeCache[key]);
      return;
    }

    const resortList = Object.values(resorts);
    const locations = [[originLon, originLat]].concat(
      resortList.map(r => [r.lon, r.lat])
    );
    const body = {
      locations: locations,
      metrics: ["distance", "duration"],
      units: "km",
      sources: [0],
      destinations: resortList.map((_, idx) => idx + 1)
    };

    if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
      alert("Bitte ORS_API_KEY in config.js eintragen.");
      return;
    }

    try {
      const resp = await fetch("https://api.openrouteservice.org/v2/matrix/driving-car", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": ORS_API_KEY
        },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        throw new Error("Matrix-Request fehlgeschlagen: " + resp.status);
      }
      const data = await resp.json();
      const durations = (data.durations && data.durations[0]) || [];
      const distances = (data.distances && data.distances[0]) || [];

      const ttMap = {};
      resortList.forEach((r, idx) => {
        const durSec = durations[idx];
        const distKm = distances[idx];
        if (typeof durSec === "number" && typeof distKm === "number") {
          const hours = durSec / 3600.0;
          ttMap[r.name] = { hours: hours, km: distKm };
        }
      });

      travelTimeCache[key] = ttMap;
      applyTravelTimesFromMap(ttMap);
    } catch (err) {
      console.error("Fehler beim Abrufen der Matrix:", err);
      alert("Fehler beim Abrufen der Fahrzeiten (Details in Konsole).");
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btn-calc-times");
    if (btn) {
      btn.addEventListener("click", () => {
        recalcTravelTimesFromOrigin();
      });
    }
  });

  function loadTravelTimesJson(homeId) {
    // Kompatibilit√§t: l√§dt vorkomputierte Fahrzeiten pro Home-Profil
    // Erwartet Datei: data/travel_times/home_<homeId>.json
    const stored = (window.HomeTravelTimes && typeof window.HomeTravelTimes.getSelectedHomeId === "function")
      ? window.HomeTravelTimes.getSelectedHomeId()
      : null;

    const hid = homeId || stored || (localStorage.getItem("skimap.selectedHomeId")) || "muc";
    if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
      return window.HomeTravelTimes.load(hid);
    }

    // Fallback (sollte praktisch nie passieren):
    fetch(`data/travel_times/home_${hid}.json`)
      .then(resp => resp.json())
      .then(data => applyTravelTimesFromMap(data))
      .catch(err => {
        console.error("Fehler beim Laden von travel_times (per home), nutze Luftlinie:", err);
        updateTimeLabel(100);
        applyTimeFilter(100);
      });
  }

  
  // --------- Home Dropdown (Tree Routes + Fahrzeiten ausw√§hlen) ---------
  document.addEventListener("DOMContentLoaded", () => {
    if (!window.HomeRoutesSelector) return;

    window.HomeRoutesSelector.init({
      homesUrl: "data/homes.json",
      routesDir: "data/routes",
      routeFile: (homeId) => `data/routes/home_${homeId}.geojson`,
      defaultHomeId: "muc",
      selectId: "homeSelectSlider",
      boxId: "homeSelectorBox",
      desktopHostSelector: ".leaflet-top.leaflet-right",
      mobileHostId: "panel-filters",
      storageKey: "skimap.selectedHomeId",
      onHomeChanged: async (homeId, homeMeta) => {
        // Slider-Label updaten
        const lbl = document.querySelector('.slider-box label[for="time-slider"]');
        if (lbl) lbl.textContent = `Max. Fahrzeit ab ${homeMeta?.name || homeId}`;

        // Fahrzeiten pro Home laden
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.setSelectedHomeId === "function") {
          window.HomeTravelTimes.setSelectedHomeId(homeId);
        }
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
          try { await window.HomeTravelTimes.load(homeId); }
          catch (e) { console.warn("HomeTravelTimes load failed:", e); }
        }

        // Tree-Routes neu laden (ohne Checkbox-Status zu ver√§ndern)
        if (typeof window.ensureTreeOverlayForHome === "function") {
          try { await window.ensureTreeOverlayForHome(homeId); }
          catch (e) { console.warn("ensureTreeOverlayForHome failed:", e); }
        }
      }
    });
  });

document.addEventListener("DOMContentLoaded", () => {
    loadResortsAndInit();
  });

</script>

<div id="mobile-panel-backdrop" aria-hidden="true"></div>
<aside id="mobile-panel" aria-label="Filter und Layer">
  <h3>Filter & Layer</h3>
  <div id="panel-layers" class="panel-section"></div>
  <div id="panel-filters" class="panel-section"></div>
</aside>


<script>
  (function initMobilePanel(){
    const btn = document.getElementById('mobile-panel-toggle');
    const backdrop = document.getElementById('mobile-panel-backdrop');
    const panel = document.getElementById('mobile-panel');
    const panelLayers = document.getElementById('panel-layers');
    const panelFilters = document.getElementById('panel-filters');
    if (!btn || !backdrop || !panel || !panelLayers || !panelFilters) return;

    const mq = window.matchMedia('(max-width: 720px)');
    const isMobile = () => mq && mq.matches;

    // Remember original parents so we can restore on desktop
    let origLayersParent = null, origLayersNext = null;
    let origFiltersParent = null, origFiltersNext = null;

    const setSearchBottomVar = () => {
      const box = document.querySelector('.search-box');
      if (!box) return;
      const r = box.getBoundingClientRect();
      const px = Math.max(56, Math.round(r.bottom + 8)); // +8px spacing
      document.documentElement.style.setProperty('--search-bottom', px + 'px');
    };

    const open = () => {
      document.body.classList.add('mobile-panel-open');
      btn.setAttribute('aria-pressed','true');
      btn.textContent = '‚úï';
      btn.title = 'Panel schlie√üen';
      btn.setAttribute('aria-label', btn.title);

      // On open: re-try moving in case Leaflet created controls late
      moveToPanel({force:true});
    };

    const close = () => {
      document.body.classList.remove('mobile-panel-open');
      btn.setAttribute('aria-pressed','false');
      btn.textContent = '‚ò∞';
      btn.title = 'Filter & Layer';
      btn.setAttribute('aria-label', 'Filter und Layer √∂ffnen');
    };

    btn.addEventListener('click', () => {
      if (document.body.classList.contains('mobile-panel-open')) close();
      else open();
    });
    backdrop.addEventListener('click', close);

    const captureOriginals = (layers, filters) => {
      if (layers && !origLayersParent) {
        origLayersParent = layers.parentNode;
        origLayersNext = layers.nextSibling;
      }
      if (filters && !origFiltersParent) {
        origFiltersParent = filters.parentNode;
        origFiltersNext = filters.nextSibling;
      }
    };

    const restoreFromPanel = () => {
      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');

      if (layers && origLayersParent && layers.parentNode !== origLayersParent) {
        try { origLayersParent.insertBefore(layers, origLayersNext || null); }
        catch (_) { origLayersParent.appendChild(layers); }
      }
      if (filters && origFiltersParent && filters.parentNode !== origFiltersParent) {
        try { origFiltersParent.insertBefore(filters, origFiltersNext || null); }
        catch (_) { origFiltersParent.appendChild(filters); }
      }
    };

    const moveToPanel = ({force=false} = {}) => {
      if (!isMobile()) return false;

      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');

      // If Leaflet hasn't created them yet, keep waiting
      if (!layers && !filters) return false;

      captureOriginals(layers, filters);

      let movedAny = false;
      if (layers && (!panelLayers.contains(layers) || force)) {
        panelLayers.appendChild(layers);
        movedAny = true;
      }
      if (filters && (!panelFilters.contains(filters) || force)) {
        panelFilters.appendChild(filters);
        movedAny = true;
      }
      return movedAny || (!!layers && !!filters && panelLayers.contains(layers) && panelFilters.contains(filters));
    };

    // Keep trying for a short while (Leaflet creates controls asynchronously)
    let attempts = 0;
    const timer = setInterval(() => {
      attempts++;
      setSearchBottomVar();

      if (isMobile()) {
        const done = moveToPanel();
        if (done || attempts > 80) clearInterval(timer);
      } else {
        restoreFromPanel();
        if (attempts > 10) clearInterval(timer);
      }
    }, 200);

    const onResize = () => {
      setSearchBottomVar();
      if (isMobile()) {
        // Move again (e.g., after rotate)
        moveToPanel({force:true});
        close(); // start closed for more map area
      } else {
        close();
        restoreFromPanel();
      }
    };
    window.addEventListener('resize', onResize);
    if (mq && mq.addEventListener) mq.addEventListener('change', onResize);

    // Init
    setSearchBottomVar();
    close();
  })();
</script>

</body>
</html>