<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Ski-Pässe: Snow Card Tirol & SuperSkiCard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon-32.png" sizes="32x32">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">


  <style>
    
/* --- Unified Control Cards (Layer / Filter / Export) --- */
:root{
  --panel-bg: #ffffff;
  --panel-border: rgba(0,0,0,0.18);
  --panel-radius: 14px;
  --panel-shadow: 0 8px 22px rgba(0,0,0,0.16);
  --panel-pad: 10px 12px;
  --panel-title-size: 13px;
  --panel-title-weight: 700;
  --panel-muted: rgba(0,0,0,0.62);
  --control-gap: 10px;
}

.panel-card{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  box-sizing: border-box;
}

.panel-title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

.panel-group-title{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .02em;
  text-transform: uppercase;
  color: var(--panel-muted);
  margin: 10px 0 6px 0;
}

.panel-card label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
  user-select:none;
}
.panel-card input[type="checkbox"],
.panel-card input[type="radio"]{
  margin:0;
}

/* Desktop: rechte Control-Spalte sauber stapeln */
.leaflet-top.leaflet-right{
  display:flex;
  flex-direction:column;
  gap: var(--control-gap);
}
.leaflet-top.leaflet-right .leaflet-control{
  margin: 0 !important; /* gap regelt Abstand */
}

/* Stack-Reihenfolge + Scroll, damit auf Desktop keine Controls "verschwinden" */
.leaflet-top.leaflet-right{
  max-height: calc(100% - 12px);
  overflow-y: auto;
  padding-right: 2px;
}
.leaflet-top.leaflet-right .leaflet-control-layers{ order: 1; }
.leaflet-top.leaflet-right .filter-box.leaflet-control{ order: 2; }
.leaflet-top.leaflet-right .export-box.leaflet-control{ order: 3; }

/* Filter-Labels sauber untereinander */
.filter-box label{
  display:flex;
  align-items:center;
  gap:8px;
  width:100%;
  margin: 6px 0;
}
.filter-box input[type="checkbox"]{ margin:0; }

/* Export-Hinweis komplett ausblenden (falls vorhanden) */
.export-box .hint{ display:none; }

/* Export-Buttons etwas kompakter */
.export-box button{
  height: 32px;
  font-size: 12px;
  border-radius: 10px;
  margin-top: 6px;
}

/* --- Filter-Box --- */
.filter-box.leaflet-control,
.export-box.leaflet-control,
.leaflet-control-layers{
  width: 210px;
}
.filter-box.leaflet-control,
.export-box.leaflet-control{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  font-size: 13px;
  line-height: 1.35;
  box-sizing:border-box;
  width: 210px;
}
.filter-box .title,
.export-box .title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

/* Filter-Gruppenüberschriften */
.filter-box .filter-group-title{
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.03em;
  color: rgba(0,0,0,0.5);
  margin: 12px 0 6px 0;
  padding-top: 8px;
  border-top: 1px solid rgba(0,0,0,0.1);
}
.filter-box .filter-group-title:first-of-type{
  margin-top: 4px;
  padding-top: 0;
  border-top: none;
}

/* Leaflet Layers Control wie Panel-Card */
.leaflet-control-layers{
  width: 210px;
  background: var(--panel-bg) !important;
  padding: var(--panel-pad) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--panel-radius) !important;
  box-shadow: var(--panel-shadow) !important;
}
.leaflet-control-layers .leaflet-control-layers-separator{
  border-top: 1px solid rgba(0,0,0,0.12);
  margin: 8px 0;
}
.leaflet-control-layers label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.leaflet-control-layers input{
  margin: 0;
}

/* Export Buttons etwas "ruhiger" */
.export-box button{
  width:100%;
  height: 36px;
  padding: 0 10px;
  margin: 6px 0 0 0;
  font-size: 13px;
  font-weight: 600;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,0.35);
  background:#f3f3f3;
  cursor:pointer;
}
.export-box button:hover{ background:#e9e9e9; }
.export-box .hint{
  margin-top:8px;
  font-size:11px;
  color: rgba(0,0,0,0.68);
}
html, body {
      height: 100%;
      margin: 0;
    }
    :root { --app-h: 100dvh; }
    @supports not (height: 100dvh) { :root { --app-h: 100vh; } }
    #map {
      height: var(--app-h);
      width: 100vw;
    }

    .legend-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
      background: white;
      padding: 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
    }
.search-box {
  position: fixed !important;
  top: 10px;
  left: 50px;
  z-index: 10000;
  background: white;
  padding: 10px 10px 12px 10px;
  width: 390px;
  max-width: calc(100vw - 40px);
  box-sizing: border-box;
  border: 1px solid #888;
  font-size: 13px;
  line-height: 1.35;
  box-shadow: 0 8px 22px rgba(0,0,0,0.16);
  border-radius: 12px;
}
.search-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
.search-box input {
  width: 100%;
  height: 36px;
  padding: 8px 10px;
  font-size: 14px;
  border: 1px solid #bbb;
  border-radius: 10px;
  box-sizing: border-box;
  outline: none;
}
.search-box input:focus {
  border-color: #777;
}
.search-row {
  display: flex;
  gap: 8px;
  align-items: stretch;
  flex-wrap: nowrap;
}
.search-row input {
      flex: 1 1 auto;
      min-width: 0;
    }
#search-btn {
  flex: 0 0 auto;
  height: 36px;
  padding: 0 12px;
  font-size: 13px;
  font-weight: 600;
  border: 1px solid #666;
  border-radius: 10px;
  background: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
}
#search-btn:hover{ background:#e0e0e0; }
#clear-verbund-btn {
  flex: 0 0 auto;
}
#clear-verbund-btn:disabled {
  opacity: 0.55;
  cursor: default;
}
#clear-verbund-btn:disabled {
      opacity: 0.55;
      cursor: default;
    }
.slider-box {
      position: fixed;
      bottom: 110px;        /* sitzt über der Legende */
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px); /* mobil: passt sich an */
      box-sizing: border-box;
    }

    .slider-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .slider-box input[type="range"] {
      width: 100%;
    }
    .slider-box .time-label {
      margin-top: 4px;
      font-size: 12px;
      color: #444;
    }

    /* Box für Startadresse & Button */
    .home-box {
      position: fixed;
      bottom: 120px;           
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px);
      box-sizing: border-box;
    }

    /* Desktop: Home-Box ausblenden (Dropdown sitzt oben im Slider) */
    @media (min-width: 721px){
      .home-box{ display:none !important; }
    }

    .home-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
    .home-box input {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border: 1px solid #bbb;
      border-radius: 3px;
      box-sizing: border-box;
      margin-bottom: 6px;
    }
    .home-box button {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border-radius: 3px;
      border: 1px solid #666;
      background: #f0f0f0;
      cursor: pointer;
    }
    .home-box button:hover {
      background: #e0e0e0;
    }

    /* Counter unten rechts */
    .counter-box {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      background: white;
      padding: 6px 10px;
      border: 1px solid #888;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
    }
  
    /* Responsive: Mobile Layout */
    @media (max-width: 720px) {
      /* --- Strong overrides for mobile topbar layout --- */
      .search-box .search-row{ flex-wrap: nowrap !important; }
      #resort-search{ min-width: 0 !important; }
      #search-btn{ min-width: 56px; }
      #clear-verbund-btn,
      #mobile-panel-toggle{ width: 44px; min-width: 44px; height: 44px; padding: 0 !important; }
      #clear-verbund-btn{ border-radius: 10px !important; }

      /* Zoom: unten rechts über dem Counter */
      .leaflet-control-zoom{
        position: fixed !important;
        right: 12px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 64px) !important;
        left: auto !important;
        top: auto !important;
        z-index: 4000 !important;
      }
      .leaflet-control-zoom a{
        width: 40px;
        height: 40px;
        line-height: 40px;
        font-size: 20px;
      }

      /* Auf Mobile aufräumen */
      .home-box { display: none !important; }               /* Startadresse ausblenden */
      /* Export ausblenden */
      .legend-box { display: none !important; }             /* optional: Legende ausblenden */

      /* Suchleiste oben als "Card" */
      .search-box label{ display:none; }

      /* Top-Bar: Input + Go + X + Menü in EINER Zeile */
      #search-btn{
        height: 44px;
        padding: 0 10px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
        min-width: 56px;
        flex: 0 0 auto !important;
      }
      #clear-verbund-btn,
      #mobile-panel-toggle{
        width: 44px;
        min-width: 44px;
        height: 44px;
        padding: 0 !important;
        flex: 0 0 auto !important;
      }
      /* falls irgendwo noch alte Flex-Regeln greifen */
      #clear-verbund-btn{ margin-left: 0 !important; }

      .search-box {
        top: calc(env(safe-area-inset-top, 0px) + 8px) !important;
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        max-width: none !important;
        padding: 8px 10px 10px 10px !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        backdrop-filter: blur(8px);
        background: rgba(255,255,255,0.92) !important;
      }
      .search-box label {
        display: block;
        font-size: 14px !important;
        margin-bottom: 6px !important;
      }

      .search-row { gap: 8px !important; flex-wrap: wrap !important; }

      #resort-search {
        flex: 1 1 220px !important;
        min-width: 180px;
        height: 44px;
        padding: 10px 12px !important;
        font-size: 16px !important; /* verhindert iOS auto-zoom */
        border-radius: 10px !important;
      }

      #search-btn,
      #clear-verbund-btn {
        height: 44px;
        padding: 0 12px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
      }
/* Leaflet Controls nicht unter der Suchbox verstecken */
      .leaflet-top.leaflet-right {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        right: 12px !important;
        z-index: 2000;
      }
      .leaflet-top.leaflet-left {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        left: 8px !important;
        z-index: 2000;
      }

      /* Filter-Box: scrollfähig und touch-freundlich */
      .filter-box.leaflet-control {
        width: min(52vw, 260px) !important;
        max-height: 48vh;
        overflow: auto;
        border-radius: 14px;
      }
      .filter-box label { padding: 8px 2px; }
      .filter-box input[type="checkbox"] { width: 20px; height: 20px; }

      /* Layer-Control: komfortabler auf Touch */
      .leaflet-control-layers {
        width: min(52vw, 260px) !important;
        border-radius: 14px;
        max-height: 48vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .leaflet-control-layers-toggle { width: 44px; height: 44px; }
      .leaflet-control-layers label { padding: 8px 2px; }

      /* Slider unten als "Bottom Bar" */
      .slider-box {
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        background: rgba(255,255,255,0.92) !important;
        backdrop-filter: blur(8px);
        transition: transform 0.3s ease;
      }

      /* Toggle-Button für mobile Slider-Box */
      .slider-box-toggle {
        display: flex !important;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 28px;
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
        margin: -8px 0 4px 0;
      }
      .slider-box-toggle .toggle-icon {
        font-size: 14px;
        color: #666;
        transition: transform 0.3s ease;
      }
      .slider-box.collapsed .toggle-icon {
        transform: rotate(180deg);
      }
      .slider-box.collapsed .slider-box-content {
        display: none;
      }
      .slider-box.collapsed {
        padding: 4px 12px !important;
      }

      /* Counter über dem Slider, damit nichts überlappt */
      .counter-box {
        right: 12px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 12px) !important;
        border-radius: 12px !important;
      }
    }

    /* Layer-Control: nie "abschneiden" und scrollbar machen */
    .leaflet-top.leaflet-right { z-index: 2000; }
    .leaflet-control-layers { max-height: 70vh; overflow-y: auto; overflow-x: hidden; }


    /* A11y helpers */
    .sr-only{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }
.icon-btn{
  width:36px;
  height:36px;
  border:1px solid #666;
  border-radius:10px;
  background:#f0f0f0;
  cursor:pointer;
  font-size:16px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:0;
  flex: 0 0 auto;
}
.icon-btn:hover{ background:#e0e0e0; }

    /* Button text variants */
    #clear-verbund-btn .btn-short{ display:none; }
    #clear-verbund-btn .btn-full{ display:inline; }

    /* Mobile Slide-In Panel (Filter + Layer) */
    #mobile-panel-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 3500;
    }
    #mobile-panel{
      position: fixed;
      top: var(--search-bottom, 76px);
      right: 0;
      height: calc(100dvh - var(--search-bottom, 76px));
      width: min(84vw, 340px);
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(10px);
      box-shadow: -12px 0 28px rgba(0,0,0,0.22);
      transform: translateX(102%);
      transition: transform .22s ease;
      z-index: 3600;
      padding: 14px 12px calc(env(safe-area-inset-bottom, 0px) + 12px) 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Controls im Mobile-Panel sollen volle Breite nutzen */
    #mobile-panel .leaflet-control,
    #mobile-panel .leaflet-control-layers,
    #mobile-panel .filter-box.leaflet-control{
      width: 100% !important;
      max-width: none !important;
    }
    #mobile-panel .leaflet-control-layers-list{
      margin: 0 !important;
    }
    #mobile-panel h3{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: .85;
    }
    #mobile-panel .panel-section{
      overflow: auto;
      border-radius: 14px;
    }
    body.mobile-panel-open #mobile-panel-backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.mobile-panel-open #mobile-panel{
      transform: translateX(0);
    }
    @media (min-width: 721px){
      #mobile-panel, #mobile-panel-backdrop, #mobile-panel-toggle{ display:none !important; }
    }

.control-select {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.2);
  background: white;
}




/* --- Fix: Legacy-Startpunkt-Box ausblenden (falls sie noch existiert) --- */
#homeSelectorBox,
.homeSelectorBox,
.leaflet-control.home-selector,
.leaflet-control.homeSelector {
  display: none !important;
}

/* --- Fix: Seite nicht scrollbar (verhindert weißen Leerraum unten auf Mobile) --- */
html, body {
  overflow: hidden;
}

/* --- Slider-Box wirklich als Overlay (nicht im Dokumentfluss) --- */
.slider-box {
  position: fixed !important;
  left: 20px;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
}

/* Toggle-Button nur auf Mobile anzeigen */
.slider-box-toggle {
  display: none;
}

/* Mobile: etwas kompakter, damit nichts überlappt */
@media (max-width: 640px){
  .slider-box{
    left: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    max-width: min(320px, calc(100vw - 24px));
    width: calc(100vw - 24px);
  }
}

/* Startpunkt (Dropdown) oberhalb des Sliders */
.startpoint-row{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.startpoint-title{
  font-weight:600;
  font-size:12px;
  opacity:.9;
}
.slider-sep{
  height:1px;
  background: rgba(0,0,0,.12);
  margin: 10px 0 8px 0;
}


/* Label + Fahrzeit in einer Zeile */
.time-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:6px;
}
.time-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
}
.time-value{
  font-weight:700;
  color:#1a73e8;
  white-space:nowrap;
}

/* Neue Filter-Slider Zeilen */
.filter-slider-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:4px;
  margin-top:8px;
}
.filter-slider-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
  font-size:12px;
}
.filter-value{
  font-weight:600;
  color:#1a73e8;
  white-space:nowrap;
  font-size:12px;
}

/* Mobile Panel: etwas aufgeräumter */
#mobile-panel h3{
  letter-spacing: .2px;
}
#mobile-panel .panel-section{
  display:flex;
  flex-direction:column;
  gap: 10px;
}

/* --- Desktop: Home-Box dauerhaft ausblenden (Dropdown sitzt im Slider) --- */
@media (min-width: 721px){
  .home-box{ display:none !important; }
}

/* --- Desktop: sauberer Stack in Leaflet top-right --- */
.desktop-control-stack{
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.desktop-control-stack .leaflet-control{
  margin: 0 !important;
}

/* --- Mobile: Counter wirklich ganz nach unten rechts --- */
@media (max-width: 720px){
  .counter-box{
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 12px) !important;
  }
}

/* --- Mobile Panel: Accordion --- */
.panel-accordion{
  margin: 0;
  padding: 0;
  border: 0;
  background: transparent;
}
#mobile-panel details.panel-accordion > summary{
  list-style: none;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  font-weight: 800;
  font-size: 14px;
  padding: 6px 2px;
  margin: 0;
}
#mobile-panel details.panel-accordion > summary::-webkit-details-marker{ display:none; }
#mobile-panel details.panel-accordion > summary::after{
  content: "▾";
  opacity: .65;
  font-size: 14px;
  transform: translateY(-1px);
}
#mobile-panel details.panel-accordion[open] > summary::after{ content: "▴"; }
#mobile-panel details.panel-accordion + details.panel-accordion{ margin-top: 8px; }



/* --- Last search highlight (ring + subtle pulse) --- */
.leaflet-interactive.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}
img.leaflet-marker-icon.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}

.last-search-indicator {
  /* color of the ring (override Leaflet default path styling) */
  stroke: rgba(255, 204, 0, 0.95);
  stroke-width: 3;
  fill: transparent;
}
.last-search-indicator.pulse {
  animation: lastSearchRing 1.2s ease-out 0s 1;
  transform-origin: center;
}

@keyframes lastSearchRing {
  0%   { opacity: 1; transform: scale(0.6); }
  100% { opacity: 0; transform: scale(1.8); }
}
@keyframes lastSearchBounce {
  0%   { transform: translateY(0); }
  20%  { transform: translateY(-10px); }
  45%  { transform: translateY(0); }
  65%  { transform: translateY(-6px); }
  100% { transform: translateY(0); }
}


/* --- FIX: Desktop right controls unified width + edge spacing --- */
:root{
  --right-controls-w: 210px;
  --right-controls-pad: 12px;
}

/* Abstand zum rechten/oberen Rand (wirkt wie "margin" zur Karte) */
.leaflet-top.leaflet-right{
  padding-right: var(--right-controls-pad) !important;
  padding-top: var(--right-controls-pad) !important;
}

/* Alle Panel-Controls (Layers / Filters / Export) exakt gleich breit (outer width) */
.leaflet-top.leaflet-right .leaflet-control-layers,
.leaflet-top.leaflet-right .filter-box.leaflet-control,
.leaflet-top.leaflet-right .export-box.leaflet-control{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important; /* Leaflet layers war sonst content-box -> wird breiter */
}

/* Sicherheit: auch im expanded state gleich breit */
.leaflet-top.leaflet-right .leaflet-control-layers.leaflet-control-layers-expanded{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important;
}



/* --- FIX: Unified UI font sizes (side panel + right controls) --- */
:root{
  --ui-font-size: 14px;
  --ui-font-size-small: 12px;
  --ui-font-size-title: 14px;
}

/* Desktop right controls */
.leaflet-top.leaflet-right .leaflet-control{
  font-size: var(--ui-font-size) !important;
}

/* Mobile side panel: accordion titles + all Leaflet controls inside */
#mobile-panel details.panel-accordion > summary{
  font-size: var(--ui-font-size-title) !important;
}

#mobile-panel .leaflet-control,
#mobile-panel .leaflet-control-layers,
#mobile-panel .filter-box,
#mobile-panel .export-box{
  font-size: var(--ui-font-size) !important;
}

#mobile-panel .leaflet-control-layers label,
#mobile-panel .leaflet-control-layers-list,
#mobile-panel .filter-box label{
  font-size: var(--ui-font-size) !important;
}

/* Small caps headings inside Leaflet layer control (KARTE / OVERLAYS) */
#mobile-panel .leaflet-control-layers-base,
#mobile-panel .leaflet-control-layers-overlays{
  font-size: var(--ui-font-size-small) !important;
}

/* Export buttons in panel/desktop */
.export-box button{
  font-size: var(--ui-font-size) !important;
}


/* --- Font: modern, highly legible on mobile + desktop (no external downloads) --- */
:root{
  /* "Inter" if installed, otherwise system UI fonts */
  --ui-font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}

/* Apply everywhere */
html, body{
  font-family: var(--ui-font-family) !important;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

button, input, select, textarea{
  font-family: var(--ui-font-family) !important;
}

/* Leaflet UI inherits reliably */
.leaflet-container,
.leaflet-control,
.leaflet-popup,
.leaflet-tooltip{
  font-family: var(--ui-font-family) !important;
}


/* --- Unified checkbox/radio sizing (mobile + desktop) --- */
:root{
  --ui-check-size: 18px;   /* try 16-20px */
  --ui-check-scale: 1.1;   /* helps on browsers that ignore width/height on native inputs */
}

/* Target Leaflet layers control + our filter box (desktop) */
.leaflet-control-layers input[type="checkbox"],
.leaflet-control-layers input[type="radio"],
.filter-box input[type="checkbox"],
.filter-box input[type="radio"],
.export-box input[type="checkbox"],
.export-box input[type="radio"],
/* Target everything inside the mobile side panel */
#mobile-panel input[type="checkbox"],
#mobile-panel input[type="radio"]{
  inline-size: var(--ui-check-size);
  block-size: var(--ui-check-size);
  transform: scale(var(--ui-check-scale));
  transform-origin: center;
  vertical-align: middle;
  margin-right: 8px;
}

/* Keep label text nicely aligned */
.leaflet-control-layers label,
.filter-box label,
#mobile-panel label{
  line-height: 1.35;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* When using flex+gap, don't double-space from margin-right */
.leaflet-control-layers label input,
.filter-box label input,
#mobile-panel label input{
  margin-right: 0;
}


/* --- FIX: Mobile panel horizontal overflow (Layers control was wider due to content-box + padding) --- */
#mobile-panel .panel-section{
  overflow-x: hidden !important;  /* prevent sideways scroll */
  overflow-y: auto !important;
}

#mobile-panel .leaflet-control-layers,
#mobile-panel .leaflet-control-layers.leaflet-control-layers-expanded{
  box-sizing: border-box !important; /* include padding/border in width */
  max-width: 100% !important;
  width: 100% !important;
}


/* --- FIX: Filter box tiny horizontal scroll in mobile panel --- */
#mobile-panel .filter-box.leaflet-control{
  box-sizing: border-box !important;
  width: 100% !important;
  max-width: 100% !important;
  overflow-x: hidden !important; /* keep vertical scroll, kill horizontal */
}

/* Some browsers still create 1–2px overflow due to label/gap -> clamp */
#mobile-panel .filter-box.leaflet-control *{
  max-width: 100% !important;
}

/* GPS toggle inside export box */
.export-box label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.export-box .gps-hint{
  font-size: 11px;
  color: rgba(0,0,0,0.68);
  margin-top: 4px;
}


/* GPS center button */
.gps-control .gps-row{
  display:flex;
  align-items:center;
  gap:10px;
}
.gps-control .gps-center-btn{
  margin-left:auto;
  padding: 4px 8px;
  font-size: 12px;
  line-height: 1.2;
  border: 1px solid rgba(0,0,0,0.18);
  border-radius: 10px;
  background: rgba(255,255,255,0.9);
  cursor: pointer;
}
.gps-control .gps-center-btn:active{
  transform: translateY(1px);
}

/* GPS Map Button (standalone, above zoom controls on mobile) */
.gps-map-btn-container {
  margin-bottom: 10px !important;
  box-shadow: 0 1px 5px rgba(0,0,0,0.25) !important;
  border-radius: 4px !important;
  overflow: hidden;
  border: none !important;
}
.gps-map-btn {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 34px !important;
  height: 34px !important;
  line-height: 34px !important;
  padding: 0 !important;
  margin: 0 !important;
  background: #fff;
  color: #666;
  text-decoration: none;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease;
  border: none !important;
}
.gps-map-btn:hover {
  background: #f5f5f5;
  color: #333;
}
.gps-map-btn:active {
  background: #e8e8e8;
}
.gps-map-btn.gps-active {
  background: #4285F4;
  color: #fff;
}
.gps-map-btn.gps-active:hover {
  background: #3367D6;
  color: #fff;
}
.gps-map-btn svg {
  display: block;
}

/* Desktop: hide map button, use panel checkbox instead */
@media (min-width: 721px) {
  .gps-map-btn-container {
    display: none !important;
  }
}

/* Mobile: GPS button fixed above zoom controls */
@media (max-width: 720px) {
  .gps-map-btn-container {
    position: fixed !important;
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 156px) !important;
    left: auto !important;
    top: auto !important;
    z-index: 4000 !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3) !important;
  }
  .gps-map-btn {
    width: 40px;
    height: 40px;
  }
  .gps-map-btn svg {
    width: 22px;
    height: 22px;
  }
}

</style>

</head>
<body>

<div id="map"></div>

<!-- Counter sichtbare Resorts -->
<div id="resort-counter" class="counter-box">
  0 / 0
</div>

<!-- Suchfeld -->
<form id="resort-search-form" class="search-box" autocomplete="off">
  <label for="resort-search" class="sr-only">Skigebiet suchen</label>
  <div class="search-row">
    <input
      id="resort-search"
      list="resort-datalist"
      type="search"
      inputmode="search"
      enterkeyhint="search"
      autocapitalize="off"
      placeholder="Let's..."
    />
    <button id="search-btn" type="submit" title="Suche ausführen">Go</button>
    <button id="clear-verbund-btn" type="button" disabled class="icon-btn icon-btn--danger" aria-label="Verbundfilter aufheben" title="Verbundfilter aufheben">✕</button>
    <button id="mobile-panel-toggle" class="icon-btn" type="button" aria-pressed="false" title="Filter & Layer" aria-label="Filter und Layer öffnen">☰</button>
    </div>
  <datalist id="resort-datalist"></datalist>
</form>

<!-- Startadresse & Button -->
<div class="home-box">
  <label for="home-input">Startadresse (Adresse oder lat,lon)</label>
  <input
    id="home-input"
    type="text"
    placeholder="z.B. München, Marienplatz oder 48.12,11.57"
  />
  <button id="btn-calc-times" type="button">Fahrzeiten berechnen</button>
</div>

<!-- Fahrzeit-Slider + Startpunkt -->
<div class="slider-box" id="slider-box">
  <button type="button" id="slider-box-toggle" class="slider-box-toggle" aria-label="Filter ein-/ausklappen" aria-expanded="true">
    <span class="toggle-icon">&#9660;</span>
  </button>
  <div class="slider-box-content">
  <div class="startpoint-row">
    <select id="homeSelectSlider" class="control-select" aria-label="Startpunkt auswählen"></select>
  </div>

  <div class="slider-sep"></div>

  <div class="time-row">
  <label for="time-slider" id="time-slider-title">Max. Fahrzeit</label>
  <span id="time-slider-label" class="time-value">bis ca. 0h 00m</span>
</div>
<input id="time-slider" type="range" min="0" max="100" value="100" />

  <div class="slider-sep"></div>

  <!-- Neue Filter: Pistenkilometer, Lifte, Höhe -->
  <div class="filter-slider-row">
    <label for="pistes-slider">Min. Pistenkilometer</label>
    <span id="pistes-slider-label" class="filter-value">0 km</span>
  </div>
  <input id="pistes-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="lifts-slider">Min. Lifte</label>
    <span id="lifts-slider-label" class="filter-value">0</span>
  </div>
  <input id="lifts-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="elevation-slider">Min. Höhe</label>
    <span id="elevation-slider-label" class="filter-value">0 m</span>
  </div>
  <input id="elevation-slider" type="range" min="0" max="100" value="0" />
  </div><!-- /.slider-box-content -->
</div>

<!-- Home Selector Host (Placeholder für HomeRoutesSelector; Dropdown sitzt im Slider) -->
<div id="homeSelectorBox" class="filter-box leaflet-control" style="display:none;"></div>

<!-- isochroneControl -->
<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Protomaps Leaflet (PMTiles + Vector rendering) -->
<script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>

<!-- Wird später für Live Travel Times im Profil gebraucht -->
<script src="js/config.js"></script>

<script src="js/searchFilter.js"></script>


<script src="js/treeRoutesOverlay.js"></script>
<script src="js/homeRoutesSelector.js"></script>
<script src="js/homeTravelTimes.js"></script>


<script src="js/gpsControl.js"></script>
<script>
  // --------- Basis-Einstellungen ---------
  // ORS_API_KEY wird aus config.js gelesen (nicht in Git einchecken).
  const ORS_API_KEY = (window.APP_CONFIG && window.APP_CONFIG.ORS_API_KEY) ? window.APP_CONFIG.ORS_API_KEY : "DEIN_ORS_API_KEY";

  const MUC_LAT = 48.137;
  const MUC_LON = 11.575;
  const AVG_SPEED_KMH = 70.0;
  
  function getResortNameFromInput(raw) {
    if (!raw) return '';
    const parts = raw.split(/\s[–-]\s/);
    return parts[0].trim();
  }

  function toRad(x) {
    return x * Math.PI / 180;
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371.0;
    const phi1 = toRad(lat1);
    const phi2 = toRad(lat2);
    const dphi = toRad(lat2 - lat1);
    const dlambda = toRad(lon2 - lon1);
    const a = Math.sin(dphi / 2) ** 2 +
              Math.cos(phi1) * Math.cos(phi2) * Math.sin(dlambda / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  
  function buildDriveText(r) {
    let distTxt = "";
    if (r.distKm != null && isFinite(r.distKm)) {
      distTxt = `${Math.round(r.distKm)} km`;
    }
    let timeTxt = "";
    if (r.travelHours != null && isFinite(r.travelHours)) {
      timeTxt = fmtTime(r.travelHours);
    }

    if (distTxt && timeTxt) return `${distTxt} · ca. ${timeTxt}`;
    if (distTxt)           return distTxt;
    if (timeTxt)           return "ca. " + timeTxt;
    return "keine Angabe";
  }

  function makePopupHtml(r) {
    const hasSct = hasPass(r, PASS_ID_SCT);
    const hasSsc = hasPass(r, PASS_ID_SSC);

    const passes = [];
    if (hasSct) passes.push("Snow Card Tirol");
    if (hasSsc) passes.push("SuperSkiCard");
    if (r.nearMuc && !hasSct && !hasSsc) passes.push("Weitere Gebiete südlich von München");
    const passesStr = passes.length ? passes.join(", ") : "–";

    const driveTxt = buildDriveText(r);
    const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;

    let websiteLine = "";
    if (r.website) {
      const url = r.website.startsWith("http") ? r.website : "https://" + r.website;
      const label = url.replace(/^https?:\/\//, "");
      websiteLine = `<b>Website:</b> <a href="${url}" target="_blank" rel="noopener noreferrer">${label}</a><br/>`;
    }

    return `
      <div style="font-size:13px">
        <b>${r.name}</b><br/>
        <b>Pässe:</b> ${passesStr}<br/>
        <b>Gletscher:</b> ${r.glacier ? "Ja" : "Nein"}<br/>
        ${websiteLine}
        <b>Ab Zuhause:</b> ${driveTxt}<br/>
        <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer">
          In Google Maps öffnen
        </a>
      </div>
    `;
  }
  
  function fmtTime(hoursFloat) {
    const totalMin = Math.round(hoursFloat * 60);
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return `${h}h ${m.toString().padStart(2, "0")}m`;
  }

  function norm(name) {
    return name
      .toLowerCase()
      .replace(/–/g, "-")
      .replace(/—/g, "-")
      .replace(/  +/g, " ")
      .trim();
  }

  // Pass-IDs aus der Datenbank
  const PASS_ID_SCT = "snowcard-tirol";
  const PASS_ID_SSC = "superskicard";

  // Hilfsfunktion: Prüft ob ein Resort einen bestimmten Pass hat
  function hasPass(r, passId) {
    if (!r.passes || !Array.isArray(r.passes)) return false;
    return r.passes.some(p => p.stable_id === passId);
  }

  // --------- Grunddaten ---------
  const sctList = [/* nur noch Referenz, echte Daten aus resorts.json */];
  const sscList = [];
  const nearMucList = [];

  const resorts = {};
  const resortMarkers = {};
  window.__resortsReady = false;
  let minHours = Infinity;
  let maxHours = 0;

  const travelTimeCache = {};
  let originMarker = null;
  
  // Gesamtzahl der Resorts
  let totalResorts = 0;

  // Karte
  const map = L.map("map").setView([47.2, 12.2], 9);
  // Debug/DevTools access
  window.map = map;

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap-Mitwirkende"
  });
  osm.addTo(map);

  // Optional: Topo-Look mit Relief (zeigt Höhen/Topologie etwas deutlicher)
  const topo = L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
    maxZoom: 17,
    attribution: "Map data: &copy; OpenStreetMap-Mitwirkende, SRTM | Map style: &copy; OpenTopoMap"
  });

  // --------- PMTiles Overlay (Pisten & Lifte) ---------
  // Lege die Dateien in deinem Projekt z.B. unter /tiles ab:
  //   ./tiles/pistes.pmtiles
  //   ./tiles/lifts.pmtiles
  const PMTILES_PISTES_URL = "./tiles/pistes.pmtiles";
  const PMTILES_LIFTS_URL  = "./tiles/lifts.pmtiles";

  // Protomaps rendert Vector-Tiles als Canvas-Kacheln in Leaflet.
  // (Sehr performant, ideal als Overlay. Interaktion auf einzelne Pisten ist nur eingeschränkt.)
  class LineSymbolizer {
    constructor(styleFn) { this.styleFn = styleFn; }
    draw(ctx, geom, z, feature) {
      const s = this.styleFn(feature.props || {}, z);
      if (!s) return;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.globalAlpha = (s.opacity ?? 1);
      ctx.strokeStyle = s.color;
      ctx.lineWidth = s.width;
      if (s.dash) ctx.setLineDash(s.dash);
      else ctx.setLineDash([]);

      ctx.beginPath();
      // geom: Array<LineString>, each is Array<Point> with {x,y}
      for (const line of geom) {
        for (let i = 0; i < line.length; i++) {
          const p = line[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  // Wichtig: Diese Layernamen ("pistes" / "lifts") müssen beim Erzeugen der PMTiles so gesetzt werden.
  // Wenn du später andere Layernamen hast, einfach hier anpassen.
  const PISTES_RULES = [{
    dataLayer: "pistes",
    symbolizer: new LineSymbolizer((props, z) => {
      const d = (props["piste:difficulty"] || "").toLowerCase();
      const width = z < 10 ? 2.0 : z < 12 ? 3.0 : 4.4;

      if (d === "easy" || d === "novice" || d === "blue")  return { color: "#2b6cff", width, opacity: 0.95 };
      if (d === "intermediate" || d === "red")             return { color: "#e53935", width, opacity: 0.95 };
      if (d === "advanced" || d === "expert" || d === "black") return { color: "#111111", width, opacity: 0.95 };
      return { color: "#6f6f6f", width, opacity: 0.9 };
    })
  }];

  const LIFTS_RULES = [{
    dataLayer: "lifts",
    symbolizer: new LineSymbolizer((props, z) => {
      const width = z < 10 ? 1.2 : z < 12 ? 1.8 : 2.4;
      return { color: "#111111", width, opacity: 0.8, dash: [4, 3] };
    })
  }];

  // Overlay-Layer NICHT direkt hinzufügen (kommt per Layer-Control Checkbox)
  const pistesLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_PISTES_URL,
    paintRules: PISTES_RULES,
    labelRules: []
  }) : null;

  const liftsLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_LIFTS_URL,
    paintRules: LIFTS_RULES,
    labelRules: []
  }) : null;

// Ein Layer für alle Resort-Marker (Filter steuern Sichtbarkeit)
  const markerLayer = L.layerGroup().addTo(map);
  const COLOR_SCT   = "#9C2419";
  const COLOR_SSC   = "#004A8F";
  const COLOR_BOTH  = "#9C27B0";
  const COLOR_MUC   = "#2E7D32";
  const COLOR_OTHER = "#888888";

  // Counter aktualisieren
  function updateResortCounter() {
    const box = document.getElementById("resort-counter");
    if (!box) return;

    let visible = 0;
    Object.values(resortMarkers).forEach(marker => {
      if (map.hasLayer(marker)) {
        visible++;
      }
    });

    box.textContent = `${visible} / ${totalResorts}`;
  }
  function initResortsFromJson(list) {
    list.forEach(r => {
      const key = norm(r.name);

      // Resort-Objekt direkt übernehmen (mit passes-Array)
      resorts[key] = {
        name: r.name,
        lat: r.lat,
        lon: r.lon,
        country: r.country || null,
        region: r.region || null,
        passes: r.passes || [],
        glacier: !!r.glacier,
        nearMuc: !!r.nearMuc,
        website: (typeof r.website === "string" && r.website.trim()) ? r.website.trim() : null,
        groupId: (typeof r.groupId === "string" && r.groupId.trim()) ? r.groupId.trim() : null,
        groupName: (typeof r.groupName === "string" && r.groupName.trim()) ? r.groupName.trim() : null,
        entryType: (typeof r.entryType === "string" && r.entryType.trim()) ? r.entryType.trim() : null,
        entryName: (typeof r.entryName === "string" && r.entryName.trim()) ? r.entryName.trim() : null,
        liftsTotal: (r.liftsTotal != null) ? Number(r.liftsTotal) : null,
        pistesKm: (r.pistesKm != null) ? Number(r.pistesKm) : null,
        maxElevation: (r.maxElevation != null) ? Number(r.maxElevation) : null
      };
    });
  }

  function loadResortsAndInit() {
    fetch("data/resorts.json")
      .then(resp => {
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        return resp.json();
      })
      .then(list => {
        initResortsFromJson(list);

        totalResorts = Object.keys(resorts).length;

        buildMarkers();
        window.__resortsReady = true;
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.onResortsReady === "function") {
          try { window.HomeTravelTimes.onResortsReady(); } catch (e) { console.warn(e); }
        }
if (typeof rebuildDatalist === "function") {
          rebuildDatalist();
        }
        // Neue Filter-Slider initialisieren
        if (window.ui && typeof window.ui.computeFilterRanges === "function") {
          window.ui.computeFilterRanges();
          window.ui.updateFilterSliderLabels();
        }
        updateTimeLabel(100);
        applyTimeFilter(100);
                if (typeof loadTravelTimesJson === "function") {
          loadTravelTimesJson();
        }
      })
      .catch(err => {
        console.error("Fehler beim Laden von resorts.json:", err);
        alert("Fehler beim Laden der Skigebiete (Details in Konsole).");
      });
  }

  function buildMarkers() {
    Object.values(resorts).forEach(r => {
      const hasSct = hasPass(r, PASS_ID_SCT);
      const hasSsc = hasPass(r, PASS_ID_SSC);

      const passes = [];
      if (hasSct) passes.push("Snow Card Tirol");
      if (hasSsc) passes.push("SuperSkiCard");
      if (r.nearMuc && !hasSct && !hasSsc) passes.push("Extra: ab München");
      const passesStr = passes.length ? passes.join(", ") : "–";

      let color = COLOR_OTHER;
      if (hasSct && hasSsc)      color = COLOR_BOTH;
      else if (hasSct)           color = COLOR_SCT;
      else if (hasSsc)           color = COLOR_SSC;
      else if (r.nearMuc)        color = COLOR_MUC;

      const distKm   = haversineKm(MUC_LAT, MUC_LON, r.lat, r.lon);
      const estHours = distKm / AVG_SPEED_KMH;
      r.distKm = distKm;
      r.travelHours = estHours;
      if (estHours < minHours) minHours = estHours;
      if (estHours > maxHours) maxHours = estHours;

      const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;
      const driveTxt = `${Math.round(distKm)} km · ca. ${fmtTime(estHours)}`;

      let marker;

      if (r.glacier) {
        const glacierIcon = L.divIcon({
          html: `
            <div style="
              width: 26px;
              height: 26px;
              border-radius: 50%;
              border: 2px solid ${color};
              background: white;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 16px;
            ">
              ❄
            </div>
          `,
          className: "",
          iconSize: [26, 26],
          iconAnchor: [13, 13],
          popupAnchor: [0, -13]
        });

        marker = L.marker([r.lat, r.lon], { icon: glacierIcon });
      } else {
        marker = L.circleMarker([r.lat, r.lon], {
          radius: 8,
          color: color,
          fillColor: color,
          fillOpacity: 0.95,
          weight: 2
        });
      }

      marker
        .bindPopup(() => makePopupHtml(r))
        .bindTooltip(`${r.name} (${passesStr})`);
      markerLayer.addLayer(marker);
      resortMarkers[norm(r.name)] = marker;
    });

    // einmal initial nach Markerbau updaten
    updateResortCounter();
  }
  const timeSlider = document.getElementById("time-slider");
  

  const baseLayers = {
    "OSM": osm,
    "Topo (Relief)": topo
  };

  const overlays = {};
  if (pistesLayer) overlays["Pists"] = pistesLayer;
  if (liftsLayer)  overlays["Lifts"]  = liftsLayer;

  window.layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// --------- Live OSM Overpass Overlay (Alpe d'Huez) ---------
// Quick, no-tiles approach: fetch OSM data from Overpass and render as GeoJSON.
// BBox source: map.getBounds().toBBoxString() returned west,south,east,north.
const ALPE_LIVE_BOUNDS = {
  west: 5.814495389733874,
  south: 45.03078564735712,
  east: 6.400547330651842,
  north: 45.180779880904076
};
// Overpass expects: (south,west,north,east)
const ALPE_OVERPASS_BBOX = `${ALPE_LIVE_BOUNDS.south},${ALPE_LIVE_BOUNDS.west},${ALPE_LIVE_BOUNDS.north},${ALPE_LIVE_BOUNDS.east}`;

const OVERPASS_ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.kumi.systems/api/interpreter",
  "https://overpass.nchc.org.tw/api/interpreter"
];

const alpeLiveLiftsLayer = L.layerGroup();
const alpeLivePistesLayer = L.layerGroup();
let alpeLiveLoaded = false;
let alpeLiveLoading = false;

async function fetchOverpassJSON(query) {
  // Overpass does NOT require an API key.
  // In practice, browser POST requests are sometimes blocked (CORS / overloaded servers),
  // so we try GET first (most reliable from GitHub Pages), then POST as a fallback.
  const encoded = encodeURIComponent(query);

  let lastErr = null;
  for (const baseUrl of OVERPASS_ENDPOINTS) {
    // --- Try GET ---
    try {
      const getUrl = `${baseUrl}?data=${encoded}`;
      const res = await fetch(getUrl, { method: "GET", mode: "cors", cache: "no-store" });
      if (!res.ok) throw new Error(`Overpass GET HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      lastErr = e;
    }

    // --- Try POST (fallback) ---
    try {
      const res = await fetch(baseUrl, {
        method: "POST",
        mode: "cors",
        cache: "no-store",
        headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
        body: "data=" + encoded
      });
      if (!res.ok) throw new Error(`Overpass POST HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error("Overpass request failed");
}

function setAlpeLiveStatus(msg) {
  const el = document.getElementById("alpe-live-status");
  if (el) el.textContent = msg || "";
}

function getTags(feature) {
  const p = feature && feature.properties ? feature.properties : {};
  return (p.tags && typeof p.tags === "object") ? p.tags : p;
}

function pisteStyle(tags, z) {
  const d = String(tags["piste:difficulty"] || "").toLowerCase();
  // Keep it close to your PMTiles styling
  if (d === "easy" || d === "novice" || d === "blue")  return { color: "#2b6cff", weight: 3, opacity: 0.95 };
  if (d === "intermediate" || d === "red")             return { color: "#e53935", weight: 3, opacity: 0.95 };
  if (d === "advanced" || d === "expert" || d === "black") return { color: "#111111", weight: 3, opacity: 0.95 };
  return { color: "#6f6f6f", weight: 2.5, opacity: 0.9 };
}

function overpassWaysToFeatureCollections(osmJson) {
  const lifts = [];
  const pistes = [];

  const els = (osmJson && osmJson.elements) ? osmJson.elements : [];
  for (const el of els) {
    if (!el || el.type !== "way") continue;
    const tags = el.tags || {};
    const geom = el.geometry;
    if (!Array.isArray(geom) || geom.length < 2) continue;

    const coords = geom.map(p => [p.lon, p.lat]).filter(c => Number.isFinite(c[0]) && Number.isFinite(c[1]));
    if (coords.length < 2) continue;

    const feat = {
      type: "Feature",
      geometry: { type: "LineString", coordinates: coords },
      properties: { ...tags, osm_id: el.id, osm_type: "way" }
    };

    if (tags.aerialway) lifts.push(feat);
    if (tags["piste:type"]) pistes.push(feat);
  }

  return {
    lifts: { type: "FeatureCollection", features: lifts },
    pistes: { type: "FeatureCollection", features: pistes },
  };
}

async function loadAlpeLiveOSM(force=false) {
  if (alpeLiveLoading) return;
  if (alpeLiveLoaded && !force) return;
  alpeLiveLoading = true;
  setAlpeLiveStatus("Lade Alpe d'Huez (Overpass)…");

  try {
    // We request geometries directly from Overpass (`out geom`) so we don't need osmtogeojson.
    // Overpass bbox format: south,west,north,east
    const query = `
      [out:json][timeout:60];
      (
        way["aerialway"](${ALPE_OVERPASS_BBOX});
        way["piste:type"](${ALPE_OVERPASS_BBOX});
      );
      out tags geom;
    `;

    const osmJson = await fetchOverpassJSON(query);
    const { lifts, pistes } = overpassWaysToFeatureCollections(osmJson);

    // Replace data in layer groups
    alpeLiveLiftsLayer.clearLayers();
    alpeLivePistesLayer.clearLayers();

    const liftsCount = lifts.features.length;
    const pistesCount = pistes.features.length;

    const liftsGeo = L.geoJSON(lifts, {
      style: () => ({ color: "#111111", weight: 2.2, opacity: 0.85, dashArray: "5,4" }),
      onEachFeature: (f, layer) => {
        const t = getTags(f);
        const nm = t.name || t.ref || t.aerialway;
        if (nm) layer.bindTooltip(String(nm), { sticky: true });
      }
    });
    liftsGeo.addTo(alpeLiveLiftsLayer);

    const pistesGeo = L.geoJSON(pistes, {
      style: (f) => pisteStyle(getTags(f)),
      onEachFeature: (f, layer) => {
        const t = getTags(f);
        const nm = t.name || t.ref || t["piste:name"] || t["piste:type"];
        if (nm) layer.bindTooltip(String(nm), { sticky: true });
      }
    });
    pistesGeo.addTo(alpeLivePistesLayer);

    alpeLiveLoaded = true;

    if (liftsCount === 0 && pistesCount === 0) {
      setAlpeLiveStatus("Keine Live-Daten gefunden (OSM).");
    } else {
      setAlpeLiveStatus(`Geladen: ${pistesCount} Pisten / ${liftsCount} Lifte`);
    }
  } catch (e) {
    console.error("Alpe live Overpass error:", e);
    setAlpeLiveStatus("Fehler beim Laden (Overpass).");
  } finally {
    alpeLiveLoading = false;
  }
}


function clearAlpeLiveOSM() {
  try {
    alpeLiveLiftsLayer.clearLayers();
    alpeLivePistesLayer.clearLayers();
  } catch (_) {}
  alpeLiveLoaded = false;
}

async function reloadAlpeLiveOSM() {
  clearAlpeLiveOSM();
  // Only reload if at least one of the live layers is currently enabled
  const enabled = map.hasLayer(alpeLiveLiftsLayer) || map.hasLayer(alpeLivePistesLayer);
  if (enabled) {
    await loadAlpeLiveOSM(true);
  } else {
    setAlpeLiveStatus("Reload bereit – Overlay aktivieren, um zu laden.");
  }
}

// Add overlays to your existing layers control
if (window.layerControl && typeof window.layerControl.addOverlay === "function") {
  window.layerControl.addOverlay(alpeLivePistesLayer, "Alpe d'Huez – Pisten (Live)");
  window.layerControl.addOverlay(alpeLiveLiftsLayer,  "Alpe d'Huez – Lifte (Live)");
}


// If the user has the live overlays enabled by default (or via persisted state), load immediately
if (map.hasLayer(alpeLivePistesLayer) || map.hasLayer(alpeLiveLiftsLayer)) {
  loadAlpeLiveOSM();
}

// Lazy-load on first enable (so you don't hit Overpass until needed)
map.on("overlayadd", (e) => {
  if (e.layer === alpeLivePistesLayer || e.layer === alpeLiveLiftsLayer) {
    loadAlpeLiveOSM();
  }
});




map.on("overlayremove", (e) => {
  if (e.layer === alpeLivePistesLayer || e.layer === alpeLiveLiftsLayer) {
    setAlpeLiveStatus("");
  }
});
// --- Panel: Layer-Control optisch/inhaltlich gliedern (Karte vs Overlays) ---
(function decorateLayerControl(){
  try{
    const lc = window.layerControl;
    const c = lc && lc.getContainer ? lc.getContainer() : document.querySelector('.leaflet-control-layers');
    if (!c) return;

    // Gruppenüberschriften
    const base = c.querySelector('.leaflet-control-layers-base');
    const ov   = c.querySelector('.leaflet-control-layers-overlays');
    if (base && !(base.previousElementSibling && base.previousElementSibling.classList.contains('panel-group-title'))){
      base.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Karte</div>');
    }
    if (ov && !(ov.previousElementSibling && ov.previousElementSibling.classList.contains('panel-group-title'))){
      ov.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Overlays</div>');
    }

    // Reload-Button + Status für Live-Overpass (damit man bei Overpass-Problemen neu versuchen kann)
    if (!c.querySelector('#alpe-live-reload')) {
      const wrap = document.createElement('div');
      wrap.style.marginTop = '8px';
      wrap.innerHTML = `
        <button id="alpe-live-reload" type="button" style="width:100%;height:32px;border-radius:10px;border:1px solid rgba(0,0,0,0.35);background:#f3f3f3;cursor:pointer;font-size:12px;font-weight:600;">
          Reload Alpe d'Huez (Live)
        </button>
        <div id="alpe-live-status" style="margin-top:6px;font-size:11px;color:rgba(0,0,0,0.68);"></div>
      `;
      c.appendChild(wrap);

      const btn = wrap.querySelector('#alpe-live-reload');
      btn.addEventListener('click', () => { reloadAlpeLiveOSM(); });
      setAlpeLiveStatus('');
    }
  } catch(e){
    console.warn('decorateLayerControl failed', e);
  }
})();
// --------- Suche & Filter initialisieren (ausgelagert in searchFilter.js) ---------

  // --- Zoom-Reset: mobile anders als Desktop (wird von searchFilter.js über resetMapView() genutzt) ---
  // Passe RESET_ZOOM_MOBILE in den DevTools an, bis es sich für dich richtig anfühlt.
  const RESET_CENTER = [47.2, 12.2];
  const RESET_ZOOM_DESKTOP = 9;
  const RESET_ZOOM_MOBILE  = 8; // <— hier testen/ändern

  const isMobileViewport = () => window.matchMedia("(max-width: 720px)").matches;

  function resetView(map) {
    // Optional: Popups schließen, damit Reset "clean" wirkt
    try { map.closePopup(); } catch (_) {}

    const opts = { animate: true, duration: 0.8 };

    if (isMobileViewport()) {
      map.flyTo(RESET_CENTER, RESET_ZOOM_MOBILE, opts);

      // Optional: leicht nach unten schieben, falls die Top-Bar zu viel überdeckt (Wert anpassen/auskommentieren)
      // try { map.panBy([0, 80], { animate: true, duration: 0.35 }); } catch (_) {}
    } else {
      map.flyTo(RESET_CENTER, RESET_ZOOM_DESKTOP, opts);
    }
  }

  const ui = window.initSearchAndFilters({
    map,
    resorts,
    resortMarkers,
    markerLayer,
    fmtTime,
    norm,
    getMinHours: () => minHours,
    getMaxHours: () => maxHours,
    updateResortCounter,
    createFilterControl: true,
    createExportControl: true
  ,
    resetView});
  window.ui = ui;

  // --------- GPS: aktuelle Position anzeigen (mobil) ---------
  if (window.GpsControl && typeof window.GpsControl.init === "function") {
    try { window.GpsControl.init(map); } catch (e) { console.warn("GpsControl init failed", e); }
  }

// Alte Funktionsnamen weiterhin verfügbar halten (damit bestehender Code unverändert bleibt)
  window.rebuildDatalist   = ui.rebuildDatalist;
  window.updateTimeLabel   = ui.updateTimeLabel;
  window.applyTimeFilter   = ui.applyTimeFilter;
  window.focusResortByName = ui.focusResortByName;
  // Suche & Filter wurden in searchFilter.js ausgelagert.


  // --------- Tree Routes Overlay (Reachability "Chaos"-Layer) ---------
  // Erwartete Dateien: data/routes/home_<homeId>.geojson (z.B. home_muc.geojson)
  // Home-Auswahl erfolgt über das Dropdown (HomeRoutesSelector) und lädt die passende Datei.
  let tree = null;
  let currentTreeHomeId = "muc"; // Fallback; wird bei Init vom Selector überschrieben

  function pctToLimitHours(pct) {
    const p = Math.max(0, Math.min(100, Number(pct))) / 100;
    // minHours/maxHours werden aus travel_times.json (oder OSRM/ORS) gesetzt
    if (!isFinite(minHours) || !isFinite(maxHours) || minHours === Infinity) return Infinity;
    return minHours + p * (maxHours - minHours);
  }

  function syncTreeWithUi(uiObj, pct) {
    if (!tree || !uiObj) return;

    // 1) Zeitlimit aus Slider-Prozent
    const limitHours = (pct >= 99) ? Infinity : pctToLimitHours(pct);
    tree.setMaxHours(limitHours);

    // 2) Weitere Filter: Wir übernehmen einfach die aktuell sichtbaren Resorts aus der UI
    //    und zeigen nur deren Routen an.
    const visible = uiObj.getVisibleResorts ? uiObj.getVisibleResorts() : [];
    const visibleSet = new Set(visible.map(r => norm(r.name)));

    tree.setPredicate((props) => {
      const nm = props && (props.name || props.resort_name || props.resort) ? String(props.name || props.resort_name || props.resort) : "";
      return visibleSet.has(norm(nm));
    });
  }

  // Tree Overlay (re-)initialisieren und (optional) in Layer-Control aufnehmen
  async function ensureTreeOverlayForHome(homeId) {
    if (!window.TreeRoutesOverlay) return null;
    const url = `data/routes/home_${homeId}.geojson`;

    // Enabled-Status merken
    const hadTree = !!(tree && tree.getLayer && tree.getLayer());
    const wasEnabled = hadTree ? map.hasLayer(tree.getLayer()) : true; // default: an

    // Alte Instanz entfernen (Layer + Eintrag im LayerControl)
    if (tree && tree.getLayer && tree.getLayer()) {
      const oldLayer = tree.getLayer();
      try { if (map.hasLayer(oldLayer)) map.removeLayer(oldLayer); } catch (_) {}
      try { if (window.layerControl && typeof window.layerControl.removeLayer === "function") window.layerControl.removeLayer(oldLayer); } catch (_) {}
    }

    // Neu initialisieren (preserve enabled state)
    const next = await window.TreeRoutesOverlay.init(map, {
      url,
      enabled: wasEnabled,   // bleibt an/aus wie vorher
      baseOpacity: 0.18
    });

    tree = next;
    currentTreeHomeId = homeId;
    window.treeOverlay = tree;

    // Eintrag (Checkbox) in Layer-Control hinzufügen (Leaflet setzt checked abhängig von map.hasLayer)
    if (window.layerControl && tree.getLayer && tree.getLayer()) {
      window.layerControl.addOverlay(tree.getLayer(), "Tree Routes");
      // Default/Restore: wenn enabled, Layer auch wirklich auf die Karte legen (damit Checkbox checked ist)
      if (wasEnabled && tree.getLayer && tree.getLayer() && !map.hasLayer(tree.getLayer())) {
        map.addLayer(tree.getLayer());
      }
    }

    // applyFilters hooken: immer wenn Marker-Filter aktualisiert werden, Tree synchronisieren
    if (ui && typeof ui.applyFilters === "function") {
      const _apply = ui.applyFilters;
      if (!_apply.__treeHooked) {
        ui.applyFilters = function (pct) {
          _apply(pct);
          syncTreeWithUi(ui, pct);
        };
        ui.applyFilters.__treeHooked = true;

        // alte Alias-Funktion ebenfalls aktualisieren
        window.applyTimeFilter = ui.applyFilters;
        window.applyFilters = ui.applyFilters;
      }
    }

    // initial sync
    const initialPct = Number(timeSlider?.value ?? 100);
    syncTreeWithUi(ui, initialPct);

    return tree;
  }

  // Expose for home selector
  window.ensureTreeOverlayForHome = ensureTreeOverlayForHome;

  // Initial: versuche mit muc zu laden (wenn Datei fehlt, bleibt es still)
  (async () => {
    try {
      await ensureTreeOverlayForHome(currentTreeHomeId);
    } catch (err) {
      console.warn("TreeRoutesOverlay init skipped/failed:", err);
    }
  })();

  function applyTravelTimesFromMap(ttMap) {
    const resortList = Object.values(resorts);
    minHours = Infinity;
    maxHours = 0;

    resortList.forEach(r => {
      const tt = ttMap[r.name];
      if (tt && typeof tt.hours === "number" && typeof tt.km === "number") {
        r.travelHours = tt.hours;
        r.distKm = tt.km;
        if (tt.hours < minHours) minHours = tt.hours;
        if (tt.hours > maxHours) maxHours = tt.hours;
      }
    });

    if (typeof rebuildDatalist === "function") {
      rebuildDatalist();
    }
    if (typeof timeSlider !== "undefined" && timeSlider) {
      timeSlider.value = 100;
    }
    updateTimeLabel(100);
    applyTimeFilter(100);    
  }

  async function recalcTravelTimesFromOrigin() {
    const input = document.getElementById("home-input");
    const value = input.value.trim();

    let originLat;
    let originLon;

    if (!value) {
      originLat = MUC_LAT;
      originLon = MUC_LON;
    } else if (value.includes(",")) {
      const parts = value.split(",");
      originLat = parseFloat(parts[0]);
      originLon = parseFloat(parts[1]);
      if (!isFinite(originLat) || !isFinite(originLon)) {
        alert("Konnte Eingabe nicht als 'lat,lon' interpretieren.");
        return;
      }
    } else {
      if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
        alert("Bitte ORS_API_KEY in config.js eintragen.");
        return;
      }
      try {
        const url = "https://api.openrouteservice.org/geocode/search?api_key=" +
                    encodeURIComponent(ORS_API_KEY) +
                    "&text=" + encodeURIComponent(value) +
                    "&size=1";
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("Geocoding-Request fehlgeschlagen");
        }
        const data = await resp.json();
        const feats = data.features || [];
        if (!feats.length) {
          alert("Adresse konnte nicht gefunden werden.");
          return;
        }
        const coords = feats[0].geometry.coordinates;
        originLon = coords[0];
        originLat = coords[1];
      } catch (err) {
        console.error("Fehler beim Geocoding:", err);
        alert("Fehler beim Geocoding (Details in Konsole).");
        return;
      }
    }

    if (typeof map !== "undefined") {
      if (originMarker) {
        map.removeLayer(originMarker);
      }
      const originIcon = L.divIcon({
        html: `
          <div style="
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
          ">
            🏠
          </div>
        `,
        className: "",
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
      originMarker = L.marker([originLat, originLon], { icon: originIcon })
        .addTo(map)
        .bindTooltip("Startpunkt", { permanent: false });
    }

    const key = originLat.toFixed(3) + "," + originLon.toFixed(3);

    if (travelTimeCache[key]) {
      applyTravelTimesFromMap(travelTimeCache[key]);
      return;
    }

    const resortList = Object.values(resorts);
    const locations = [[originLon, originLat]].concat(
      resortList.map(r => [r.lon, r.lat])
    );
    const body = {
      locations: locations,
      metrics: ["distance", "duration"],
      units: "km",
      sources: [0],
      destinations: resortList.map((_, idx) => idx + 1)
    };

    if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
      alert("Bitte ORS_API_KEY in config.js eintragen.");
      return;
    }

    try {
      const resp = await fetch("https://api.openrouteservice.org/v2/matrix/driving-car", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": ORS_API_KEY
        },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        throw new Error("Matrix-Request fehlgeschlagen: " + resp.status);
      }
      const data = await resp.json();
      const durations = (data.durations && data.durations[0]) || [];
      const distances = (data.distances && data.distances[0]) || [];

      const ttMap = {};
      resortList.forEach((r, idx) => {
        const durSec = durations[idx];
        const distKm = distances[idx];
        if (typeof durSec === "number" && typeof distKm === "number") {
          const hours = durSec / 3600.0;
          ttMap[r.name] = { hours: hours, km: distKm };
        }
      });

      travelTimeCache[key] = ttMap;
      applyTravelTimesFromMap(ttMap);
    } catch (err) {
      console.error("Fehler beim Abrufen der Matrix:", err);
      alert("Fehler beim Abrufen der Fahrzeiten (Details in Konsole).");
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btn-calc-times");
    if (btn) {
      btn.addEventListener("click", () => {
        recalcTravelTimesFromOrigin();
      });
    }
  });

  function loadTravelTimesJson(homeId) {
    // Kompatibilität: lädt vorkomputierte Fahrzeiten pro Home-Profil
    // Erwartet Datei: data/travel_times/home_<homeId>.json
    const stored = (window.HomeTravelTimes && typeof window.HomeTravelTimes.getSelectedHomeId === "function")
      ? window.HomeTravelTimes.getSelectedHomeId()
      : null;

    const hid = homeId || stored || (localStorage.getItem("skimap.selectedHomeId")) || "muc";
    if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
      return window.HomeTravelTimes.load(hid);
    }

    // Fallback (sollte praktisch nie passieren):
    fetch(`data/travel_times/home_${hid}.json`)
      .then(resp => resp.json())
      .then(data => applyTravelTimesFromMap(data))
      .catch(err => {
        console.error("Fehler beim Laden von travel_times (per home), nutze Luftlinie:", err);
        updateTimeLabel(100);
        applyTimeFilter(100);
      });
  }

  
  // --------- Home Dropdown (Tree Routes + Fahrzeiten auswählen) ---------
  document.addEventListener("DOMContentLoaded", () => {
    if (!window.HomeRoutesSelector) return;

    window.HomeRoutesSelector.init({
      homesUrl: "data/homes.json",
      routesDir: "data/routes",
      routeFile: (homeId) => `data/routes/home_${homeId}.geojson`,
      defaultHomeId: "muc",
      selectId: "homeSelectSlider",
      boxId: "homeSelectorBox",
      desktopHostSelector: ".leaflet-top.leaflet-right",
      mobileHostId: "panel-filters",
      storageKey: "skimap.selectedHomeId",
      onHomeChanged: async (homeId, homeMeta) => {
        // Slider-Label updaten
        const lbl = document.querySelector('.slider-box label[for="time-slider"]');
        if (lbl) lbl.textContent = `Max. Fahrzeit ab ${homeMeta?.name || homeId}`;

        // Fahrzeiten pro Home laden
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.setSelectedHomeId === "function") {
          window.HomeTravelTimes.setSelectedHomeId(homeId);
        }
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
          try { await window.HomeTravelTimes.load(homeId); }
          catch (e) { console.warn("HomeTravelTimes load failed:", e); }
        }

        // Tree-Routes neu laden (ohne Checkbox-Status zu verändern)
        if (typeof window.ensureTreeOverlayForHome === "function") {
          try { await window.ensureTreeOverlayForHome(homeId); }
          catch (e) { console.warn("ensureTreeOverlayForHome failed:", e); }
        }
      }
    });
  });

document.addEventListener("DOMContentLoaded", () => {
    loadResortsAndInit();
  });

  // Slider-Box Toggle für Mobile
  (function() {
    const sliderBox = document.getElementById('slider-box');
    const toggleBtn = document.getElementById('slider-box-toggle');
    if (!sliderBox || !toggleBtn) return;

    toggleBtn.addEventListener('click', () => {
      const isCollapsed = sliderBox.classList.toggle('collapsed');
      toggleBtn.setAttribute('aria-expanded', !isCollapsed);
    });
  })();

</script>

<div id="mobile-panel-backdrop" aria-hidden="true"></div>
<aside id="mobile-panel" aria-label="Filter und Layer">
    <details class="panel-accordion" open>
    <summary>Layer</summary>
    <div id="panel-layers" class="panel-section"></div>
  </details>

  <details class="panel-accordion" open>
    <summary>Filter</summary>
    <div id="panel-filters" class="panel-section"></div>
  </details>

  <details class="panel-accordion" open>
    <summary>Export</summary>
    <div id="panel-export" class="panel-section"></div>
  </details>
</aside>


<script>
  (function initMobilePanel(){
    const btn = document.getElementById('mobile-panel-toggle');
    const backdrop = document.getElementById('mobile-panel-backdrop');
    const panel = document.getElementById('mobile-panel');
    const panelLayers = document.getElementById('panel-layers');
    const panelFilters = document.getElementById('panel-filters');
    const panelExport = document.getElementById('panel-export');
    if (!btn || !backdrop || !panel || !panelLayers || !panelFilters || !panelExport) return;

    const mq = window.matchMedia('(max-width: 720px)');
    const isMobile = () => mq && mq.matches;

    const openPanel = () => {
      document.body.classList.add('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'true');
      backdrop.setAttribute('aria-hidden','false');
    };
    const closePanel = () => {
      document.body.classList.remove('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'false');
      backdrop.setAttribute('aria-hidden','true');
    };

    btn.addEventListener('click', () => {
      document.body.classList.contains('mobile-panel-open') ? closePanel() : openPanel();
    });
    backdrop.addEventListener('click', closePanel);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePanel(); });

    function ensureDesktopStack(){
      const corner = document.querySelector('.leaflet-top.leaflet-right');
      if (!corner) return null;
      let stack = document.getElementById('desktop-control-stack');
      if (!stack) {
        stack = document.createElement('div');
        stack.id = 'desktop-control-stack';
        stack.className = 'desktop-control-stack';
        corner.prepend(stack);
      }
      return stack;
    }

    function placeControls(){
      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');

      if (isMobile()) {
        if (layers && layers.parentNode !== panelLayers) panelLayers.appendChild(layers);
        if (filters && filters.parentNode !== panelFilters) panelFilters.appendChild(filters);
        if (exportBox && exportBox.parentNode !== panelExport) panelExport.appendChild(exportBox);
      } else {
        const stack = ensureDesktopStack();
        if (!stack) return;
        if (layers && layers.parentNode !== stack) stack.appendChild(layers);
        if (filters && filters.parentNode !== stack) stack.appendChild(filters);
        if (exportBox && exportBox.parentNode !== stack) stack.appendChild(exportBox);
        closePanel(); // ensure panel isn't stuck open when resizing to desktop
      }
    }

    // Controls are created after map init -> retry a few times
    let tries = 0;
    const timer = setInterval(() => {
      placeControls();
      tries += 1;

      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');
      if ((layers && filters && exportBox) || tries > 50) clearInterval(timer);
    }, 200);

    window.addEventListener('resize', () => placeControls());
    if (mq && mq.addEventListener) mq.addEventListener('change', () => placeControls());
  })();
</script>

</body>
</html>
