<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Ski-Pässe: Snow Card Tirol & SuperSkiCard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon-32.png" sizes="32x32">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">


  <style>
    
/* --- Unified Control Cards (Layer / Filter / Export) --- */
:root{
  --panel-bg: #ffffff;
  --panel-border: rgba(0,0,0,0.18);
  --panel-radius: 14px;
  --panel-shadow: 0 8px 22px rgba(0,0,0,0.16);
  --panel-pad: 10px 12px;
  --panel-title-size: 13px;
  --panel-title-weight: 700;
  --panel-muted: rgba(0,0,0,0.62);
  --control-gap: 10px;
}

.panel-card{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  box-sizing: border-box;
}

.panel-title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

.panel-group-title{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .02em;
  text-transform: uppercase;
  color: var(--panel-muted);
  margin: 10px 0 6px 0;
}

.panel-card label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
  user-select:none;
}
.panel-card input[type="checkbox"],
.panel-card input[type="radio"]{
  margin:0;
}

/* Desktop: rechte Control-Spalte sauber stapeln */
.leaflet-top.leaflet-right{
  display:flex;
  flex-direction:column;
  gap: var(--control-gap);
}
.leaflet-top.leaflet-right .leaflet-control{
  margin: 0 !important; /* gap regelt Abstand */
}

/* Stack-Reihenfolge + Scroll, damit auf Desktop keine Controls "verschwinden" */
.leaflet-top.leaflet-right{
  max-height: calc(100% - 12px);
  overflow-y: auto;
  padding-right: 2px;
}
.leaflet-top.leaflet-right .leaflet-control-layers{ order: 1; }
.leaflet-top.leaflet-right .filter-box.leaflet-control{ order: 2; }
.leaflet-top.leaflet-right .export-box.leaflet-control{ order: 3; }

/* Filter-Labels sauber untereinander */
.filter-box label{
  display:flex;
  align-items:center;
  gap:8px;
  width:100%;
  margin: 6px 0;
}
.filter-box input[type="checkbox"]{ margin:0; }

/* Export-Hinweis komplett ausblenden (falls vorhanden) */
.export-box .hint{ display:none; }

/* Export-Buttons etwas kompakter */
.export-box .panel-content button{
  height: 32px;
  font-size: 12px;
  border-radius: 10px;
  margin-top: 6px;
}

/* --- Filter-Box --- */
.filter-box.leaflet-control,
.export-box.leaflet-control,
.leaflet-control-layers{
  width: 210px;
}
.filter-box.leaflet-control,
.export-box.leaflet-control{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  font-size: 13px;
  line-height: 1.35;
  box-sizing:border-box;
  width: 210px;
}
/* Panel Toggle Button (für einklappbare Boxen) */
.filter-box .panel-toggle,
.export-box .panel-toggle,
.gps-box .panel-toggle,
.leaflet-control-layers .panel-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  margin: 0 0 8px 0;
  font-family: inherit;
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  color: rgba(0,0,0,0.86);
  text-align: left;
}
.filter-box .panel-toggle:hover,
.export-box .panel-toggle:hover,
.gps-box .panel-toggle:hover,
.leaflet-control-layers .panel-toggle:hover {
  color: rgba(0,0,0,1);
}
.filter-box .toggle-title,
.export-box .toggle-title,
.gps-box .toggle-title,
.leaflet-control-layers .toggle-title {
  flex: 1;
}
.filter-box .toggle-icon,
.export-box .toggle-icon,
.gps-box .toggle-icon,
.leaflet-control-layers .toggle-icon {
  font-size: 10px;
  color: #666;
  transition: transform 0.2s ease;
}
.filter-box.collapsed .toggle-icon,
.export-box.collapsed .toggle-icon,
.gps-box.collapsed .toggle-icon,
.leaflet-control-layers.collapsed .toggle-icon {
  transform: rotate(-90deg);
}
.filter-box.collapsed .panel-content,
.export-box.collapsed .panel-content,
.gps-box.collapsed .panel-content,
.leaflet-control-layers.collapsed .panel-content {
  display: none;
}
.filter-box.collapsed,
.export-box.collapsed,
.gps-box.collapsed,
.leaflet-control-layers.collapsed {
  padding: 8px 10px;
}
.filter-box.collapsed .panel-toggle,
.export-box.collapsed .panel-toggle,
.gps-box.collapsed .panel-toggle,
.leaflet-control-layers.collapsed .panel-toggle {
  margin-bottom: 0;
}

/* Legacy: .title class (falls noch verwendet) */
.filter-box .title,
.export-box .title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

/* Filter-Gruppenüberschriften */
.filter-box .filter-group-title{
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.03em;
  color: rgba(0,0,0,0.5);
  margin: 12px 0 6px 0;
  padding-top: 8px;
  border-top: 1px solid rgba(0,0,0,0.1);
}
.filter-box .filter-group-title:first-of-type{
  margin-top: 4px;
  padding-top: 0;
  border-top: none;
}

/* Leaflet Layers Control wie Panel-Card */
.leaflet-control-layers{
  width: 210px;
  background: var(--panel-bg) !important;
  padding: var(--panel-pad) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--panel-radius) !important;
  box-shadow: var(--panel-shadow) !important;
}
.leaflet-control-layers .leaflet-control-layers-separator{
  border-top: 1px solid rgba(0,0,0,0.12);
  margin: 8px 0;
}
.leaflet-control-layers label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.leaflet-control-layers input{
  margin: 0;
}

/* Leaflet Layers Control: Override für !important padding */
.leaflet-control-layers.collapsed {
  padding: 8px 10px !important;
}

/* GPS-Box Basis-Styling */
.gps-box.leaflet-control {
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  font-size: 13px;
  line-height: 1.35;
  box-sizing: border-box;
  width: 210px;
}
.gps-box .gps-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
.gps-box .gps-row label {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}
.gps-box .gps-center-btn {
  padding: 4px 8px;
  font-size: 12px;
  border: 1px solid rgba(0,0,0,0.35);
  border-radius: 6px;
  background: #f3f3f3;
  cursor: pointer;
  white-space: nowrap;
}
.gps-box .gps-center-btn:hover {
  background: #e9e9e9;
}

/* Export Buttons etwas "ruhiger" */
.export-box button:not(.panel-toggle){
  width:100%;
  height: 36px;
  padding: 0 10px;
  margin: 6px 0 0 0;
  font-size: 13px;
  font-weight: 600;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,0.35);
  background:#f3f3f3;
  cursor:pointer;
}
.export-box button:not(.panel-toggle):hover{ background:#e9e9e9; }
.export-box .hint{
  margin-top:8px;
  font-size:11px;
  color: rgba(0,0,0,0.68);
}
html, body {
      height: 100%;
      margin: 0;
    }
    :root { --app-h: 100dvh; }
    @supports not (height: 100dvh) { :root { --app-h: 100vh; } }
    #map {
      height: var(--app-h);
      width: 100vw;
    }

    .legend-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
      background: white;
      padding: 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
    }
.search-box {
  position: fixed !important;
  top: 10px;
  left: 50px;
  z-index: 10000;
  background: white;
  padding: 10px 10px 12px 10px;
  width: 550px;
  max-width: calc(100vw - 40px);
  box-sizing: border-box;
  border: 1px solid #888;
  font-size: 13px;
  line-height: 1.35;
  box-shadow: 0 8px 22px rgba(0,0,0,0.16);
  border-radius: 12px;
}
.search-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
.search-box input {
  width: 100%;
  height: 36px;
  padding: 8px 10px;
  font-size: 14px;
  border: 1px solid #bbb;
  border-radius: 10px;
  box-sizing: border-box;
  outline: none;
}
.search-box input:focus {
  border-color: #777;
}
.search-row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: nowrap;
}
.search-row input {
      flex: 1 1 auto;
      min-width: 200px;
    }
#search-btn {
  flex: 0 0 auto;
  height: 36px;
  padding: 0 12px;
  font-size: 13px;
  font-weight: 600;
  border: 1px solid #666;
  border-radius: 10px;
  background: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
}
#search-btn:hover{ background:#e0e0e0; }
#clear-verbund-btn {
  flex: 0 0 auto;
}
#clear-verbund-btn:disabled {
  opacity: 0.55;
  cursor: default;
}
#clear-verbund-btn:disabled {
      opacity: 0.55;
      cursor: default;
    }
.slider-box {
      position: fixed;
      bottom: 110px;        /* sitzt über der Legende */
      left: 20px;
      z-index: 10000;
      background: rgba(255,255,255,0.96);
      padding: 10px 14px;
      border: none;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      border-radius: 8px;
      max-width: 260px;
      width: calc(100vw - 40px); /* mobil: passt sich an */
      box-sizing: border-box;
    }

    .slider-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .slider-box input[type="range"] {
      width: 100%;
    }

    /* Fahrzeit-Slider mit Farbverlauf (passend zur Corridor-Skala) */
    #time-slider {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      outline: none;
      /* Gradient: grün (0-1h) → hellgrün (1-2h) → gelb (2-3h) → orange (3-4h) → rot (4h+) */
      /* Bei 6h max: 1h=17%, 2h=33%, 3h=50%, 4h=67% */
      background: linear-gradient(to right,
        #1a9850 0%,      /* grün - Start */
        #1a9850 15%,     /* grün - bis ~1h */
        #91cf60 25%,     /* hellgrün - ~1.5h */
        #fee08b 40%,     /* gelb - ~2.5h */
        #fc8d59 55%,     /* orange - ~3.5h */
        #d73027 75%,     /* rot - ~4.5h */
        #d73027 100%     /* rot - Ende */
      );
    }

    /* Slider-Thumb (der Anfasser) */
    #time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    #time-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    /* Firefox Track-Styling */
    #time-slider::-moz-range-track {
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(to right,
        #1a9850 0%, #1a9850 15%, #91cf60 25%,
        #fee08b 40%, #fc8d59 55%, #d73027 75%, #d73027 100%
      );
    }
    .slider-box .time-label {
      margin-top: 4px;
      font-size: 12px;
      color: #444;
    }

    /* Box für Startadresse & Button */
    .home-box {
      position: fixed;
      bottom: 120px;           
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px);
      box-sizing: border-box;
    }

    /* Desktop: Home-Box ausblenden (Dropdown sitzt oben im Slider) */
    @media (min-width: 721px){
      .home-box{ display:none !important; }
    }

    .home-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
    .home-box input {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border: 1px solid #bbb;
      border-radius: 3px;
      box-sizing: border-box;
      margin-bottom: 6px;
    }
    .home-box button {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border-radius: 3px;
      border: 1px solid #666;
      background: #f0f0f0;
      cursor: pointer;
    }
    .home-box button:hover {
      background: #e0e0e0;
    }

    /* Counter inline neben Suchfeld */
    .counter-inline {
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 500;
      color: #555;
      white-space: nowrap;
      padding: 0 4px;
      display: flex;
      align-items: center;
      height: 36px;
    }

    /* Language Toggle Button */
    .lang-btn {
      flex: 0 0 auto;
      height: 28px;
      min-width: 32px;
      padding: 0 8px;
      font-size: 11px;
      font-weight: 700;
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 6px;
      background: #f5f5f5;
      color: #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, border-color 0.15s;
    }
    .lang-btn:hover {
      background: #e8e8e8;
      border-color: rgba(0,0,0,0.35);
    }
    .lang-btn:active {
      background: #ddd;
    }

    /* Responsive: Mobile Layout */
    @media (max-width: 720px) {
      /* --- Strong overrides for mobile topbar layout --- */
      .search-box .search-row{ flex-wrap: nowrap !important; }
      #resort-search{ min-width: 0 !important; }
      #search-btn{ min-width: 56px; }
      #clear-verbund-btn,
      #mobile-panel-toggle{ width: 44px; min-width: 44px; height: 44px; padding: 0 !important; }
      #clear-verbund-btn{ border-radius: 10px !important; }

      /* Zoom-Buttons auf Mobile ausblenden (Pinch-to-Zoom ist Standard) */
      .leaflet-control-zoom {
        display: none !important;
      }

      /* Auf Mobile aufräumen */
      .home-box { display: none !important; }               /* Startadresse ausblenden */
      .legend-box { display: none !important; }             /* Legende ausblenden */
      .weather-box { display: none !important; }            /* Weather in Slider-Box auf Mobile */
      .slider-box { display: none !important; }             /* Desktop Slider-Box ausblenden */

      /* Desktop Controls (Layer/Filter/Export) auf Mobile verstecken */
      .leaflet-top.leaflet-right .leaflet-control-layers,
      .leaflet-top.leaflet-right .filter-box,
      .leaflet-top.leaflet-right .export-box {
        display: none !important;
      }

      /* Suchleiste oben als "Card" */
      .search-box label{ display:none; }

      /* Top-Bar: Input + Go + X + Menü in EINER Zeile */
      #search-btn{
        height: 44px;
        padding: 0 10px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
        min-width: 56px;
        flex: 0 0 auto !important;
      }
      #clear-verbund-btn,
      #mobile-panel-toggle{
        width: 44px;
        min-width: 44px;
        height: 44px;
        padding: 0 !important;
        flex: 0 0 auto !important;
      }
      /* falls irgendwo noch alte Flex-Regeln greifen */
      #clear-verbund-btn{ margin-left: 0 !important; }

      .search-box {
        top: calc(env(safe-area-inset-top, 0px) + 8px) !important;
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        max-width: none !important;
        padding: 8px 10px 10px 10px !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        backdrop-filter: blur(8px);
        background: rgba(255,255,255,0.92) !important;
      }
      .search-box label {
        display: block;
        font-size: 14px !important;
        margin-bottom: 6px !important;
      }

      .search-row { gap: 8px !important; flex-wrap: wrap !important; }

      #resort-search {
        flex: 1 1 220px !important;
        min-width: 180px;
        height: 44px;
        padding: 10px 12px !important;
        font-size: 16px !important; /* verhindert iOS auto-zoom */
        border-radius: 10px !important;
      }

      #search-btn,
      #clear-verbund-btn {
        height: 44px;
        padding: 0 12px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
      }
/* Leaflet Controls nicht unter der Suchbox verstecken */
      .leaflet-top.leaflet-right {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        right: 12px !important;
        z-index: 2000;
      }
      .leaflet-top.leaflet-left {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        left: 8px !important;
        z-index: 2000;
      }

      /* Filter-Box: scrollfähig und touch-freundlich */
      .filter-box.leaflet-control {
        width: min(52vw, 260px) !important;
        max-height: 48vh;
        overflow: auto;
        border-radius: 14px;
      }
      .filter-box label { padding: 8px 2px; }
      .filter-box input[type="checkbox"] { width: 20px; height: 20px; }

      /* Layer-Control: komfortabler auf Touch */
      .leaflet-control-layers {
        width: min(52vw, 260px) !important;
        border-radius: 14px;
        max-height: 48vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .leaflet-control-layers-toggle { width: 44px; height: 44px; }
      .leaflet-control-layers label { padding: 8px 2px; }

      /* Slider unten als "Bottom Bar" */
      .slider-box {
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        background: rgba(255,255,255,0.92) !important;
        backdrop-filter: blur(8px);
        transition: transform 0.3s ease;
      }

      /* Mobile: Slider-Box Toggle anpassen */
      .slider-box-toggle {
        justify-content: center;
        height: 28px;
        margin: -8px 0 4px 0;
      }
      .slider-box-toggle .toggle-title {
        display: none; /* Titel auf Mobile verstecken */
      }
      .slider-box-toggle .toggle-icon {
        font-size: 14px;
      }
      .slider-box.collapsed .toggle-icon {
        transform: rotate(180deg);
      }
      .slider-box.collapsed {
        padding: 4px 12px !important;
      }

    }

    /* Layer-Control: nie "abschneiden" und scrollbar machen */
    .leaflet-top.leaflet-right { z-index: 2000; }
    .leaflet-control-layers { max-height: 70vh; overflow-y: auto; overflow-x: hidden; }


    /* A11y helpers */
    .sr-only{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }
.icon-btn{
  width:36px;
  height:36px;
  border:1px solid #666;
  border-radius:10px;
  background:#f0f0f0;
  cursor:pointer;
  font-size:16px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:0;
  flex: 0 0 auto;
}
.icon-btn:hover{ background:#e0e0e0; }

    /* Button text variants */
    #clear-verbund-btn .btn-short{ display:none; }
    #clear-verbund-btn .btn-full{ display:inline; }

    /* Mobile Slide-In Panel (Filter + Layer) */
    #mobile-panel-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 3500;
    }
    #mobile-panel{
      position: fixed;
      top: var(--search-bottom, 76px);
      right: 0;
      height: calc(100dvh - var(--search-bottom, 76px));
      width: min(84vw, 340px);
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(10px);
      box-shadow: -12px 0 28px rgba(0,0,0,0.22);
      transform: translateX(102%);
      transition: transform .22s ease;
      z-index: 3600;
      padding: 14px 12px calc(env(safe-area-inset-bottom, 0px) + 12px) 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Controls im Mobile-Panel sollen volle Breite nutzen */
    #mobile-panel .leaflet-control,
    #mobile-panel .leaflet-control-layers,
    #mobile-panel .filter-box.leaflet-control{
      width: 100% !important;
      max-width: none !important;
    }
    #mobile-panel .leaflet-control-layers-list{
      margin: 0 !important;
    }
    #mobile-panel h3{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: .85;
    }
    #mobile-panel .panel-section{
      overflow: auto;
      border-radius: 14px;
    }
    body.mobile-panel-open #mobile-panel-backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.mobile-panel-open #mobile-panel{
      transform: translateX(0);
    }
    @media (min-width: 721px){
      #mobile-panel, #mobile-panel-backdrop, #mobile-panel-toggle{ display:none !important; }
    }

.control-select {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.2);
  background: white;
}




/* --- Fix: Legacy-Startpunkt-Box ausblenden (falls sie noch existiert) --- */
#homeSelectorBox,
.homeSelectorBox,
.leaflet-control.home-selector,
.leaflet-control.homeSelector {
  display: none !important;
}

/* --- Fix: Seite nicht scrollbar (verhindert weißen Leerraum unten auf Mobile) --- */
html, body {
  overflow: hidden;
}

/* --- Slider-Box wirklich als Overlay (nicht im Dokumentfluss) --- */
.slider-box {
  position: fixed !important;
  left: 20px;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
}

/* Toggle-Button für Slider-Box (Desktop + Mobile) */
.slider-box-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  margin: 0 0 6px 0;
  font-size: 13px;
  font-weight: 600;
  color: rgba(0,0,0,0.86);
}
.slider-box-toggle .toggle-icon {
  font-size: 10px;
  color: #666;
  transition: transform 0.2s ease;
}
.slider-box.collapsed .toggle-icon {
  transform: rotate(-90deg);
}
.slider-box.collapsed .slider-box-content {
  display: none;
}
.slider-box-toggle .toggle-title {
  flex: 1;
  text-align: left;
}

/* Mobile: etwas kompakter, damit nichts überlappt */
@media (max-width: 640px){
  .slider-box{
    left: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    max-width: min(320px, calc(100vw - 24px));
    width: calc(100vw - 24px);
  }
}

/* --- Weather-Box (rechte Seite) --- */
.weather-box {
  position: fixed !important;
  right: 20px;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
  z-index: 2001; /* Higher than .leaflet-top.leaflet-right (2000) */
  background: rgba(255,255,255,0.96);
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  padding: 10px 14px;
  font-size: 13px;
  min-width: 200px;
  max-width: 260px;
  transition: right 0.3s ease;
}
.weather-box.shifted {
  right: 240px; /* Nach links verschieben wenn Controls zu hoch */
}
.weather-box-toggle {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  margin: 0 0 6px 0;
  font-size: 13px;
  font-weight: 600;
  color: rgba(0,0,0,0.86);
}
.weather-box-toggle .toggle-icon {
  font-size: 10px;
  color: #666;
  transition: transform 0.2s ease;
}
.weather-box.collapsed .toggle-icon {
  transform: rotate(-90deg);
}
.weather-box.collapsed .weather-box-content {
  display: none;
}
.weather-box.collapsed {
  min-width: auto;
}
.weather-box-toggle .toggle-title {
  flex: 1;
  text-align: left;
}
.weather-box .weather-toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 2px;
}
.weather-last-update {
  font-size: 11px;
  color: #888;
  margin-bottom: 8px;
}
.weather-box .weather-toggle-switch {
  position: relative;
  width: 42px;
  height: 22px;
}
.weather-box .weather-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.weather-box .weather-toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc;
  transition: 0.3s;
  border-radius: 22px;
}
.weather-box .weather-toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
}
.weather-box .weather-toggle-switch input:checked + .weather-toggle-slider {
  background-color: #3b82f6;
}
.weather-box .weather-toggle-switch input:checked + .weather-toggle-slider:before {
  transform: translateX(20px);
}
.weather-box .timeframe-row {
  display: flex;
  gap: 4px;
  margin-bottom: 10px;
}
.weather-box .timeframe-btn {
  flex: 1;
  padding: 4px 6px;
  font-size: 11px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: #f5f5f5;
  cursor: pointer;
  transition: all 0.15s;
}
.weather-box .timeframe-btn:hover {
  background: #e8e8e8;
}
.weather-box .timeframe-btn.active {
  background: #3b82f6;
  color: white;
  border-color: #3b82f6;
}
/* Cumulative Toggle (Tag/Σ bis) */
.weather-box .cumulative-toggle-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
  font-size: 11px;
}
.weather-box .cumulative-label {
  color: #64748b;
}
.weather-box .cumulative-btn {
  padding: 2px 8px;
  font-size: 10px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: #f5f5f5;
  cursor: pointer;
  transition: all 0.15s;
}
.weather-box .cumulative-btn:hover {
  background: #e8e8e8;
}
.weather-box .cumulative-btn.active {
  background: #10b981;
  color: white;
  border-color: #10b981;
}
/* Daily buttons - smaller for 8 buttons */
.weather-box .day-btn {
  padding: 4px 2px 8px 2px; /* extra bottom padding for dot */
  font-size: 10px;
  min-width: 0;
  position: relative;
}
/* Snow indicator dot at bottom of day button */
.weather-box .day-btn .snow-dot {
  position: absolute;
  bottom: 2px;
  left: 50%;
  transform: translateX(-50%);
  width: 5px;
  height: 5px;
  border-radius: 50%;
  opacity: 0;
  transition: opacity 0.2s;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.25);
}
.weather-box .day-btn .snow-dot.visible {
  opacity: 1;
}
.weather-box .day-btn.active .snow-dot {
  bottom: 2px;
}
.weather-box .filter-row {
  margin-bottom: 8px;
}
.weather-box .filter-row label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  margin-bottom: 2px;
}
.weather-box .filter-row input[type="range"] {
  width: 100%;
  margin: 0;
}
.weather-box .legend {
  margin-top: 10px;
  padding-top: 8px;
  border-top: 1px solid #e5e7eb;
  font-size: 11px;
}
.weather-box .legend-title {
  font-weight: 600;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.weather-box .legend-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.weather-box .legend-item {
  display: flex;
  align-items: center;
  gap: 3px;
}
.weather-box .legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.2);
}
@media (max-width: 640px) {
  .weather-box {
    right: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    max-width: min(240px, calc(100vw - 24px));
  }
}

/* Weather mobile section (in slider-box) */
.weather-mobile-section {
  display: none;  /* Hidden on desktop */
}
@media (max-width: 720px) {
  .weather-mobile-section {
    display: block;  /* Shown on mobile */
  }
}
.weather-header-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}
.weather-section-title {
  font-weight: 600;
  font-size: 13px;
}
.weather-info-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  padding: 2px 6px;
  border-radius: 50%;
  opacity: 0.7;
}
.weather-info-btn:hover {
  opacity: 1;
  background: rgba(0,0,0,0.05);
}

/* Travel time info button */
.travel-time-info-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 12px;
  padding: 2px 4px;
  border-radius: 50%;
  opacity: 0.7;
  margin-left: 4px;
}
.travel-time-info-btn:hover {
  opacity: 1;
  background: rgba(0,0,0,0.05);
}

/* Travel time info dialog */
.travel-time-info-dialog {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  z-index: 10000;
  max-width: 420px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}
.travel-time-info-dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
  background: #f5f5f5;
  border-radius: 12px 12px 0 0;
}
.travel-time-info-dialog-header h3 {
  margin: 0;
  font-size: 16px;
}
.travel-time-info-dialog-close {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
}
.travel-time-info-dialog-close:hover {
  background: rgba(0,0,0,0.1);
}
.travel-time-info-dialog-content {
  padding: 16px;
  font-size: 13px;
  line-height: 1.5;
}
.travel-time-info-dialog-content h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
}
.travel-time-info-dialog-content p {
  margin: 0 0 12px 0;
  color: #555;
}
.travel-time-info-dialog-content .info-section {
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #eee;
}
.travel-time-info-dialog-content .info-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}
.travel-time-info-dialog-content .coverage-stat {
  background: #e8f5e9;
  padding: 8px 12px;
  border-radius: 6px;
  font-weight: 500;
  color: #2e7d32;
  margin: 8px 0;
}
.travel-time-info-dialog-content .bbox-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}
.travel-time-info-dialog-content .bbox-toggle input {
  width: 18px;
  height: 18px;
  cursor: pointer;
}
.travel-time-info-dialog-content .bbox-toggle label {
  cursor: pointer;
}
.travel-time-info-dialog-content .comparison-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
  margin-top: 8px;
}
.travel-time-info-dialog-content .comparison-table th,
.travel-time-info-dialog-content .comparison-table td {
  padding: 6px 8px;
  text-align: left;
  border: 1px solid #ddd;
}
.travel-time-info-dialog-content .comparison-table th {
  background: #f5f5f5;
  font-weight: 600;
}
.travel-time-info-dialog-content .comparison-table td:first-child {
  font-weight: 500;
  background: #fafafa;
}
.travel-time-info-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.4);
  z-index: 9999;
}

/* Weather info dialog (shares styles with travel time dialog) */
.weather-info-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.4);
  z-index: 9999;
}
.weather-info-dialog {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  z-index: 10000;
  max-width: 400px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}
.weather-info-dialog .info-dialog-header,
.travel-time-info-dialog .info-dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
  background: #f5f5f5;
  border-radius: 12px 12px 0 0;
}
.weather-info-dialog .info-dialog-header h3 {
  margin: 0;
  font-size: 16px;
}
.weather-info-dialog .info-dialog-close,
.travel-time-info-dialog .info-dialog-close {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
}
.weather-info-dialog .info-dialog-close:hover {
  background: rgba(0,0,0,0.1);
}
.weather-info-dialog .info-dialog-content {
  padding: 16px;
  font-size: 13px;
  line-height: 1.5;
}
.weather-info-dialog .info-dialog-content h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
}
.weather-info-dialog .info-dialog-content p {
  margin: 0 0 8px 0;
  color: #555;
}
.weather-info-dialog .info-dialog-content .info-section {
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid #eee;
}
.weather-info-dialog .info-dialog-content .info-section:last-child {
  border-bottom: none;
  margin-bottom: 0;
  padding-bottom: 0;
}

/* Home origin marker */
.home-origin-marker {
  background: transparent !important;
  border: none !important;
}
/* Mobile weather toggle & legend styles */
.weather-mobile-section .weather-toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}
.weather-mobile-section .weather-toggle-switch {
  position: relative;
  width: 42px;
  height: 22px;
}
.weather-mobile-section .weather-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.weather-mobile-section .weather-toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc;
  transition: 0.3s;
  border-radius: 22px;
}
.weather-mobile-section .weather-toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
}
.weather-mobile-section .weather-toggle-switch input:checked + .weather-toggle-slider {
  background-color: #3b82f6;
}
.weather-mobile-section .weather-toggle-switch input:checked + .weather-toggle-slider:before {
  transform: translateX(20px);
}
/* Mobile Cumulative Toggle */
.weather-mobile-section .cumulative-toggle-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
  font-size: 12px;
}
.weather-mobile-section .cumulative-label {
  color: #64748b;
}
.weather-mobile-section .cumulative-btn {
  padding: 3px 10px;
  font-size: 11px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: #fff;
  cursor: pointer;
}
.weather-mobile-section .cumulative-btn:hover {
  background: #f3f4f6;
}
.weather-mobile-section .cumulative-btn.active {
  background: #10b981;
  color: white;
  border-color: #10b981;
}
.weather-mobile-section .timeframe-row {
  display: flex;
  gap: 4px;
  margin-bottom: 10px;
}
.weather-mobile-section .timeframe-btn {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #d1d5db;
  background: #fff;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}
.weather-mobile-section .timeframe-btn:hover {
  background: #f3f4f6;
}
.weather-mobile-section .timeframe-btn.active {
  background: #3b82f6;
  color: white;
  border-color: #3b82f6;
}
.weather-mobile-section .legend {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #e5e7eb;
  font-size: 11px;
}
.weather-mobile-section .legend-title {
  font-weight: 600;
  margin-bottom: 4px;
}
.weather-mobile-section .legend-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.weather-mobile-section .legend-item {
  display: flex;
  align-items: center;
  gap: 3px;
}
.weather-mobile-section .legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,0.2);
}

/* Startpunkt (Dropdown) oberhalb des Sliders */
.startpoint-row{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:6px;
}
.startpoint-row .control-select{
  flex:1;
}
.gps-btn{
  padding:4px 8px;
  font-size:14px;
  border:1px solid #888;
  border-radius:4px;
  background:#f5f5f5;
  cursor:pointer;
  line-height:1;
}
.gps-btn:hover{
  background:#e8e8e8;
}
.gps-btn:disabled{
  opacity:0.6;
  cursor:wait;
}
.startpoint-input-row{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:6px;
  margin-top:6px;
}
.startpoint-input{
  flex:1;
  padding:4px 6px;
  font-size:12px;
  border:1px solid #aaa;
  border-radius:4px;
  min-width:0;
}
.calc-btn{
  padding:4px 8px;
  font-size:12px;
  border:1px solid #888;
  border-radius:4px;
  background:#f5f5f5;
  cursor:pointer;
  line-height:1;
}
.calc-btn:hover{
  background:#e8e8e8;
}
.startpoint-title{
  font-weight:600;
  font-size:12px;
  opacity:.9;
}
.slider-sep{
  height:1px;
  background: rgba(0,0,0,.12);
  margin: 10px 0 8px 0;
}


/* Label + Fahrzeit in einer Zeile */
.time-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:6px;
}
.time-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
}
.time-value{
  font-weight:700;
  color:#1a73e8;
  white-space:nowrap;
}

/* Neue Filter-Slider Zeilen */
.filter-slider-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:4px;
  margin-top:8px;
}
.filter-slider-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
  font-size:12px;
}
.filter-value{
  font-weight:600;
  color:#1a73e8;
  white-space:nowrap;
  font-size:12px;
}

/* Mobile Panel: etwas aufgeräumter */
#mobile-panel h3{
  letter-spacing: .2px;
}
#mobile-panel .panel-section{
  display:flex;
  flex-direction:column;
  gap: 10px;
}

/* --- Desktop: Home-Box dauerhaft ausblenden (Dropdown sitzt im Slider) --- */
@media (min-width: 721px){
  .home-box{ display:none !important; }
}

/* --- Desktop: sauberer Stack in Leaflet top-right --- */
.desktop-control-stack{
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.desktop-control-stack .leaflet-control{
  margin: 0 !important;
}

/* --- Mobile Panel: Accordion --- */
.panel-accordion{
  margin: 0;
  padding: 0;
  border: 0;
  background: transparent;
}
#mobile-panel details.panel-accordion > summary{
  list-style: none;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  font-weight: 800;
  font-size: 14px;
  padding: 6px 2px;
  margin: 0;
}
#mobile-panel details.panel-accordion > summary::-webkit-details-marker{ display:none; }
#mobile-panel details.panel-accordion > summary::after{
  content: "▾";
  opacity: .65;
  font-size: 14px;
  transform: translateY(-1px);
}
#mobile-panel details.panel-accordion[open] > summary::after{ content: "▴"; }
#mobile-panel details.panel-accordion + details.panel-accordion{ margin-top: 8px; }



/* --- Last search highlight (ring + subtle pulse) --- */
.leaflet-interactive.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}
img.leaflet-marker-icon.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}

.last-search-indicator {
  /* color of the ring (override Leaflet default path styling) */
  stroke: rgba(255, 204, 0, 0.95);
  stroke-width: 3;
  fill: transparent;
}
.last-search-indicator.pulse {
  animation: lastSearchRing 1.2s ease-out 0s 1;
  transform-origin: center;
}

@keyframes lastSearchRing {
  0%   { opacity: 1; transform: scale(0.6); }
  100% { opacity: 0; transform: scale(1.8); }
}
@keyframes lastSearchBounce {
  0%   { transform: translateY(0); }
  20%  { transform: translateY(-10px); }
  45%  { transform: translateY(0); }
  65%  { transform: translateY(-6px); }
  100% { transform: translateY(0); }
}


/* --- FIX: Desktop right controls unified width + edge spacing --- */
:root{
  --right-controls-w: 210px;
  --right-controls-pad: 12px;
}

/* Abstand zum rechten/oberen Rand (wirkt wie "margin" zur Karte) */
.leaflet-top.leaflet-right{
  padding-right: var(--right-controls-pad) !important;
  padding-top: var(--right-controls-pad) !important;
}

/* Alle Panel-Controls (Layers / Filters / Export) exakt gleich breit (outer width) */
.leaflet-top.leaflet-right .leaflet-control-layers,
.leaflet-top.leaflet-right .filter-box.leaflet-control,
.leaflet-top.leaflet-right .export-box.leaflet-control{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important; /* Leaflet layers war sonst content-box -> wird breiter */
}

/* Sicherheit: auch im expanded state gleich breit */
.leaflet-top.leaflet-right .leaflet-control-layers.leaflet-control-layers-expanded{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important;
}



/* --- FIX: Unified UI font sizes (side panel + right controls) --- */
:root{
  --ui-font-size: 14px;
  --ui-font-size-small: 12px;
  --ui-font-size-title: 14px;
}

/* Desktop right controls */
.leaflet-top.leaflet-right .leaflet-control{
  font-size: var(--ui-font-size) !important;
}

/* Mobile side panel: accordion titles + all Leaflet controls inside */
#mobile-panel details.panel-accordion > summary{
  font-size: var(--ui-font-size-title) !important;
}

#mobile-panel .leaflet-control,
#mobile-panel .leaflet-control-layers,
#mobile-panel .filter-box,
#mobile-panel .export-box{
  font-size: var(--ui-font-size) !important;
}

#mobile-panel .leaflet-control-layers label,
#mobile-panel .leaflet-control-layers-list,
#mobile-panel .filter-box label{
  font-size: var(--ui-font-size) !important;
}

/* Small caps headings inside Leaflet layer control (KARTE / OVERLAYS) */
#mobile-panel .leaflet-control-layers-base,
#mobile-panel .leaflet-control-layers-overlays{
  font-size: var(--ui-font-size-small) !important;
}

/* Export buttons in panel/desktop (exclude panel-toggle) */
.export-box .panel-content button{
  font-size: var(--ui-font-size) !important;
}


/* --- Font: modern, highly legible on mobile + desktop (no external downloads) --- */
:root{
  /* "Inter" if installed, otherwise system UI fonts */
  --ui-font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}

/* Apply everywhere */
html, body{
  font-family: var(--ui-font-family) !important;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

button, input, select, textarea{
  font-family: var(--ui-font-family) !important;
}

/* Leaflet UI inherits reliably */
.leaflet-container,
.leaflet-control,
.leaflet-popup,
.leaflet-tooltip{
  font-family: var(--ui-font-family) !important;
}

/* --- Draggable Popup --- */
.leaflet-popup-content-wrapper {
  cursor: grab;
}
.leaflet-popup-content-wrapper.dragging {
  cursor: grabbing;
  opacity: 0.95;
}
.leaflet-popup.dragging {
  transition: none !important;
}
.leaflet-popup-content-wrapper::before {
  content: '';
  display: block;
  width: 40px;
  height: 4px;
  background: #d1d5db;
  border-radius: 2px;
  margin: 0 auto 6px auto;
}
.leaflet-popup-content-wrapper:hover::before {
  background: #9ca3af;
}

/* --- Unified checkbox/radio sizing (mobile + desktop) --- */
:root{
  --ui-check-size: 18px;   /* try 16-20px */
  --ui-check-scale: 1.1;   /* helps on browsers that ignore width/height on native inputs */
}

/* Target Leaflet layers control + our filter box (desktop) */
.leaflet-control-layers input[type="checkbox"],
.leaflet-control-layers input[type="radio"],
.filter-box input[type="checkbox"],
.filter-box input[type="radio"],
.export-box input[type="checkbox"],
.export-box input[type="radio"],
/* Target everything inside the mobile side panel */
#mobile-panel input[type="checkbox"],
#mobile-panel input[type="radio"]{
  inline-size: var(--ui-check-size);
  block-size: var(--ui-check-size);
  transform: scale(var(--ui-check-scale));
  transform-origin: center;
  vertical-align: middle;
  margin-right: 8px;
}

/* Keep label text nicely aligned */
.leaflet-control-layers label,
.filter-box label,
#mobile-panel label{
  line-height: 1.35;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* When using flex+gap, don't double-space from margin-right */
.leaflet-control-layers label input,
.filter-box label input,
#mobile-panel label input{
  margin-right: 0;
}


/* --- FIX: Mobile panel horizontal overflow (Layers control was wider due to content-box + padding) --- */
#mobile-panel .panel-section{
  overflow-x: hidden !important;  /* prevent sideways scroll */
  overflow-y: auto !important;
}

#mobile-panel .leaflet-control-layers,
#mobile-panel .leaflet-control-layers.leaflet-control-layers-expanded{
  box-sizing: border-box !important; /* include padding/border in width */
  max-width: 100% !important;
  width: 100% !important;
}


/* --- FIX: Filter box tiny horizontal scroll in mobile panel --- */
#mobile-panel .filter-box.leaflet-control{
  box-sizing: border-box !important;
  width: 100% !important;
  max-width: 100% !important;
  overflow-x: hidden !important; /* keep vertical scroll, kill horizontal */
}

/* Some browsers still create 1–2px overflow due to label/gap -> clamp */
#mobile-panel .filter-box.leaflet-control *{
  max-width: 100% !important;
}

/* Mobile-Panel: Panel-Toggles verstecken (Accordions übernehmen das Einklappen) */
#mobile-panel .panel-toggle {
  display: none !important;
}
#mobile-panel .panel-content {
  display: block !important; /* Immer sichtbar im Mobile-Panel */
}
#mobile-panel .filter-box.collapsed,
#mobile-panel .export-box.collapsed,
#mobile-panel .gps-box.collapsed,
#mobile-panel .leaflet-control-layers.collapsed {
  padding: var(--panel-pad) !important; /* Reset collapsed padding */
}

/* GPS toggle inside export box */
.export-box label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.export-box .gps-hint{
  font-size: 11px;
  color: rgba(0,0,0,0.68);
  margin-top: 4px;
}


/* GPS center button */
.gps-control .gps-row{
  display:flex;
  align-items:center;
  gap:10px;
}
.gps-control .gps-center-btn{
  margin-left:auto;
  padding: 4px 8px;
  font-size: 12px;
  line-height: 1.2;
  border: 1px solid rgba(0,0,0,0.18);
  border-radius: 10px;
  background: rgba(255,255,255,0.9);
  cursor: pointer;
}
.gps-control .gps-center-btn:active{
  transform: translateY(1px);
}

/* GPS Map Button (standalone, above zoom controls on mobile) */
.gps-map-btn-container {
  margin-bottom: 10px !important;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
  border-radius: 50% !important;
  overflow: hidden;
  border: none !important;
}
.gps-map-btn {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 40px !important;
  height: 40px !important;
  line-height: 40px !important;
  padding: 0 !important;
  margin: 0 !important;
  background: #fff;
  color: #444;
  text-decoration: none;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease;
  border: none !important;
  border-radius: 50% !important;
}
.gps-map-btn:hover {
  background: #f5f5f5;
  color: #333;
}
.gps-map-btn:active {
  background: #e8e8e8;
}
.gps-map-btn.gps-active {
  background: #00E676;
  color: #fff;
  box-shadow: 0 0 0 3px rgba(255,255,255,0.95), 0 2px 8px rgba(0,0,0,0.3) !important;
}
.gps-map-btn.gps-active:hover {
  background: #00C853;
  color: #fff;
  box-shadow: 0 0 0 3px rgba(255,255,255,0.95), 0 2px 10px rgba(0,0,0,0.4) !important;
}
.gps-map-btn svg {
  display: block;
}

/* Desktop: hide map button, use panel checkbox instead */
@media (min-width: 721px) {
  .gps-map-btn-container {
    display: none !important;
  }
}

/* Mobile: GPS button fixed above zoom controls */
@media (max-width: 720px) {
  .gps-map-btn-container {
    position: fixed !important;
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 156px) !important;
    left: auto !important;
    top: auto !important;
    z-index: 4000 !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25) !important;
  }
  .gps-map-btn {
    width: 48px !important;
    height: 48px !important;
  }
  .gps-map-btn svg {
    width: 26px;
    height: 26px;
  }
}

/* GPS pulse effect when centering on location */
@keyframes gps-pulse {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}
.gps-pulse-ring {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 3px solid #4285F4;
  border-radius: 50%;
  pointer-events: none;
  animation: gps-pulse 0.8s ease-out forwards;
}

/* Snow Badge (Bergfex-Style) */
.snow-badge {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  border: 1.5px solid rgba(255,255,255,0.9);
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  font-size: 10px;
  color: white;
  text-shadow: 0 0 2px rgba(0,0,0,0.5);
  pointer-events: none;
  z-index: 500;
}
.snow-badge-small { width: 14px; height: 14px; font-size: 8px; }
.snow-badge-medium { width: 18px; height: 18px; font-size: 10px; }
.snow-badge-large { width: 22px; height: 22px; font-size: 12px; }
.snow-badge-wrapper { background: transparent !important; border: none !important; }

/* Snow Badge Canvas Layer - bleibt sichtbar, Leaflet verschiebt per CSS transform */

/* Snow info in popup */
.snow-forecast-section {
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid #e5e7eb;
}

.snow-forecast-section .snow-amount {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: 600;
  font-size: 12px;
}

.snow-amount.heavy { background: #dbeafe; color: #1e40af; }
.snow-amount.moderate { background: #e0f2fe; color: #0369a1; }
.snow-amount.light { background: #f1f5f9; color: #475569; }

/* 16-Tage-Prognose im Popup */
.forecast-details {
  margin-top: 6px;
}
.forecast-details summary {
  cursor: pointer;
  color: #3b82f6;
  font-size: 11px;
  user-select: none;
}
.forecast-details summary:hover {
  text-decoration: underline;
}
.forecast-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 11px;
  margin-top: 4px;
}
.forecast-table th {
  text-align: left;
  padding: 2px 4px;
  border-bottom: 1px solid #e5e7eb;
  font-weight: 600;
  color: #64748b;
}
.forecast-table td {
  padding: 2px 4px;
}
.forecast-table tr.odd {
  background: #f8fafc;
}
.forecast-table tr.even {
  background: white;
}
.forecast-table-compact td:first-child {
  min-width: 55px;
}
.geosphere-note {
  font-size: 10px;
  color: #94a3b8;
  margin: 2px 0 4px 0;
  font-style: italic;
}

/* Favoriten-Stern im Popup */
.fav-star {
  cursor: pointer;
  font-size: 16px;
  margin-left: 6px;
  color: #d1d5db;
  transition: color 0.15s, transform 0.15s;
  user-select: none;
}
.fav-star:hover {
  color: #fbbf24;
  transform: scale(1.2);
}
.fav-star.active {
  color: #f59e0b;
}
.fav-star.active:hover {
  color: #dc2626;
}

/* Besucht-Toggle im Popup */
.visited-check {
  cursor: pointer;
  font-size: 14px;
  margin-left: 4px;
  color: #d1d5db;
  transition: color 0.15s, transform 0.15s;
  user-select: none;
}
.visited-check:hover {
  color: #22c55e;
  transform: scale(1.2);
}
.visited-check.active {
  color: #16a34a;
}
.visited-check.active:hover {
  color: #dc2626;
}

/* Gletscher-Badge im Popup */
.glacier-badge {
  display: inline-block;
  background: linear-gradient(135deg, #43C4F5, #3D8DF3);
  color: white;
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 0.7em;
  font-weight: bold;
  margin-left: 6px;
  vertical-align: middle;
}

/* Access Points im Popup */
.access-points-section {
  margin-top: 6px;
  padding-top: 6px;
  border-top: 1px solid #e5e7eb;
}
.access-points-list {
  font-size: 12px;
  line-height: 1.6;
}
.access-point-link {
  color: #2563eb;
  text-decoration: none;
  white-space: nowrap;
}
.access-point-link:hover {
  text-decoration: underline;
}
.show-access-points-btn {
  background: #f3f4f6;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  padding: 2px 6px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 4px;
  vertical-align: middle;
}
.show-access-points-btn:hover {
  background: #e5e7eb;
}

/* Access Point Marker auf der Karte */
.access-point-marker {
  background: #2563eb;
  border: 2px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

/* Marker-Icons für Favorit/Besucht (ersetzt den normalen Kreis-Marker) */
.marker-icon-wrapper {
  background: transparent !important;
  border: none !important;
}
.marker-icon-favorite {
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.4));
}
.marker-icon-visited {
  font-weight: bold;
  line-height: 1;
}

/* ============================================
   BOTTOM SHEET (Mobile Only)
   ============================================ */

:root {
  --bs-peek-height: 72px;
  --bs-half-height: 50dvh;
  --bs-full-height: 100dvh;
  --bs-handle-height: 32px; /* Touch-friendly handle area */
  --bs-bg: rgba(255, 255, 255, 0.98);
  --bs-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
  --bs-radius: 16px;
  --bs-transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Fallback for browsers that don't support dvh */
@supports not (height: 100dvh) {
  :root {
    --bs-half-height: 50vh;
    --bs-full-height: calc(100vh - env(safe-area-inset-bottom, 0px));
  }
}

/* Hide Bottom Sheet on Desktop */
@media (min-width: 721px) {
  #bottom-sheet,
  #bottom-sheet-backdrop {
    display: none !important;
  }
}

/* On mobile, search-box needs lower z-index so bottom sheet can slide over it */
@media (max-width: 720px) {
  .search-box {
    z-index: 4000 !important;
  }
}

/* Backdrop */
#bottom-sheet-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.4);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s ease;
  z-index: 4900;
}
#bottom-sheet-backdrop.active {
  opacity: 1;
  pointer-events: auto;
}

/* Bottom Sheet Container */
#bottom-sheet {
  position: fixed;
  left: 0;
  right: 0;
  top: 80px; /* Leave space for search box */
  bottom: 0;
  background: var(--bs-bg);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-radius: var(--bs-radius) var(--bs-radius) 0 0;
  box-shadow: var(--bs-shadow);
  z-index: 5000;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  transition: var(--bs-transition);
  padding-bottom: env(safe-area-inset-bottom, 0px);
  transform: translateY(calc(100% - 32px)); /* Default: hidden state - only handle visible */
}

/* State: Peek (default) - show 72px */
#bottom-sheet[data-state="peek"] {
  transform: translateY(calc(100% - 72px));
}

/* State: Half - show 50% */
#bottom-sheet[data-state="half"] {
  transform: translateY(50%);
}

/* State: Full - show everything */
#bottom-sheet[data-state="full"] {
  transform: translateY(0);
}

/* State: Hidden - only handle visible (32px) */
#bottom-sheet[data-state="hidden"] {
  transform: translateY(calc(100% - 32px));
}

/* Disable transition during drag */
#bottom-sheet.dragging {
  transition: none !important;
}

/* Handle Area (Touch Target) */
.bs-handle-area {
  flex: 0 0 var(--bs-handle-height);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: grab;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  position: relative;
}
.bs-handle-area:active {
  cursor: grabbing;
}

/* Handle Bar */
.bs-handle {
  width: 40px;
  height: 5px;
  background: #d1d5db;
  border-radius: 3px;
  transition: background 0.2s ease;
}
.bs-handle-area:hover .bs-handle,
.bs-handle-area:focus .bs-handle {
  background: #9ca3af;
}

/* Peek Content (Counter + Chips) */
.bs-peek-content {
  flex: 0 0 auto;
  padding: 0 12px 8px 12px;
  display: flex;
  align-items: center;
  gap: 12px;
  min-height: 36px;
}

/* Resort Counter */
.bs-counter {
  flex: 0 0 auto;
  font-size: 14px;
  font-weight: 600;
  color: rgba(0, 0, 0, 0.7);
  white-space: nowrap;
}

/* Filter Chips (Horizontal Scroll) */
.bs-chips {
  flex: 1 1 auto;
  display: flex;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
  -ms-overflow-style: none;
  padding: 4px 0;
}
.bs-chips::-webkit-scrollbar {
  display: none;
}

/* Individual Chip */
.bs-chip {
  flex: 0 0 auto;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  background: #f3f4f6;
  border: 1px solid #e5e7eb;
  border-radius: 20px;
  font-size: 13px;
  font-weight: 500;
  color: #374151;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.15s ease;
  min-height: 32px;
  min-width: 44px;
  justify-content: center;
}
.bs-chip:active {
  transform: scale(0.96);
}
.bs-chip.active {
  background: #3b82f6;
  border-color: #3b82f6;
  color: white;
}
.bs-chip .chip-icon {
  font-size: 14px;
}

/* Scrollable Content Area */
.bs-content {
  flex: 1 1 auto;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
  padding: 0 16px 16px 16px;
}

/* Prevent scroll when in peek state */
#bottom-sheet[data-state="peek"] .bs-content {
  overflow: hidden;
  pointer-events: none;
}

/* Section */
.bs-section {
  margin-bottom: 20px;
}

.bs-section-title {
  font-size: 15px;
  font-weight: 700;
  color: rgba(0, 0, 0, 0.85);
  margin: 0 0 12px 0;
  padding-top: 4px;
}

/* Divider */
.bs-divider {
  height: 1px;
  background: rgba(0, 0, 0, 0.1);
  margin: 16px 0;
}

/* Full-Only Sections (hidden in peek/half) */
.bs-full-only {
  display: none;
}
#bottom-sheet[data-state="full"] .bs-full-only {
  display: block;
}

/* Slider Rows */
.bs-slider-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}
.bs-slider-row label {
  font-size: 13px;
  color: rgba(0, 0, 0, 0.75);
}
.bs-slider-value {
  font-size: 13px;
  font-weight: 600;
  color: rgba(0, 0, 0, 0.85);
}

/* Sliders */
.bs-section input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #e5e7eb;
  outline: none;
  margin-bottom: 12px;
  -webkit-appearance: none;
  touch-action: pan-x; /* Allow horizontal swipe for slider on mobile */
}
.bs-section input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: #3b82f6;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}
.bs-section input[type="range"]::-moz-range-thumb {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: #3b82f6;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  border: none;
}

/* Startpoint Row */
.bs-startpoint-row {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.bs-startpoint-row select {
  flex: 1;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  font-size: 14px;
  background: white;
}
.bs-gps-btn {
  flex: 0 0 44px;
  height: 44px;
  border: 1px solid #d1d5db;
  border-radius: 10px;
  background: white;
  font-size: 18px;
  cursor: pointer;
}
.bs-gps-btn:active {
  background: #f3f4f6;
}

/* Toggle Switch */
.bs-toggle-switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 28px;
}
.bs-toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.bs-toggle-slider {
  position: absolute;
  cursor: pointer;
  inset: 0;
  background: #d1d5db;
  border-radius: 28px;
  transition: 0.3s;
}
.bs-toggle-slider::before {
  content: "";
  position: absolute;
  width: 22px;
  height: 22px;
  left: 3px;
  bottom: 3px;
  background: white;
  border-radius: 50%;
  transition: 0.3s;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}
.bs-toggle-switch input:checked + .bs-toggle-slider {
  background: #3b82f6;
}
.bs-toggle-switch input:checked + .bs-toggle-slider::before {
  transform: translateX(20px);
}

/* Weather Toggle Row */
.bs-weather-toggle-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

/* Mode Buttons */
.bs-mode-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}
.bs-mode-row span {
  font-size: 13px;
  color: rgba(0, 0, 0, 0.6);
}
.bs-mode-btn {
  padding: 6px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  background: white;
  font-size: 13px;
  cursor: pointer;
}
.bs-mode-btn.active {
  background: #3b82f6;
  border-color: #3b82f6;
  color: white;
}

/* Day Buttons */
.bs-day-row {
  display: flex;
  gap: 6px;
  margin-bottom: 12px;
}
.bs-day-btn {
  flex: 1;
  padding: 8px 4px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  background: white;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  min-height: 36px;
}
.bs-day-btn.active {
  background: #3b82f6;
  border-color: #3b82f6;
  color: white;
}

/* Filter Content in Full State - Chip Groups */
.bs-filter-group {
  margin-bottom: 16px;
}
.bs-filter-group-title {
  font-size: 12px;
  font-weight: 600;
  color: rgba(0, 0, 0, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.bs-filter-group-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.bs-dropdown-row {
  margin-top: 10px;
}
.bs-dropdown {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  font-size: 14px;
  background: white;
  cursor: pointer;
}

/* FAB Adjustments when Bottom Sheet is visible */
@media (max-width: 720px) {
  /* Hide old mobile elements when bottom sheet is active */
  #mobile-panel,
  #mobile-panel-backdrop,
  #mobile-panel-toggle {
    display: none !important;
  }

  /* Slider-box hidden on mobile (replaced by bottom sheet) */
  .slider-box {
    display: none !important;
  }

  /* Counter in search box hidden (shown in bottom sheet) */
  .search-row #resort-counter {
    display: none !important;
  }

  /* Language toggle hidden (shown in bottom sheet) */
  .search-row #lang-toggle {
    display: none !important;
  }

  /* GPS Button above bottom sheet */
  .gps-map-btn-container {
    bottom: calc(var(--bs-peek-height) + env(safe-area-inset-bottom, 0px) + 16px) !important;
    transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  body.bs-half .gps-map-btn-container {
    bottom: calc(var(--bs-half-height) + 16px) !important;
  }
  body.bs-full .gps-map-btn-container {
    opacity: 0;
    pointer-events: none;
  }

}

</style>

</head>
<body>

<div id="map"></div>

<!-- Suchfeld -->
<form id="resort-search-form" class="search-box" autocomplete="off">
  <label for="resort-search" class="sr-only">Skigebiet suchen</label>
  <div class="search-row">
    <input
      id="resort-search"
      list="resort-datalist"
      type="search"
      inputmode="search"
      enterkeyhint="search"
      autocapitalize="off"
      placeholder="Let's..."
    />
    <button id="search-btn" type="submit" data-i18n-title="searchExecute" title="Suche ausführen" data-i18n="go">Go</button>
    <button id="clear-verbund-btn" type="button" disabled class="icon-btn icon-btn--danger" data-i18n-aria="clearFilter" aria-label="Verbundfilter aufheben" data-i18n-title="clearFilter" title="Verbundfilter aufheben">✕</button>
    <!-- Counter sichtbare Resorts -->
    <span id="resort-counter" class="counter-inline">0 / 0</span>
    <!-- Language Toggle -->
    <button id="lang-toggle" type="button" class="lang-btn" title="Switch to English"><svg viewBox="0 0 60 30" width="24" height="12"><clipPath id="gb"><rect width="60" height="30"/></clipPath><g clip-path="url(#gb)"><path d="M0,0v30h60V0z" fill="#012169"/><path d="M0,0L60,30M60,0L0,30" stroke="#fff" stroke-width="6"/><path d="M0,0L60,30M60,0L0,30" stroke="#C8102E" stroke-width="4" clip-path="url(#gb)"/><path d="M30,0v30M0,15h60" stroke="#fff" stroke-width="10"/><path d="M30,0v30M0,15h60" stroke="#C8102E" stroke-width="6"/></g></svg></button>
    <button id="mobile-panel-toggle" class="icon-btn" type="button" aria-pressed="false" data-i18n-title="filtersAndLayers" title="Filter & Layer" data-i18n-aria="openFilters" aria-label="Filter und Layer öffnen">☰</button>
    </div>
  <datalist id="resort-datalist"></datalist>
</form>

<!-- Startadresse & Button -->
<div class="home-box">
  <label for="home-input">Startadresse (Adresse oder lat,lon)</label>
  <input
    id="home-input"
    type="text"
    placeholder="z.B. München, Marienplatz oder 48.12,11.57"
  />
  <button id="btn-calc-times" type="button">Fahrzeiten berechnen</button>
  <button id="btn-gps-times" type="button" title="GPS-Standort verwenden">📍 GPS</button>
</div>

<!-- Fahrzeit-Slider + Startpunkt -->
<div class="slider-box" id="slider-box">
  <button type="button" id="slider-box-toggle" class="slider-box-toggle" aria-label="Slider ein-/ausklappen" aria-expanded="true">
    <span class="toggle-title" data-i18n="travelTimeAndFilter">Fahrzeit & Filter</span>
    <span class="toggle-icon">▼</span>
  </button>
  <div class="slider-box-content">
  <div class="startpoint-row">
    <select id="homeSelectSlider" class="control-select" data-i18n-aria="selectStartpoint" aria-label="Startpunkt auswählen"></select>
    <button id="btn-gps-slider" type="button" class="gps-btn" data-i18n-title="useGps" title="GPS-Standort verwenden">📍</button>
  </div>
  <div class="startpoint-input-row">
    <input id="home-input-slider" type="text" data-i18n-placeholder="addressOrCoords" placeholder="Adresse oder lat,lon" class="startpoint-input" />
    <button id="btn-calc-slider" type="button" class="calc-btn" data-i18n-title="calculateTimes" title="Fahrzeiten berechnen">▶</button>
  </div>

  <div class="slider-sep"></div>

  <div class="time-row">
  <label for="time-slider" id="time-slider-title" data-i18n="maxTravelTime">Max. Fahrzeit</label>
  <button type="button" class="travel-time-info-btn" id="travel-time-info-btn" data-i18n-title="travelTimeInfoTitle" title="Fahrzeit-Info">ℹ️</button>
  <span id="time-slider-label" class="time-value">bis ca. 0h 00m</span>
</div>
<input id="time-slider" type="range" min="0" max="100" value="100" />

  <div class="slider-sep"></div>

  <!-- Neue Filter: Pistenkilometer, Lifte, Höhe -->
  <div class="filter-slider-row">
    <label for="pistes-slider" data-i18n="minPistes">Min. Pistenkilometer</label>
    <span id="pistes-slider-label" class="filter-value">0 km</span>
  </div>
  <input id="pistes-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="lifts-slider" data-i18n="minLifts">Min. Lifte</label>
    <span id="lifts-slider-label" class="filter-value">0</span>
  </div>
  <input id="lifts-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="elevation-slider" data-i18n="minElevation">Min. Höhe</label>
    <span id="elevation-slider-label" class="filter-value">0 m</span>
  </div>
  <input id="elevation-slider" type="range" min="0" max="100" value="0" />

  <!-- Weather controls (Mobile only - shown via CSS) -->
  <div class="weather-mobile-section" id="weather-mobile-section">
    <div class="slider-sep"></div>
    <div class="weather-header-row">
      <span class="weather-section-title" data-i18n="snowAndWeather">❄️ Schnee & Wetter</span>
      <button type="button" class="weather-info-btn" id="weather-info-btn-mobile" data-i18n-title="dataSourceInfo" title="Datenquellen-Info">ℹ️</button>
    </div>
    <div class="weather-toggle-row">
      <span data-i18n="snowDisplay">Schnee-Anzeige</span>
      <label class="weather-toggle-switch">
        <input type="checkbox" id="weather-toggle-mobile" checked>
        <span class="weather-toggle-slider"></span>
      </label>
    </div>
    <div class="weather-last-update" id="weather-last-update-mobile"></div>
    <!-- Cumulative Toggle (Mobile) -->
    <div class="cumulative-toggle-row">
      <span class="cumulative-label" data-i18n="mode">Modus:</span>
      <button class="cumulative-btn" data-cumulative="false" data-i18n-title="onlyThisDay" data-i18n="day" title="Nur dieser Tag">Tag</button>
      <button class="cumulative-btn active" data-cumulative="true" data-i18n-title="sumUntilThisDay" data-i18n="sumUntil" title="Summe bis zu diesem Tag">Σ bis</button>
    </div>
    <!-- Day Buttons (Mobile - simplified) -->
    <div class="timeframe-row day-row">
      <button class="timeframe-btn day-btn" data-day="0" data-i18n="todayShort">Heu</button>
      <button class="timeframe-btn day-btn" data-day="1">+1</button>
      <button class="timeframe-btn day-btn" data-day="3">+3</button>
      <button class="timeframe-btn day-btn active" data-day="7">+7</button>
    </div>
    <div class="filter-slider-row">
      <label for="snow-min-slider-mobile" data-i18n="snowForecast">Schnee-Vorhersage</label>
      <span id="snow-min-label-mobile" class="filter-value">≥0 cm</span>
    </div>
    <input type="range" id="snow-min-slider-mobile" min="0" max="100" value="0" step="5">
    <div class="legend" style="margin-top:8px;">
      <div class="legend-title" data-i18n="legendSnowForecast">Legende (Neuschnee-Prognose)</div>
      <div class="legend-row">
        <span class="legend-item"><span class="legend-dot" style="background:#FFFF00"></span>10-20</span>
        <span class="legend-item"><span class="legend-dot" style="background:#00CED1"></span>20-40</span>
        <span class="legend-item"><span class="legend-dot" style="background:#0000CD"></span>40-70</span>
        <span class="legend-item"><span class="legend-dot" style="background:#FF8C00"></span>70+</span>
      </div>
    </div>
  </div>
  </div><!-- /.slider-box-content -->
</div>

<!-- Home Selector Host (Placeholder für HomeRoutesSelector; Dropdown sitzt im Slider) -->
<div id="homeSelectorBox" class="filter-box leaflet-control" style="display:none;"></div>

<!-- Wetter-Filter Box (rechte Seite) -->
<div class="weather-box" id="weather-box">
  <button type="button" id="weather-box-toggle" class="weather-box-toggle" data-i18n-aria="weatherToggle" aria-label="Wetter ein-/ausklappen" aria-expanded="true">
    <span class="toggle-title" data-i18n="snowAndWeather">❄️ Schnee & Wetter</span>
    <span class="toggle-icon">▼</span>
  </button>
  <div class="weather-box-content">
    <div class="weather-toggle-row">
      <span data-i18n="snowDisplay">Schnee-Anzeige</span>
      <label class="weather-toggle-switch">
        <input type="checkbox" id="weather-toggle" checked>
        <span class="weather-toggle-slider"></span>
      </label>
    </div>
    <div class="weather-last-update" id="weather-last-update"></div>

    <!-- Cumulative Toggle -->
    <div class="cumulative-toggle-row">
      <span class="cumulative-label" data-i18n="mode">Modus:</span>
      <button class="cumulative-btn" data-cumulative="false" data-i18n-title="onlyThisDay" data-i18n="day" title="Nur dieser Tag">Tag</button>
      <button class="cumulative-btn active" data-cumulative="true" data-i18n-title="sumUntilThisDay" data-i18n="sumUntil" title="Summe bis zu diesem Tag">Σ bis</button>
    </div>

    <!-- Day Buttons Row 1 (0-7) -->
    <div class="timeframe-row day-row" id="timeframe-daily">
      <button class="timeframe-btn day-btn" data-day="0" data-i18n="todayShort">Heu</button>
      <button class="timeframe-btn day-btn" data-day="1">+1</button>
      <button class="timeframe-btn day-btn" data-day="2">+2</button>
      <button class="timeframe-btn day-btn" data-day="3">+3</button>
      <button class="timeframe-btn day-btn" data-day="4">+4</button>
      <button class="timeframe-btn day-btn" data-day="5">+5</button>
      <button class="timeframe-btn day-btn" data-day="6">+6</button>
      <button class="timeframe-btn day-btn active" data-day="7">+7</button>
    </div>
    <!-- Day Buttons Row 2 (8-15) -->
    <div class="timeframe-row day-row" id="timeframe-daily-2">
      <button class="timeframe-btn day-btn" data-day="8">+8</button>
      <button class="timeframe-btn day-btn" data-day="9">+9</button>
      <button class="timeframe-btn day-btn" data-day="10">+10</button>
      <button class="timeframe-btn day-btn" data-day="11">+11</button>
      <button class="timeframe-btn day-btn" data-day="12">+12</button>
      <button class="timeframe-btn day-btn" data-day="13">+13</button>
      <button class="timeframe-btn day-btn" data-day="14">+14</button>
      <button class="timeframe-btn day-btn" data-day="15">+15</button>
    </div>

    <div class="filter-row">
      <label for="snow-min-slider">
        <span data-i18n="snowForecast">Schnee-Vorhersage</span>
        <span id="snow-min-label">≥0 cm</span>
      </label>
      <input type="range" id="snow-min-slider" min="0" max="100" value="0" step="5">
    </div>

    <div class="legend">
      <div class="legend-title">
        <span id="legend-timeframe-label" data-i18n="legendSnowForecast">Legende (Σ bis +7 Tage)</span>
        <button type="button" class="weather-info-btn" id="weather-info-btn" data-i18n-title="dataSourceInfo" title="Datenquellen-Info">ℹ️</button>
      </div>
      <div class="legend-row">
        <span class="legend-item"><span class="legend-dot" style="background:#FFFF00"></span>10-20</span>
        <span class="legend-item"><span class="legend-dot" style="background:#00CED1"></span>20-40</span>
        <span class="legend-item"><span class="legend-dot" style="background:#0000CD"></span>40-70</span>
        <span class="legend-item"><span class="legend-dot" style="background:#FF8C00"></span>70+</span>
      </div>
    </div>
  </div>
</div>

<!-- isochroneControl -->
<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>


<!-- Config muss zuerst laden (zentrale Defaults) -->
<script src="js/config.js"></script>

<!-- i18n (Internationalization) - nutzt Config für Default-Sprache -->
<script src="js/i18n.js"></script>
<script src="js/favorites.js"></script>

<script src="js/searchFilter.js"></script>


<script src="js/treeRoutesOverlay.js"></script>
<script src="js/corridorOverlay.js"></script>
<script src="js/homeRoutesSelector.js"></script>
<script src="js/homeTravelTimes.js"></script>


<script src="js/gpsControl.js"></script>
<script src="js/snowBadgeCanvas.js"></script>
<script src="js/verbundMarkerCanvas.js"></script>
<script src="js/glacierIconCache.js"></script>
<script>
  // --------- Basis-Einstellungen ---------
  // ORS_API_KEY wird aus config.js gelesen (nicht in Git einchecken).
  const ORS_API_KEY = (window.APP_CONFIG && window.APP_CONFIG.ORS_API_KEY) ? window.APP_CONFIG.ORS_API_KEY : "DEIN_ORS_API_KEY";

  const MUC_LAT = 48.137;
  const MUC_LON = 11.575;
  const AVG_SPEED_KMH = 70.0;
  
  function getResortNameFromInput(raw) {
    if (!raw) return '';
    const parts = raw.split(/\s[–-]\s/);
    return parts[0].trim();
  }

  function toRad(x) {
    return x * Math.PI / 180;
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371.0;
    const phi1 = toRad(lat1);
    const phi2 = toRad(lat2);
    const dphi = toRad(lat2 - lat1);
    const dlambda = toRad(lon2 - lon1);
    const a = Math.sin(dphi / 2) ** 2 +
              Math.cos(phi1) * Math.cos(phi2) * Math.sin(dlambda / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  
  function buildDriveText(r) {
    const t = window.i18n ? window.i18n.t : (k) => k;
    const approx = t('approxShort');
    let distTxt = "";
    if (r.distKm != null && isFinite(r.distKm)) {
      distTxt = `${Math.round(r.distKm)} km`;
    }
    let timeTxt = "";
    if (r.travelHours != null && isFinite(r.travelHours)) {
      timeTxt = fmtTime(r.travelHours);
    }

    if (distTxt && timeTxt) return `${distTxt} · ${approx} ${timeTxt}`;
    if (distTxt)           return distTxt;
    if (timeTxt)           return `${approx} ${timeTxt}`;
    return t('noData');
  }

  function makePopupHtml(r) {
    const t = window.i18n ? window.i18n.t : (k) => k;

    // Pässe-Sektion als Akkordion
    let passesSection = '';
    if (r.passes && r.passes.length > 0) {
      const passCount = r.passes.length;
      const passBadges = r.passes.map(p => {
        const badgeColor = p.type === 'season' ? '#10b981' :
                          p.type === 'verbund' ? '#8b5cf6' : '#6b7280';
        return `<span class="pass-badge" style="
          display: inline-block;
          background: ${badgeColor};
          color: white;
          padding: 2px 8px;
          border-radius: 4px;
          font-size: 11px;
          margin: 2px 4px 2px 0;
        ">${p.name}</span>`;
      }).join('');

      passesSection = `
        <details class="forecast-details">
          <summary>${t('passes')} (${passCount})</summary>
          <div class="passes-list" style="padding: 6px 0;">
            ${passBadges}
          </div>
        </details>
      `;
    } else {
      passesSection = `<div style="color:#9ca3af;font-size:12px;margin:4px 0;">${t('noPasses')}</div>`;
    }

    const driveTxt = buildDriveText(r);
    const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;

    // Pisten-Info (Bergfex System: blau, rot, schwarz)
    let pistesLine = "";
    if (r.pistesKm) {
      let breakdown = [];
      if (r.pistesBlueKm) breakdown.push(`<span style="color:#3b82f6">${r.pistesBlueKm} km</span>`);
      if (r.pistesRedKm) breakdown.push(`<span style="color:#ef4444">${r.pistesRedKm} km</span>`);
      if (r.pistesBlackKm) breakdown.push(`<span style="color:#1f2937">${r.pistesBlackKm} km</span>`);
      const breakdownStr = breakdown.length ? ` (${breakdown.join(" / ")})` : "";
      pistesLine = `<b>${t('pistes')}:</b> ${r.pistesKm} km${breakdownStr}<br/>`;
    }

    // Lifte-Info
    let liftsLine = "";
    if (r.liftsTotal) {
      let liftDetails = [];
      if (r.liftsGondola) liftDetails.push(`${r.liftsGondola} ${t('gondolas')}`);
      if (r.liftsChairlift) liftDetails.push(`${r.liftsChairlift} ${t('chairlifts')}`);
      if (r.liftsDraglift) liftDetails.push(`${r.liftsDraglift} ${t('draglifts')}`);
      const detailStr = liftDetails.length ? ` (${liftDetails.join(", ")})` : "";
      liftsLine = `<b>${t('lifts')}:</b> ${r.liftsTotal}${detailStr}<br/>`;
    }

    // Höhe
    let elevationLine = "";
    if (r.minElevation || r.maxElevation) {
      const min = r.minElevation ? `${r.minElevation}m` : "?";
      const max = r.maxElevation ? `${r.maxElevation}m` : "?";
      elevationLine = `<b>${t('elevation')}:</b> ${min} - ${max}<br/>`;
    }

    // Schneefallgrenze (separate Zeile unter Höhe)
    let snowLimitLine = '';
    const gsForecastForElev = r.stable_id ? snowForecasts[r.stable_id] : null;
    if (gsForecastForElev?.forecasts?.length > 0) {
      // Ersten nicht-null snowlmt-Wert finden (aktuelle Schneefallgrenze)
      for (const fc of gsForecastForElev.forecasts.slice(0, 6)) {
        if (fc.snow_limit_m != null) {
          const snowLimit = fc.snow_limit_m;
          // Farbcodierung: grün wenn unter Talhöhe, orange wenn zwischen, rot wenn über Berghöhe
          let limitColor = '#10b981'; // grün - Schnee überall
          let limitText = t('snowEverywhere') || 'Schnee überall';
          if (r.maxElevation && snowLimit > r.maxElevation) {
            limitColor = '#ef4444'; // rot - kein Schnee
            limitText = t('noSnow') || 'Kein Schnee';
          } else if (r.minElevation && snowLimit > r.minElevation) {
            limitColor = '#f59e0b'; // orange - nur am Berg Schnee
            limitText = t('snowOnlyTop') || 'Nur am Berg';
          }
          snowLimitLine = `<b>${t('snowLimit')}:</b> <span style="color:${limitColor}">${snowLimit}m (${limitText})</span><br/>`;
          break;
        }
      }
    }

    // Saison
    let seasonLine = "";
    if (r.seasonStart || r.seasonEnd) {
      const locale = window.i18n && window.i18n.getLang() === 'en' ? 'en-GB' : 'de-DE';
      const formatDate = (d) => d ? new Date(d).toLocaleDateString(locale, {day: '2-digit', month: '2-digit'}) : "?";
      seasonLine = `<b>${t('season')}:</b> ${formatDate(r.seasonStart)} - ${formatDate(r.seasonEnd)}<br/>`;
    }

    // Betriebszeiten
    let hoursLine = "";
    if (r.operatingHours) {
      hoursLine = `<b>${t('operation')}:</b> ${r.operatingHours.replace('-', ' - ')}<br/>`;
    }

    // Website
    let websiteLine = "";
    if (r.website) {
      const url = r.website.startsWith("http") ? r.website : "https://" + r.website;
      const label = url.replace(/^https?:\/\/(www\.)?/, "").replace(/\/$/, "");
      websiteLine = `<b>${t('website')}:</b> <a href="${url}" target="_blank" rel="noopener">${label}</a><br/>`;
    }

    // Links zusammenfassen
    let linksLine = "";
    const links = [];
    links.push(`<a href="${mapsUrl}" target="_blank" rel="noopener">Google Maps</a>`);

    // Bergfex / Skiresort.info Links
    const dataLinks = [];
    if (r.bergfexUrl) dataLinks.push(`<a href="${r.bergfexUrl}" target="_blank" rel="noopener" style="color:#f97316">Bergfex</a>`);
    if (r.skiresortUrl) dataLinks.push(`<a href="${r.skiresortUrl}" target="_blank" rel="noopener" style="color:#2563eb">Skiresort.info</a>`);
    if (dataLinks.length > 0) {
      links.push(`🔗 ${dataLinks.join(' | ')}`);
    }
    linksLine = links.join(" · ");

    // Schneevorhersage mit GeoSphere (48h) und Open-Meteo (16 Tage)
    let snowSection = "";
    if (r.stable_id) {
      const omForecast = openMeteoForecasts[r.stable_id];
      const gsForecast = snowForecasts[r.stable_id];

      // GeoSphere 48h-Prognose (stündlich, in 6h-Blöcken)
      // Nach Fix: GeoSphere liefert jetzt echte stündliche Werte (Differenz aus snow_acc)
      let geosphereSection = '';
      if (gsForecast && gsForecast.forecasts && gsForecast.forecasts.length > 0) {
        const hourly = gsForecast.forecasts.slice(0, 48);

        // Summiere stündliche Schneewerte
        const sumSnow = (forecasts) => {
          return forecasts.reduce((sum, h) => sum + (h.snowfall_cm || 0), 0);
        };
        const snow24h = sumSnow(hourly.slice(0, 24));
        const snow48h = sumSnow(hourly);

        // In 6-Stunden-Blöcke gruppieren für die Tabelle
        const blocks = [];
        for (let i = 0; i < hourly.length; i += 6) {
          const blockData = hourly.slice(i, i + 6);
          // Summiere Schnee im 6h-Block
          const blockSnow = sumSnow(blockData);
          // GeoSphere uses temp_2m field
          const blockTemps = blockData.filter(h => h.temp_2m != null).map(h => h.temp_2m);
          const avgTemp = blockTemps.length ? Math.round(blockTemps.reduce((a,b) => a+b, 0) / blockTemps.length) : null;

          // Zeitlabel aus erstem Eintrag (GeoSphere uses 'timestamp' field)
          const firstHour = blockData[0];
          let timeLabel = '';
          if (firstHour && firstHour.timestamp) {
            const date = new Date(firstHour.timestamp);
            const dayNames = (window.i18n ? window.i18n.t('dayNames') : 'So,Mo,Di,Mi,Do,Fr,Sa').split(',');
            timeLabel = `${dayNames[date.getDay()]} ${date.getHours()}h`;
          } else {
            timeLabel = `+${i}h`;
          }

          blocks.push({ timeLabel, snow: blockSnow, temp: avgTemp });
        }

        let gsTableRows = '';
        blocks.forEach((block, idx) => {
          const snowStr = block.snow > 0 ? `<b style="color:#3b82f6">${Math.round(block.snow * 10) / 10}cm</b>` : '-';
          const tempStr = block.temp != null ? `${block.temp}°` : '-';
          const rowClass = idx % 2 === 0 ? 'even' : 'odd';
          gsTableRows += `<tr class="${rowClass}"><td>${block.timeLabel}</td><td>${snowStr}</td><td>${tempStr}</td></tr>`;
        });

        const gs24hStr = snow24h > 0 ? `<b style="color:#3b82f6">${Math.round(snow24h)}cm</b>` : '0cm';
        const gs48hStr = snow48h > 0 ? `<b style="color:#3b82f6">${Math.round(snow48h)}cm</b>` : '0cm';

        geosphereSection = `
          <details class="forecast-details">
            <summary>${t('forecast48h')} (${gs24hStr} 24h · ${gs48hStr} 48h)</summary>
            <div class="geosphere-note">GeoSphere Austria · ${t('hourly')}</div>
            <table class="forecast-table forecast-table-compact">
              <thead><tr><th>${t('time')}</th><th>${t('snow')}</th><th>${t('temp')}</th></tr></thead>
              <tbody>${gsTableRows}</tbody>
            </table>
          </details>
        `;
      }

      // Open-Meteo 16-Tage-Tabelle (mit Berg/Tal-Toggle)
      let omSection = '';

      // Neues Format: mountain/valley Objekte
      const hasMountainValley = omForecast && (omForecast.mountain || omForecast.valley);
      // Altes Format: direkt daily Array
      const hasOldFormat = omForecast && omForecast.daily && omForecast.daily.length > 0;

      if (hasMountainValley || hasOldFormat) {
        // Generiere Tabelle für eine Location
        const generateTableRows = (daily) => {
          if (!daily || daily.length === 0) return '';
          let rows = '';
          daily.slice(0, 16).forEach((day, idx) => {
            const date = formatShortDate(day.date);
            const icon = getWeatherIcon(day.weathercode);
            const snowCm = day.snowfall_cm || 0;
            const snowStr = snowCm > 0 ? `<b style="color:#3b82f6">${Math.round(snowCm)}cm</b>` : '-';
            const tempMin = day.temp_min != null ? Math.round(day.temp_min) : '?';
            const tempMax = day.temp_max != null ? Math.round(day.temp_max) : '?';
            const rowClass = idx % 2 === 0 ? 'even' : 'odd';
            rows += `<tr class="${rowClass}"><td>${date}</td><td>${icon}</td><td>${snowStr}</td><td>${tempMin}° / ${tempMax}°</td></tr>`;
          });
          return rows;
        };

        let toggleHtml = '';
        let mountainTable = '';
        let valleyTable = '';
        let elevationInfo = '';
        const stableIdForToggle = r.stable_id || '';

        if (hasMountainValley) {
          // Neues Format mit Berg/Tal
          const mountainDaily = omForecast.mountain?.daily || [];
          const valleyDaily = omForecast.valley?.daily || [];
          const mountainElev = omForecast.mountain?.elevation_m;
          const valleyElev = omForecast.valley?.elevation_m;

          mountainTable = generateTableRows(mountainDaily);
          valleyTable = generateTableRows(valleyDaily);

          // Toggle-Buttons für Berg/Tal
          toggleHtml = `
            <div class="popup-location-toggle" style="display:flex;gap:4px;margin-bottom:4px;">
              <button class="popup-loc-btn active" data-loc="mountain" data-stable-id="${stableIdForToggle}" style="font-size:10px;padding:2px 6px;border:1px solid #d1d5db;border-radius:3px;background:#10b981;color:white;cursor:pointer;">
                ${t('mountain')}${mountainElev ? ' (' + mountainElev + 'm)' : ''}
              </button>
              <button class="popup-loc-btn" data-loc="valley" data-stable-id="${stableIdForToggle}" style="font-size:10px;padding:2px 6px;border:1px solid #d1d5db;border-radius:3px;background:#f5f5f5;cursor:pointer;">
                ${t('valley')}${valleyElev ? ' (' + valleyElev + 'm)' : ''}
              </button>
            </div>
          `;

          elevationInfo = mountainElev ? ` (${mountainElev}m)` : '';
        } else {
          // Altes Format - nur eine Tabelle
          mountainTable = generateTableRows(omForecast.daily);
        }

        omSection = `
          <details class="forecast-details">
            <summary>${t('forecast16d')}</summary>
            <div class="geosphere-note">Open-Meteo · ${t('daily')}</div>
            ${toggleHtml}
            <table class="forecast-table popup-forecast-mountain" data-stable-id="${stableIdForToggle}" style="${hasMountainValley ? '' : ''}">
              <thead><tr><th>${t('day')}</th><th></th><th>${t('snow')}</th><th>${t('temp')}</th></tr></thead>
              <tbody>${mountainTable}</tbody>
            </table>
            ${hasMountainValley ? `
            <table class="forecast-table popup-forecast-valley" data-stable-id="${stableIdForToggle}" style="display:none;">
              <thead><tr><th>${t('day')}</th><th></th><th>${t('snow')}</th><th>${t('temp')}</th></tr></thead>
              <tbody>${valleyTable}</tbody>
            </table>
            ` : ''}
          </details>
        `;
      }

      if (geosphereSection || omSection) {
        snowSection = `
          <div class="snow-forecast-section">
            ${geosphereSection}
            ${omSection}
          </div>
        `;
      }
    }

    // Access Points / Einstiege mit Parkplatz-Suche
    let accessPointsSection = "";
    if (r.accessPoints && r.accessPoints.length > 0) {
      const apList = r.accessPoints.map(ap => {
        // Google Maps Link mit Koordinaten
        const parkingSearchUrl = `https://www.google.com/maps?q=${ap.lat},${ap.lon}`;
        const elevStr = ap.elevation ? ` (${ap.elevation}m)` : '';
        return `<a href="${parkingSearchUrl}" target="_blank" rel="noopener" class="access-point-link" title="${t('searchParking', {name: ap.name})}">🅿️ ${ap.name}${elevStr}</a>`;
      }).join(', ');

      const showOnMapBtn = r.accessPoints.length > 1
        ? `<button class="show-access-points-btn" data-resort-id="${r.stable_id}" title="${t('showAccessPoints')}">📍</button>`
        : '';

      accessPointsSection = `
        <div class="access-points-section">
          <b>${t('accessPoints')}:</b> ${showOnMapBtn}<br/>
          <span class="access-points-list">${apList}</span>
        </div>
      `;
    }

    // Favoriten-Stern
    const stableId = r.stable_id || null;
    const isFav = stableId && window.Favorites && window.Favorites.isFavorite(stableId);
    const favStar = stableId
      ? `<span class="fav-star${isFav ? ' active' : ''}" data-stable-id="${stableId}" title="${isFav ? t('removeFromFavorites') : t('addToFavorites')}">${isFav ? '★' : '☆'}</span>`
      : '';

    // Besucht-Toggle
    const isVis = stableId && window.Visited && window.Visited.isVisited(stableId);
    const visitedCheck = stableId
      ? `<span class="visited-check${isVis ? ' active' : ''}" data-stable-id="${stableId}" title="${isVis ? t('markAsNotVisited') : t('markAsVisited')}">${isVis ? '✓' : '○'}</span>`
      : '';

    // Gletscher-Badge
    const glacierBadge = r.glacier
      ? `<span class="glacier-badge" title="${t('glacierResort')}">${t('glacier')}</span>`
      : '';

    // Verbund-Badge (wenn Resort zu einem sichtbaren Verbund gehört)
    let verbundBadge = '';
    if (r.verbund && r.verbund.name) {
      verbundBadge = `<a href="#" class="verbund-link" data-verbund-id="${r.verbund.stable_id}" style="
        display: inline-block;
        background: linear-gradient(135deg, #8B5CF6, #6366F1);
        color: white;
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 0.7em;
        font-weight: bold;
        text-decoration: none;
        margin-left: 6px;
        vertical-align: middle;
      " title="Teil von ${r.verbund.name}">${r.verbund.name}</a>`;
    }

    return `
      <div style="font-size:13px; line-height:1.5">
        <b style="font-size:14px">${r.name}</b>${glacierBadge}${verbundBadge}${favStar}${visitedCheck}<br/>
        ${pistesLine}
        ${liftsLine}
        ${elevationLine}
        ${snowLimitLine}
        ${seasonLine}
        ${hoursLine}
        ${websiteLine}
        <b>${t('travelTimeLabel')}:</b> ${driveTxt}<br/>
        ${passesSection}
        ${snowSection}
        ${accessPointsSection}
        <div style="margin-top:4px">${linksLine}</div>
      </div>
    `;
  }
  
  function fmtTime(hoursFloat) {
    const totalMin = Math.round(hoursFloat * 60);
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return `${h}h ${m.toString().padStart(2, "0")}m`;
  }

  function norm(name) {
    return name
      .toLowerCase()
      .replace(/–/g, "-")
      .replace(/—/g, "-")
      .replace(/  +/g, " ")
      .trim();
  }

  // Pass-IDs aus der Datenbank
  const PASS_ID_SCT = "snowcard-tirol";
  const PASS_ID_SSC = "superskicard";

  // Hilfsfunktion: Prüft ob ein Resort einen bestimmten Pass hat
  function hasPass(r, passId) {
    if (!r.passes || !Array.isArray(r.passes)) return false;
    return r.passes.some(p => p.stable_id === passId);
  }

  // --------- Grunddaten ---------
  const sctList = [/* nur noch Referenz, echte Daten aus resorts.json */];
  const sscList = [];

  const resorts = {};
  const resortMarkers = {};
  window.__resortsReady = false;
  let minHours = Infinity;
  let maxHours = 0;

  const travelTimeCache = {};
  let originMarker = null;

  // Gesamtzahl der Resorts
  let totalResorts = 0;

  // Schneevorhersage-Daten
  const snowForecasts = {};      // GeoSphere (48h, stündlich, AT/DE/CH/SI)
  const openMeteoForecasts = {}; // Open-Meteo (16 Tage, täglich, alle Länder)
  const forecastMeta = {         // Metadata für Info-Anzeige
    geosphere: { updatedAt: null, count: 0 },
    openmeteo: { updatedAt: null, count: 0 }
  };

  // Hilfsfunktion: Berechnet Schnee-Summen aus Forecast-Daten
  // Nutzt Open-Meteo (7-Tage) primär, GeoSphere (48h) als Ergänzung
  function getSnowSummary(stableId) {
    const omForecast = openMeteoForecasts[stableId];
    const gsForecast = snowForecasts[stableId];

    // Kein Forecast verfügbar
    if (!omForecast && !gsForecast) return null;

    let snow3d = 0, snow7d = 0;
    let minTemp = Infinity;
    let minSnowLimit = Infinity;

    // Open-Meteo: 7-Tage-Prognose (vorberechnet)
    if (omForecast) {
      snow3d = omForecast.snow_3d_cm || 0;
      snow7d = omForecast.snow_7d_cm || 0;
      // Min-Temp aus daily-Daten
      if (omForecast.daily) {
        omForecast.daily.slice(0, 7).forEach(d => {
          if (d.temp_min != null && d.temp_min < minTemp) minTemp = d.temp_min;
        });
      }
    }

    // GeoSphere: Detaillierte Stunden-Daten (falls verfügbar)
    if (gsForecast && gsForecast.forecasts && gsForecast.forecasts.length) {
      gsForecast.forecasts.forEach(f => {
        if (f.snow_limit_m != null && (f.snowfall_cm || 0) > 0 && f.snow_limit_m < minSnowLimit) {
          minSnowLimit = f.snow_limit_m;
        }
        // GeoSphere hat genauere Temp-Daten
        if (f.temp_2m != null && f.temp_2m < minTemp) minTemp = f.temp_2m;
      });
    }

    // Fallback: Wenn nur GeoSphere vorhanden, 48h-Summe berechnen
    if (!omForecast && gsForecast && gsForecast.forecasts) {
      let snow48h = 0;
      gsForecast.forecasts.slice(0, 48).forEach(f => {
        snow48h += f.snowfall_cm || 0;
      });
      snow3d = snow48h; // 48h ≈ 2 Tage, als 3d-Näherung
      snow7d = snow48h; // Keine 7d-Daten verfügbar
    }

    // Glow-Level basierend auf 7-Tage-Schnee
    const level = snow7d >= 80 ? 'heavy' : snow7d >= 30 ? 'moderate' : snow7d >= 10 ? 'light' : 'none';

    return {
      snow3d: Math.round(snow3d * 10) / 10,
      snow7d: Math.round(snow7d * 10) / 10,
      minTemp: minTemp === Infinity ? null : Math.round(minTemp),
      snowLimit: minSnowLimit === Infinity ? null : Math.round(minSnowLimit),
      level,
      hasOpenMeteo: !!omForecast,
      hasGeoSphere: !!(gsForecast && gsForecast.forecasts && gsForecast.forecasts.length)
    };
  }

  // Bergfex-Farbskala für Schnee (cm -> Farbe)
  function getBergfexSnowColor(cm) {
    if (cm >= 90) return '#FF4500';  // Rot-Orange
    if (cm >= 70) return '#FF8C00';  // Orange
    if (cm >= 50) return '#9932CC';  // Lila
    if (cm >= 40) return '#0000CD';  // Dunkelblau
    if (cm >= 30) return '#1E90FF';  // Blau
    if (cm >= 20) return '#00CED1';  // Cyan
    if (cm >= 15) return '#00FFFF';  // Hellcyan
    if (cm >= 10) return '#FFFF00';  // Gelb
    if (cm >= 5)  return '#ADFF2F';  // Gelbgrün
    return '#98FB98';                 // Hellgrün
  }

  // Badge-Größe basierend auf Schneemenge
  function getSnowBadgeSize(cm) {
    if (cm >= 50) return 'large';
    if (cm >= 20) return 'medium';
    return 'small';
  }

  // Snow Badge Marker speichern
  const snowBadgeMarkers = {};

  // Lädt Schneevorhersagen und erstellt Badges
  function loadSnowForecasts() {
    // Open-Meteo laden (16 Tage, alle Länder)
    const omPromise = fetch("data/forecasts/openmeteo_forecast.json")
      .then(resp => {
        if (!resp.ok) throw new Error("Open-Meteo not available");
        return resp.json();
      })
      .then(data => {
        if (data.forecasts) {
          Object.assign(openMeteoForecasts, data.forecasts);
          forecastMeta.openmeteo.count = Object.keys(data.forecasts).length;
          forecastMeta.openmeteo.updatedAt = data.generated_at ? new Date(data.generated_at) : null;
          console.log(`Loaded Open-Meteo forecasts for ${forecastMeta.openmeteo.count} resorts`);
        }
      })
      .catch(err => console.log("Open-Meteo forecast not loaded:", err.message));

    // GeoSphere laden (48h, stündlich - für detaillierte Popup-Info)
    const gsPromise = fetch("data/forecasts/current_forecast.json")
      .then(resp => {
        if (!resp.ok) throw new Error("GeoSphere not available");
        return resp.json();
      })
      .then(data => {
        if (data.forecasts) {
          Object.assign(snowForecasts, data.forecasts);
          forecastMeta.geosphere.count = Object.keys(data.forecasts).length;
          forecastMeta.geosphere.updatedAt = data.generated_at ? new Date(data.generated_at) : null;
          console.log(`Loaded GeoSphere forecasts for ${forecastMeta.geosphere.count} resorts`);
        }
      })
      .catch(err => console.log("GeoSphere forecast not loaded:", err.message));

    // Warte auf beide - dann Badges anzeigen wenn enabled
    Promise.all([omPromise, gsPromise]).then(() => {
      console.log('Snow forecast data ready for weather filter');
      updateWeatherLastUpdate();
      updateDayButtonSnowDots();
      // Show badges if weather display is enabled by default
      if (window.weatherFilterState && window.weatherFilterState.enabled) {
        if (typeof updateWeatherDisplay === 'function') {
          updateWeatherDisplay();
        }
      }
    });
  }

  // Update "Last update" display in weather box
  function updateWeatherLastUpdate() {
    const t = window.i18n ? window.i18n.t : (k) => k;
    const updatedAt = forecastMeta.openmeteo.updatedAt;
    if (!updatedAt) return;

    const now = new Date();
    const diffMs = now - updatedAt;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);

    let relativeTime;
    if (diffMins < 1) {
      relativeTime = t('justNow') || 'gerade eben';
    } else if (diffMins < 60) {
      relativeTime = `${diffMins} min`;
    } else if (diffHours < 24) {
      relativeTime = `${diffHours}h`;
    } else {
      const days = Math.floor(diffHours / 24);
      relativeTime = `${days}d`;
    }

    // Format time as HH:MM
    const lang = window.i18n ? window.i18n.getLang() : 'de';
    const timeStr = updatedAt.toLocaleTimeString(lang === 'de' ? 'de-DE' : 'en-GB', {
      hour: '2-digit',
      minute: '2-digit'
    });

    const text = `${t('lastUpdate') || 'Last update'}: ${timeStr} (${relativeTime})`;

    const el = document.getElementById('weather-last-update');
    const elMobile = document.getElementById('weather-last-update-mobile');
    if (el) el.textContent = text;
    if (elMobile) elMobile.textContent = text;
  }

  // Update snow indicator dots on day buttons (works in both Tag and Σ bis modes)
  function updateDayButtonSnowDots() {
    // Get all day buttons (desktop only for now)
    const dayBtns = document.querySelectorAll('.weather-box .day-btn');

    dayBtns.forEach(btn => {
      const dayIndex = parseInt(btn.dataset.day);

      // Create dot element if it doesn't exist
      let dot = btn.querySelector('.snow-dot');
      if (!dot) {
        dot = document.createElement('span');
        dot.className = 'snow-dot';
        btn.appendChild(dot);
      }

      // Show dots in both modes (Tag and Σ bis)
      // Find maximum snow anywhere in the Alps for this day
      let maxSnow = 0;

      Object.keys(openMeteoForecasts).forEach(stableId => {
        const snow = getSnowForDay(stableId, dayIndex, 'mountain');
        if (snow > maxSnow) {
          maxSnow = snow;
        }
      });

      // Show dot if significant snow (>10cm) falls ANYWHERE in the Alps
      // Color = maximum (shows "best" spot that day)
      if (maxSnow >= 10) {
        dot.style.backgroundColor = getBergfexSnowColor(maxSnow);
        dot.classList.add('visible');
      } else {
        dot.classList.remove('visible');
      }
    });
  }

  // Erstellt Snow-Badges für Resorts mit Neuschnee
  function createSnowBadges() {
    // Entferne alte Badges
    Object.values(snowBadgeMarkers).forEach(m => map.removeLayer(m));
    Object.keys(snowBadgeMarkers).forEach(k => delete snowBadgeMarkers[k]);

    let badgeCount = 0;
    Object.values(resorts).forEach(r => {
      if (!r.stable_id || !r.lat || !r.lon) return;
      const summary = getSnowSummary(r.stable_id);
      if (!summary || summary.snow7d < 10) return; // Nur ab 10cm anzeigen

      const snow = Math.round(summary.snow7d);
      const color = getBergfexSnowColor(snow);
      const size = getSnowBadgeSize(snow);

      // Badge als DivIcon erstellen
      const badgeHtml = `<div class="snow-badge snow-badge-${size}" style="background:${color}">❄</div>`;
      const icon = L.divIcon({
        html: badgeHtml,
        className: 'snow-badge-wrapper',
        iconSize: [size === 'large' ? 22 : size === 'medium' ? 18 : 14, size === 'large' ? 22 : size === 'medium' ? 18 : 14],
        iconAnchor: [-4, size === 'large' ? 22 : size === 'medium' ? 18 : 14] // Rechts oben vom Marker
      });

      const badge = L.marker([r.lat, r.lon], {
        icon,
        interactive: false,
        pane: 'markerPane'
      }).addTo(map);

      snowBadgeMarkers[r.stable_id] = badge;
      badgeCount++;
    });

    console.log(`Created ${badgeCount} snow badges`);
  }

  // Karte - zentriert über den Alpen, alle Skigebiete sichtbar
  const CFG = window.APP_CONFIG;
  const map = L.map("map").setView(CFG.map.center, CFG.map.zoomDesktop);
  // Debug/DevTools access
  window.map = map;

  // Snow Badge Canvas Layer initialisieren (Performance-Optimierung)
  if (window.SnowBadgeCanvas) {
    window.SnowBadgeCanvas.init(map);
  }

  // Verbund Icon Cache vorwärmen (Performance-Optimierung)
  if (window.VerbundIconCache) {
    window.VerbundIconCache.warmCache();
  }

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap-Mitwirkende"
  });
  osm.addTo(map);

  // Satellit (Esri World Imagery)
  const satellite = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
    maxZoom: 19,
    attribution: "Tiles &copy; Esri"
  });

  // Clean/Minimal (Stadia Alidade Smooth)
  const clean = L.tileLayer("https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.png", {
    maxZoom: 20,
    attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>'
  });

  // Terrain (Stadia Stamen Terrain)
  const terrain = L.tileLayer("https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}{r}.png", {
    maxZoom: 18,
    attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://stamen.com/">Stamen Design</a>'
  });

  // Topo (Esri World Topo Map)
  const topo = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}", {
    maxZoom: 19,
    attribution: "Tiles &copy; Esri"
  });

  // Grey/Dezent (TopPlusOpen)
  const grey = L.tileLayer("https://sgx.geodatenzentrum.de/wmts_topplus_open/tile/1.0.0/web_grau/default/WEBMERCATOR/{z}/{y}/{x}.png", {
    maxZoom: 18,
    attribution: '&copy; <a href="https://www.bkg.bund.de">BKG</a>'
  });

  // Hillshade Overlay (ArcGIS) - default an
  const hillshade = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}", {
    maxZoom: 18,
    opacity: 0.3,
    attribution: "Hillshade &copy; Esri"
  });
  hillshade.addTo(map);

  // --------- WaymarkedTrails Slopes Overlay ---------
  // OSM-basiert, zeigt Pisten (farbcodiert), Lifte, Loipen, Rodelbahnen
  // https://waymarkedtrails.org - kostenlos, keine API-Keys nötig
  const slopesLayer = L.tileLayer('https://tile.waymarkedtrails.org/slopes/{z}/{x}/{y}.png', {
    maxZoom: 18,
    opacity: 0.9,
    attribution: 'Slopes © <a href="https://waymarkedtrails.org">Waymarked Trails</a>'
  });

// Ein Layer für alle Resort-Marker (Filter steuern Sichtbarkeit)
  const markerLayer = L.layerGroup().addTo(map);

  // Lookup-Map: stableId -> { marker, resort, isSpecialIcon }
  const resortMarkersByStableId = {};

  // Erstellt Favorit-Stern als Marker-Icon (ersetzt den normalen Marker)
  function createFavoriteMarkerIcon(zoom, color) {
    const size = zoom >= 9 ? 20 : zoom >= 7 ? 16 : 14;
    // Verwende GlacierIconCache für bessere Performance und kein Memory Leak
    if (window.GlacierIconCache) {
      return window.GlacierIconCache.getFavoriteIcon(size);
    }
    // Fallback
    return L.divIcon({
      html: `<div style="width:${size}px;height:${size}px;font-size:${size}px;color:#f59e0b;">★</div>`,
      className: '',
      iconSize: [size, size],
      iconAnchor: [size/2, size/2]
    });
  }

  // Erstellt Besucht-Haken als Marker-Icon (verwendet Cache)
  function createVisitedMarkerIcon(zoom, color) {
    const size = zoom >= 9 ? 20 : zoom >= 7 ? 16 : 14;
    // Verwende GlacierIconCache für bessere Performance und kein Memory Leak
    if (window.GlacierIconCache) {
      return window.GlacierIconCache.getVisitedIcon(size);
    }
    // Fallback
    return L.divIcon({
      html: `<div style="width:${size}px;height:${size}px;background:#16a34a;color:#fff;border-radius:50%;text-align:center;">✓</div>`,
      className: '',
      iconSize: [size, size],
      iconAnchor: [size/2, size/2]
    });
  }

  // Hilfsfunktion: Berechnet Länder-Farbe für ein Resort
  function getCountryColor(resort) {
    const countryCode = (resort.country || "").toUpperCase();
    if (countryCode === "AT") return COLOR_AT;
    if (countryCode === "DE") return COLOR_DE;
    if (countryCode === "CH") return COLOR_CH;
    if (countryCode === "IT") return COLOR_IT;
    if (countryCode === "FR") return COLOR_FR;
    if (countryCode === "SI") return COLOR_SI;
    return COLOR_OTHER;
  }

  // Aktualisiert einen einzelnen Resort-Marker basierend auf Favorit/Besucht-Status
  function updateResortMarker(stableId) {
    if (!window.__resortsReady || !resorts) return;

    const entry = resortMarkersByStableId[stableId];
    if (!entry) return;

    const { marker, resort } = entry;
    const isFav = window.Favorites && window.Favorites.isFavorite(stableId);
    const isVis = window.Visited && window.Visited.isVisited(stableId);
    const currentZoom = map.getZoom();

    // Entferne alten Marker vom Layer
    markerLayer.removeLayer(marker);

    // Memory Leak Fix: Alten Marker komplett aufräumen
    // Aus glacierMarkers Array entfernen
    const glacierIdx = glacierMarkers.findIndex(g => g.marker === marker);
    if (glacierIdx >= 0) glacierMarkers.splice(glacierIdx, 1);
    // Aus circleMarkers Array entfernen
    const circleIdx = circleMarkers.indexOf(marker);
    if (circleIdx >= 0) circleMarkers.splice(circleIdx, 1);
    // Marker komplett zerstören (entfernt Event-Listener und DOM-Elemente)
    if (marker.remove) marker.remove();

    let newMarker;
    const color = getCountryColor(resort);

    // Priorität: Besucht > Favorit > Normal (auch für Gletscher!)
    if (isVis) {
      // Besucht: Grüner Haken (höchste Prio, auch für Gletscher)
      newMarker = L.marker([resort.lat, resort.lon], {
        icon: createVisitedMarkerIcon(currentZoom, color)
      });
      entry.isSpecialIcon = 'visited';
    } else if (isFav && !resort.glacier) {
      // Favorit: Goldener Stern (nur für Nicht-Gletscher)
      newMarker = L.marker([resort.lat, resort.lon], {
        icon: createFavoriteMarkerIcon(currentZoom, color)
      });
      entry.isSpecialIcon = 'favorite';
    } else if (resort.glacier) {
      // Gletscher: Schneeflocken-Icon (Favorit-Status ohne visuelles Icon)
      const iconSize = getGlacierIconSize(currentZoom);
      newMarker = L.marker([resort.lat, resort.lon], {
        icon: createGlacierIcon(color, iconSize)
      });
      entry.isSpecialIcon = isFav ? 'favorite' : null;
      // Gletscher-Marker zum Array hinzufügen für Zoom-Updates
      glacierMarkers.push({ marker: newMarker, color, resortName: resort.name });
    } else {
      // Normal: CircleMarker
      const radius = getMarkerRadius(currentZoom);
      newMarker = L.circleMarker([resort.lat, resort.lon], {
        radius: radius,
        color: color,
        fillColor: color,
        fillOpacity: 0.95,
        weight: 2
      });
      entry.isSpecialIcon = null;
      // CircleMarker zur Liste hinzufügen für Zoom-Updates
      circleMarkers.push(newMarker);
    }

    // Popup und Tooltip übertragen
    newMarker.bindPopup(() => makePopupHtml(resort));
    newMarker.bindTooltip(resort.name);

    // Neuen Marker hinzufügen
    markerLayer.addLayer(newMarker);
    entry.marker = newMarker;
    resortMarkers[norm(resort.name)] = newMarker;
  }

  // Aktualisiert alle Marker mit speziellem Icon (nach Zoom)
  function updateSpecialMarkerIcons() {
    if (!window.__resortsReady) return;

    Object.keys(resortMarkersByStableId).forEach(stableId => {
      const entry = resortMarkersByStableId[stableId];
      if (entry && entry.isSpecialIcon) {
        updateResortMarker(stableId);
      }
    });
  }

  // Event-Listener für Favoriten/Besucht-Änderungen
  window.addEventListener("favorites-changed", (e) => {
    try {
      const stableId = e.detail && e.detail.stableId;
      if (stableId) {
        updateResortMarker(stableId);
      } else {
        // Import: Alle aktualisieren
        Object.keys(resortMarkersByStableId).forEach(id => updateResortMarker(id));
      }
    } catch (err) { console.warn("favorites-changed error:", err); }
  });

  window.addEventListener("visited-changed", (e) => {
    try {
      const stableId = e.detail && e.detail.stableId;
      if (stableId) {
        updateResortMarker(stableId);
      } else {
        // Import: Alle aktualisieren
        Object.keys(resortMarkersByStableId).forEach(id => updateResortMarker(id));
      }
    } catch (err) { console.warn("visited-changed error:", err); }
  });

  // Farben aus zentraler Config
  const COLOR_SCT   = CFG.colors.SCT;
  const COLOR_SSC   = CFG.colors.SSC;
  const COLOR_BOTH  = CFG.colors.BOTH;
  const COLOR_OTHER = CFG.colors.OTHER;
  const COLOR_AT    = CFG.colors.AT;
  const COLOR_DE    = CFG.colors.DE;
  const COLOR_CH    = CFG.colors.CH;
  const COLOR_IT    = CFG.colors.IT;
  const COLOR_FR    = CFG.colors.FR;
  const COLOR_SI    = CFG.colors.SI;

  // --------- Zoom-abhängige Skalierung ---------
  // Arrays zum Speichern der verschiedenen Marker-Typen für Zoom-Updates
  const circleMarkers = [];
  const glacierMarkers = [];

  // Berechnet Marker-Radius basierend auf Zoom-Level
  function getMarkerRadius(zoom) {
    if (zoom >= 9) return 7;
    if (zoom >= 8) return 6;
    if (zoom >= 7) return 5;
    if (zoom >= 6) return 4;
    return 3;
  }

  // Berechnet Gletscher-Icon-Größe basierend auf Zoom-Level
  function getGlacierIconSize(zoom) {
    if (zoom >= 9) return 22;
    if (zoom >= 8) return 18;
    if (zoom >= 7) return 14;
    if (zoom >= 6) return 12;
    return 10;
  }

  // Erstellt Gletscher-Icon mit dynamischer Größe (verwendet Cache)
  function createGlacierIcon(color, size) {
    // Verwende GlacierIconCache für bessere Performance und kein Memory Leak
    if (window.GlacierIconCache) {
      return window.GlacierIconCache.getGlacierIcon(color, size);
    }
    // Fallback für den Fall dass Cache noch nicht geladen
    return L.divIcon({
      html: `<div style="width:${size}px;height:${size}px;border-radius:50%;border:2px solid ${color};background:white;"></div>`,
      className: "",
      iconSize: [size, size],
      iconAnchor: [size/2, size/2],
      popupAnchor: [0, -size/2]
    });
  }

  // Erstellt einfaches Kreis-Icon (verwendet Cache)
  function createCircleIcon(color, size) {
    // Verwende GlacierIconCache für bessere Performance und kein Memory Leak
    if (window.GlacierIconCache) {
      return window.GlacierIconCache.getCircleIcon(color, size);
    }
    // Fallback
    const circleSize = Math.round(size * 0.6);
    return L.divIcon({
      html: `<div style="width:${circleSize}px;height:${circleSize}px;border-radius:50%;background:${color};"></div>`,
      className: "",
      iconSize: [circleSize, circleSize],
      iconAnchor: [circleSize/2, circleSize/2],
      popupAnchor: [0, -circleSize/2]
    });
  }

  // Erstellt Hexagon-Icon für Verbünde (verwendet Cache)
  function createVerbundIcon(size) {
    // Verwende VerbundIconCache für bessere Performance und kein Memory Leak
    if (window.VerbundIconCache) {
      return window.VerbundIconCache.getIcon(size);
    }
    // Fallback
    const hexSize = Math.round(size * 0.85);
    return L.divIcon({
      html: `<div style="width:${hexSize}px;height:${hexSize}px;background:#8B5CF6;border-radius:4px;"></div>`,
      className: "",
      iconSize: [hexSize, hexSize],
      iconAnchor: [hexSize/2, hexSize/2],
      popupAnchor: [0, -hexSize/2]
    });
  }

  // Verbund-Daten und Marker
  let verbuende = {};
  let verbundMarkers = {};
  let verbundConnectionLines = null; // LayerGroup für Verbindungslinien
  let activeVerbund = null; // Aktuell ausgewählter Verbund

  // Lädt Verbünde aus JSON
  function loadVerbuende() {
    return fetch("data/verbuende.json")
      .then(resp => {
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        return resp.json();
      })
      .then(data => {
        if (!data || !Array.isArray(data)) return;
        data.forEach(v => {
          verbuende[v.stable_id] = v;
        });
        console.log(`Loaded ${Object.keys(verbuende).length} Verbünde`);
        buildVerbundMarkers();
      })
      .catch(err => {
        console.warn("Verbünde konnten nicht geladen werden:", err);
      });
  }

  // Erstellt Marker für alle Verbünde (mit gecachten Icons für Performance)
  function buildVerbundMarkers() {
    const zoom = map.getZoom();

    // Verwende gecachte Icons wenn verfügbar (kein Memory Leak)
    const getIcon = window.VerbundIconCache
      ? () => window.VerbundIconCache.getIconForZoom(zoom)
      : () => createVerbundIcon(getGlacierIconSize(zoom));

    Object.values(verbuende).forEach(v => {
      if (!v.lat || !v.lon) return;

      const marker = L.marker([v.lat, v.lon], {
        icon: getIcon(),
        zIndexOffset: 1000
      });

      marker.bindPopup(() => makeVerbundPopupHtml(v));

      marker.on('click', () => {
        showVerbundConnections(v);
      });

      marker.addTo(markerLayer);
      verbundMarkers[v.stable_id] = { marker, verbund: v };
    });

    // LayerGroup für Verbindungslinien erstellen
    if (!verbundConnectionLines) {
      verbundConnectionLines = L.layerGroup().addTo(map);
    }

    console.log(`Built ${Object.keys(verbundMarkers).length} Verbund markers`);

    // Check filter checkbox state and hide if unchecked (default: off)
    const verbundeCheckbox = document.getElementById('flt-verbunde');
    if (verbundeCheckbox && !verbundeCheckbox.checked) {
      setVerbundMarkersVisible(false);
    }
  }

  // Zeigt Verbindungslinien zu Member-Resorts
  function showVerbundConnections(verbund) {
    // Alte Linien entfernen
    if (verbundConnectionLines) {
      verbundConnectionLines.clearLayers();
    }

    // Wenn gleicher Verbund nochmal geklickt → Toggle off
    if (activeVerbund === verbund.stable_id) {
      activeVerbund = null;
      return;
    }

    activeVerbund = verbund.stable_id;

    // Linien zu allen Member-Resorts zeichnen
    if (verbund.members && verbund.members.length > 0) {
      verbund.members.forEach(member => {
        if (!member.lat || !member.lon) return;

        const line = L.polyline(
          [[verbund.lat, verbund.lon], [member.lat, member.lon]],
          {
            color: '#8B5CF6',
            weight: 2,
            opacity: 0.6,
            dashArray: '5, 5'
          }
        );
        verbundConnectionLines.addLayer(line);
      });
    }
  }

  // Erstellt Popup-HTML für Verbünde
  function makeVerbundPopupHtml(v) {
    const t = window.i18n ? window.i18n.t : (k) => k;

    // Stats
    const stats = v.stats || {};
    const resortCount = stats.resortCount || 0;
    const pistesKm = stats.pistesKmTotal || 0;
    const liftsTotal = stats.liftsTotal || 0;
    const maxElevation = stats.maxElevation;

    // Pässe aus allen Member-Resorts aggregieren
    let passesSection = '';
    if (v.members && v.members.length > 0) {
      const passMap = new Map(); // stable_id -> pass object
      v.members.forEach(m => {
        const resort = Object.values(resorts).find(r => r.stable_id === m.stable_id);
        if (resort && resort.passes && resort.passes.length > 0) {
          resort.passes.forEach(p => {
            if (!passMap.has(p.stable_id)) {
              passMap.set(p.stable_id, { ...p, count: 1 });
            } else {
              passMap.get(p.stable_id).count++;
            }
          });
        }
      });

      if (passMap.size > 0) {
        const passBadges = Array.from(passMap.values()).map(p => {
          const badgeColor = p.type === 'season' ? '#10b981' :
                            p.type === 'verbund' ? '#8b5cf6' : '#6b7280';
          const countInfo = p.count > 1 ? ` (${p.count})` : '';
          return `<span class="pass-badge" style="
            display: inline-block;
            background: ${badgeColor};
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 4px 2px 0;
          ">${p.name}${countInfo}</span>`;
        }).join('');

        passesSection = `
          <details class="forecast-details" style="margin-top: 8px;">
            <summary>${t('passes')} (${passMap.size})</summary>
            <div class="passes-list" style="padding: 6px 0;">
              ${passBadges}
            </div>
          </details>
        `;
      }
    }

    // Member-Liste
    let membersList = '';
    if (v.members && v.members.length > 0) {
      const items = v.members.map(m => {
        const isPrimary = m.isPrimary ? ' ⭐' : '';
        return `<li style="margin: 2px 0;">${m.name}${isPrimary}</li>`;
      }).join('');
      membersList = `
        <div style="margin-top: 8px;">
          <b>${t('skiResorts')} (${resortCount}):</b>
          <ul style="margin: 4px 0; padding-left: 20px; max-height: 150px; overflow-y: auto;">
            ${items}
          </ul>
        </div>
      `;
    }

    // Access Points
    let accessPointsSection = '';
    if (v.accessPoints && v.accessPoints.length > 0) {
      const apItems = v.accessPoints.slice(0, 5).map(ap => {
        const mapsUrl = `https://www.google.com/maps?q=${ap.lat},${ap.lon}`;
        return `<a href="${mapsUrl}" target="_blank" style="color:#3b82f6; text-decoration:none;">
          📍 ${ap.resortName || ap.name}
        </a>`;
      }).join('<br/>');
      const moreCount = v.accessPoints.length - 5;
      accessPointsSection = `
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
          <b>${t('accessPoints')}:</b><br/>
          <div style="font-size: 0.9em; margin-top: 4px;">
            ${apItems}
            ${moreCount > 0 ? `<br/><span style="color:#6b7280;">${t('andMore', {count: moreCount})}</span>` : ''}
          </div>
        </div>
      `;
    }

    // Website
    let websiteLine = '';
    if (v.website) {
      const url = v.website.startsWith('http') ? v.website : 'https://' + v.website;
      websiteLine = `<a href="${url}" target="_blank" rel="noopener" style="color:#6366f1;">Website</a>`;
    }

    return `
      <div style="min-width: 250px; max-width: 350px;">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
          <span style="
            background: linear-gradient(135deg, #8B5CF6, #6366F1);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
          ">${t('groupBadge')}</span>
          <b style="font-size: 1.1em;">${v.name}</b>
        </div>
        ${v.description ? `<p style="margin: 4px 0; color: #6b7280; font-size: 0.9em;">${v.description}</p>` : ''}
        <div style="margin: 8px 0;">
          ${pistesKm ? `<b>${t('pistes')}:</b> ${pistesKm} km<br/>` : ''}
          ${liftsTotal ? `<b>${t('lifts')}:</b> ${liftsTotal}<br/>` : ''}
          ${maxElevation ? `<b>${t('maxElevation')}:</b> ${maxElevation}m<br/>` : ''}
        </div>
        ${passesSection}
        ${membersList}
        ${accessPointsSection}
        ${websiteLine ? `<div style="margin-top: 8px;">${websiteLine}</div>` : ''}
      </div>
    `;
  }

  // Aktualisiert Verbund-Marker-Größen bei Zoom
  function updateVerbundMarkerSizes() {
    const zoom = map.getZoom();

    // Verwende gecachte Icons (kein Memory Leak)
    const getIcon = window.VerbundIconCache
      ? () => window.VerbundIconCache.getIconForZoom(zoom)
      : () => createVerbundIcon(getGlacierIconSize(zoom));

    Object.values(verbundMarkers).forEach(({ marker }) => {
      marker.setIcon(getIcon());
    });
  }

  // Zeigt oder versteckt alle Verbund-Marker
  function setVerbundMarkersVisible(visible) {
    Object.values(verbundMarkers).forEach(({ marker }) => {
      if (visible) {
        if (!markerLayer.hasLayer(marker)) {
          marker.addTo(markerLayer);
        }
      } else {
        if (markerLayer.hasLayer(marker)) {
          markerLayer.removeLayer(marker);
        }
      }
    });
    // Verbindungslinien auch ausblenden wenn Marker ausgeblendet
    if (!visible && verbundConnectionLines) {
      verbundConnectionLines.clearLayers();
      activeVerbund = null;
    }
  }

  // Globale Funktion für Filter-Modul
  window.setVerbundMarkersVisible = setVerbundMarkersVisible;

  // Cache für letzte Zoom-Größen (verhindert unnötige DOM-Updates)
  let lastMarkerRadius = null;
  let lastGlacierSize = null;
  let lastCorridorWeightKey = null;

  // Aktualisiert alle Marker-Größen basierend auf dem aktuellen Zoom
  // Optimiert: Nur updaten wenn sich die Größen-Stufe tatsächlich ändert
  function updateMarkerSizes() {
    const zoom = map.getZoom();
    const radius = getMarkerRadius(zoom);
    const iconSize = getGlacierIconSize(zoom);

    // CircleMarker nur updaten wenn Radius sich ändert
    if (radius !== lastMarkerRadius) {
      lastMarkerRadius = radius;
      circleMarkers.forEach(m => {
        m.setRadius(radius);
      });
    }

    // Gletscher-Icons nur updaten wenn Größe sich ändert (teuer: DOM-Neuerstellen)
    if (iconSize !== lastGlacierSize) {
      lastGlacierSize = iconSize;
      glacierMarkers.forEach(({ marker, color }) => {
        marker.setIcon(createGlacierIcon(color, iconSize));
      });
      // Verbund-Marker auch updaten
      updateVerbundMarkerSizes();
    }
  }

  // Berechnet Corridor-Linienbreite basierend auf Zoom-Level
  function getCorridorWeights(zoom) {
    if (zoom >= 9) return { minWeight: 2, maxWeight: 10, key: "z9" };
    if (zoom >= 8) return { minWeight: 1.5, maxWeight: 8, key: "z8" };
    if (zoom >= 7) return { minWeight: 1.2, maxWeight: 6, key: "z7" };
    if (zoom >= 6) return { minWeight: 1, maxWeight: 4, key: "z6" };
    return { minWeight: 0.8, maxWeight: 3, key: "z5" };
  }

  // Aktualisiert Corridor-Linienbreiten basierend auf dem aktuellen Zoom
  // Optimiert: Nur updaten wenn sich die Weight-Stufe tatsächlich ändert
  function updateCorridorWeights() {
    if (!window.corridorOverlay || !window.corridorOverlay.setStyle) return;
    const zoom = map.getZoom();
    const weights = getCorridorWeights(zoom);

    // Nur updaten wenn sich die Stufe ändert
    if (weights.key !== lastCorridorWeightKey) {
      lastCorridorWeightKey = weights.key;
      window.corridorOverlay.setStyle(weights);
    }
  }

  // Counter aktualisieren
  function updateResortCounter() {
    const box = document.getElementById("resort-counter");
    if (!box) return;

    const snowHidden = window.snowHiddenResorts;
    let visible = 0;
    Object.entries(resortMarkers).forEach(([key, marker]) => {
      if (!map.hasLayer(marker)) return;
      // Check snow filter via set (markers hidden via display:none are still in layer)
      const r = resorts[key];
      if (r && snowHidden?.has(r.name)) return;
      visible++;
    });

    box.textContent = `${visible} / ${totalResorts}`;
  }
  function initResortsFromJson(list) {
    list.forEach(r => {
      // Überspringe Resorts ohne gültige Koordinaten
      if (r.lat == null || r.lon == null) return;

      const key = norm(r.name);

      // Resort-Objekt mit allen relevanten Feldern
      resorts[key] = {
        name: r.name,
        stable_id: r.stable_id || null,
        lat: r.lat,
        lon: r.lon,
        country: r.country || null,
        countryName: r.countryName || null,
        region: r.region || null,
        passes: r.passes || [],
        glacier: !!r.glacier,
        website: (typeof r.website === "string" && r.website.trim()) ? r.website.trim() : null,
        liftsTotal: (r.liftsTotal != null) ? Number(r.liftsTotal) : null,
        liftsGondola: (r.liftsGondola != null) ? Number(r.liftsGondola) : null,
        liftsChairlift: (r.liftsChairlift != null) ? Number(r.liftsChairlift) : null,
        liftsDraglift: (r.liftsDraglift != null) ? Number(r.liftsDraglift) : null,
        pistesKm: (r.pistesKm != null) ? Number(r.pistesKm) : null,
        pistesBlueKm: (r.pistesBlueKm != null) ? Number(r.pistesBlueKm) : null,
        pistesRedKm: (r.pistesRedKm != null) ? Number(r.pistesRedKm) : null,
        pistesBlackKm: (r.pistesBlackKm != null) ? Number(r.pistesBlackKm) : null,
        maxElevation: (r.maxElevation != null) ? Number(r.maxElevation) : null,
        minElevation: (r.minElevation != null) ? Number(r.minElevation) : null,
        seasonStart: r.seasonStart || null,
        seasonEnd: r.seasonEnd || null,
        operatingHours: r.operatingHours || null,
        bergfexUrl: r.bergfexUrl || null,
        skiresortUrl: r.skiresortUrl || null,
        // Gruppen für Verbund-Filter (neues DB Schema)
        groups: r.groups || [],
        primaryGroup: r.primaryGroup || null,
        // Einstiegspunkte (Access Points)
        accessPoints: r.accessPoints || [],
        // Live-Daten (optional)
        liveData: r.liveData || null
      };
    });
  }

  // Normalisiert verschiedene Export-Formate auf ein flaches Array
  function normalizeResortData(data) {
    // 1. DBeaver Wrapper: {"v_resort_json_export": [...]}
    if (data && typeof data === "object" && !Array.isArray(data)) {
      const keys = Object.keys(data);
      if (keys.length === 1 && Array.isArray(data[keys[0]])) {
        data = data[keys[0]];
      }
    }

    // 2. Jetzt sollte es ein Array sein
    if (!Array.isArray(data)) {
      throw new Error("Ungültiges Datenformat: Erwartet Array");
    }

    // 3. Wenn Einträge resort_json haben, extrahiere diese
    if (data.length > 0 && data[0].resort_json) {
      return data.map(row => row.resort_json);
    }

    return data;
  }

  function loadResortsAndInit() {
    fetch("data/resorts.json")
      .then(resp => {
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        return resp.json();
      })
      .then(rawData => {
        const list = normalizeResortData(rawData);
        initResortsFromJson(list);

        // Global speichern für Access Points Lookup
        window.__allResorts = Object.values(resorts);

        totalResorts = Object.keys(resorts).length;

        buildMarkers();
        window.__resortsReady = true;

        // Verbünde laden (nach Resort-Markern)
        loadVerbuende();

        // Favorit/Besucht-Marker werden direkt in buildMarkers() initialisiert

        // Schneevorhersagen laden (nach Markern, damit Glow angewendet werden kann)
        loadSnowForecasts();

        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.onResortsReady === "function") {
          try { window.HomeTravelTimes.onResortsReady(); } catch (e) { console.warn(e); }
        }
if (typeof rebuildDatalist === "function") {
          rebuildDatalist();
        }
        // Neue Filter-Slider initialisieren
        if (window.ui && typeof window.ui.computeFilterRanges === "function") {
          window.ui.computeFilterRanges();
          window.ui.updateFilterSliderLabels();
        }
        updateTimeLabel(100);
        applyTimeFilter(100);
                if (typeof loadTravelTimesJson === "function") {
          loadTravelTimesJson();
        }
      })
      .catch(err => {
        console.error("Fehler beim Laden von resorts.json:", err);
        alert("Fehler beim Laden der Skigebiete (Details in Konsole).");
      });
  }

  function buildMarkers() {
    Object.values(resorts).forEach(r => {
      // Initiale Farbe: Immer Länderfarbe (Highlights sind standardmäßig aus)
      const countryCode = (r.country || "").toUpperCase();
      let color = COLOR_OTHER;
      if (countryCode === "AT") color = COLOR_AT;
      else if (countryCode === "DE") color = COLOR_DE;
      else if (countryCode === "CH") color = COLOR_CH;
      else if (countryCode === "IT") color = COLOR_IT;
      else if (countryCode === "FR") color = COLOR_FR;
      else if (countryCode === "SI") color = COLOR_SI;

      const distKm   = haversineKm(MUC_LAT, MUC_LON, r.lat, r.lon);
      const estHours = distKm / AVG_SPEED_KMH;
      r.distKm = distKm;
      r.travelHours = estHours;
      if (estHours < minHours) minHours = estHours;
      if (estHours > maxHours) maxHours = estHours;

      const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;
      const approx = window.i18n ? window.i18n.t('approxShort') : 'ca.';
      const driveTxt = `${Math.round(distKm)} km · ${approx} ${fmtTime(estHours)}`;

      let marker;
      const currentZoom = map.getZoom();

      // Prüfe ob Favorit oder Besucht (bei Page-Reload)
      const stableId = r.stable_id;
      const isFav = stableId && window.Favorites && window.Favorites.isFavorite(stableId);
      const isVis = stableId && window.Visited && window.Visited.isVisited(stableId);
      let isSpecialIcon = null;

      // Priorität: Besucht > Favorit > Gletscher > Normal
      if (isVis) {
        // Besucht: Grüner Haken (höchste Priorität, auch für Gletscher!)
        marker = L.marker([r.lat, r.lon], { icon: createVisitedMarkerIcon(currentZoom, color) });
        isSpecialIcon = 'visited';
      } else if (isFav && !r.glacier) {
        // Favorit: Goldener Stern (nur für Nicht-Gletscher)
        marker = L.marker([r.lat, r.lon], { icon: createFavoriteMarkerIcon(currentZoom, color) });
        isSpecialIcon = 'favorite';
      } else if (r.glacier) {
        // Gletscher: Schneeflocken-Icon
        const iconSize = getGlacierIconSize(currentZoom);
        marker = L.marker([r.lat, r.lon], { icon: createGlacierIcon(color, iconSize) });
        glacierMarkers.push({ marker, color, resortName: r.name });
        isSpecialIcon = isFav ? 'favorite' : null;
      } else {
        // Normal: CircleMarker
        const radius = getMarkerRadius(currentZoom);
        marker = L.circleMarker([r.lat, r.lon], {
          radius: radius,
          color: color,
          fillColor: color,
          fillOpacity: 0.95,
          weight: 2
        });
        circleMarkers.push(marker);
      }

      marker
        .bindPopup(() => makePopupHtml(r))
        .bindTooltip(r.name);
      markerLayer.addLayer(marker);
      resortMarkers[norm(r.name)] = marker;

      // Lookup-Map für Marker-Updates befüllen
      if (stableId) {
        resortMarkersByStableId[stableId] = { marker, resort: r, isSpecialIcon };
      }
    });

    // einmal initial nach Markerbau updaten
    updateResortCounter();
  }

  // Zoom-Event-Handler für Marker-Größenanpassung
  map.on("zoomend", function() {
    updateMarkerSizes();
    // Favorit/Besucht-Marker bei Zoom aktualisieren
    try {
      updateSpecialMarkerIcons();
    } catch (e) { console.warn("Zoom update error:", e); }
    // Corridor-Skalierung entfernt (Performance: zu teuer bei vielen Segmenten)
  });

  const timeSlider = document.getElementById("time-slider");
  

  const baseLayers = {
    "OSM": osm,
    "Satellit": satellite,
    "Clean": clean,
    "Terrain": terrain,
    "Topo": topo,
    "Grey": grey
  };

  const overlays = {
    "Pisten & Lifte": slopesLayer,
    "Hillshade": hillshade
  };

  window.layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// --- Panel: Layer-Control optisch/inhaltlich gliedern (Karte vs Overlays) ---
(function decorateLayerControl(){
  try{
    const lc = window.layerControl;
    const c = lc && lc.getContainer ? lc.getContainer() : document.querySelector('.leaflet-control-layers');
    if (!c) return;

    // Collapsible Toggle-Button hinzufügen (falls noch nicht vorhanden)
    if (!c.querySelector('.panel-toggle')) {
      // Existierenden Inhalt in panel-content wrappen
      const list = c.querySelector('.leaflet-control-layers-list');
      if (list) {
        const wrapper = document.createElement('div');
        wrapper.className = 'panel-content';
        list.parentNode.insertBefore(wrapper, list);
        wrapper.appendChild(list);
      }

      // Toggle-Button einfügen
      const toggleBtn = document.createElement('button');
      toggleBtn.type = 'button';
      toggleBtn.className = 'panel-toggle';
      toggleBtn.setAttribute('aria-label', 'Layer ein-/ausklappen');
      toggleBtn.setAttribute('aria-expanded', 'false');
      toggleBtn.innerHTML = '<span class="toggle-title">Layer</span><span class="toggle-icon">▼</span>';
      c.insertBefore(toggleBtn, c.firstChild);

      // Standardmäßig eingeklappt
      c.classList.add('collapsed');

      // Toggle-Verhalten
      toggleBtn.addEventListener('click', () => {
        const isCollapsed = c.classList.toggle('collapsed');
        toggleBtn.setAttribute('aria-expanded', !isCollapsed);
        // Weather-Box Position aktualisieren
        if (window.updateWeatherBoxPosition) {
          setTimeout(window.updateWeatherBoxPosition, 50);
        }
      });
    }

    // Gruppenüberschriften
    const base = c.querySelector('.leaflet-control-layers-base');
    const ov   = c.querySelector('.leaflet-control-layers-overlays');
    if (base && !(base.previousElementSibling && base.previousElementSibling.classList.contains('panel-group-title'))){
      base.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Karte</div>');
    }
    if (ov && !(ov.previousElementSibling && ov.previousElementSibling.classList.contains('panel-group-title'))){
      ov.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Overlays</div>');
    }
  } catch(e){
    console.warn('decorateLayerControl failed', e);
  }
})();
// --------- Suche & Filter initialisieren (ausgelagert in searchFilter.js) ---------

  // --- Zoom-Reset: mobile anders als Desktop (wird von searchFilter.js über resetMapView() genutzt) ---
  // Werte aus zentraler Config
  const isMobileViewport = () => window.matchMedia("(max-width: 720px)").matches;

  function resetView(map) {
    // Optional: Popups schließen, damit Reset "clean" wirkt
    try { map.closePopup(); } catch (_) {}

    const opts = { animate: true, duration: 0.8 };

    if (isMobileViewport()) {
      map.flyTo(CFG.map.center, CFG.map.zoomMobile, opts);

      // Optional: leicht nach unten schieben, falls die Top-Bar zu viel überdeckt (Wert anpassen/auskommentieren)
      // try { map.panBy([0, 80], { animate: true, duration: 0.35 }); } catch (_) {}
    } else {
      map.flyTo(CFG.map.center, CFG.map.zoomDesktop, opts);
    }
  }

  const ui = window.initSearchAndFilters({
    map,
    resorts,
    resortMarkers,
    markerLayer,
    fmtTime,
    norm,
    getMinHours: () => minHours,
    getMaxHours: () => maxHours,
    updateResortCounter,
    createFilterControl: true,
    createExportControl: true,
    resetView,
    // Farbkonstanten für dynamische Marker-Färbung
    colors: {
      SCT: COLOR_SCT,
      SSC: COLOR_SSC,
      BOTH: COLOR_BOTH,
      OTHER: COLOR_OTHER,
      AT: COLOR_AT,
      DE: COLOR_DE,
      CH: COLOR_CH,
      IT: COLOR_IT,
      FR: COLOR_FR,
      SI: COLOR_SI
    },
    // Gletscher-Marker für Icon-Updates
    glacierMarkers,
    createGlacierIcon,
    createCircleIcon
  });
  window.ui = ui;

  // --------- GPS: aktuelle Position anzeigen (mobil) ---------
  if (window.GpsControl && typeof window.GpsControl.init === "function") {
    try { window.GpsControl.init(map); } catch (e) { console.warn("GpsControl init failed", e); }
  }

// Alte Funktionsnamen weiterhin verfügbar halten (damit bestehender Code unverändert bleibt)
  window.rebuildDatalist   = ui.rebuildDatalist;
  window.updateTimeLabel   = ui.updateTimeLabel;
  window.applyTimeFilter   = ui.applyTimeFilter;
  window.focusResortByName = ui.focusResortByName;
  // Suche & Filter wurden in searchFilter.js ausgelagert.


  // --------- Tree Routes Overlay (Reachability "Chaos"-Layer) ---------
  // Erwartete Dateien: data/routes/home_<homeId>.geojson (z.B. home_muc.geojson)
  // Home-Auswahl erfolgt über das Dropdown (HomeRoutesSelector) und lädt die passende Datei.
  let tree = null;
  let currentTreeHomeId = "muc"; // Fallback; wird bei Init vom Selector überschrieben

  function pctToLimitHours(pct) {
    const p = Math.max(0, Math.min(100, Number(pct))) / 100;
    // minHours/maxHours werden aus travel_times.json (oder OSRM/ORS) gesetzt
    if (!isFinite(minHours) || !isFinite(maxHours) || minHours === Infinity) return Infinity;
    return minHours + p * (maxHours - minHours);
  }

  function syncTreeWithUi(uiObj, pct) {
    if (!tree || !uiObj) return;

    // 1) Zeitlimit aus Slider-Prozent
    const limitHours = (pct >= 99) ? Infinity : pctToLimitHours(pct);
    tree.setMaxHours(limitHours);

    // 2) Weitere Filter: Wir übernehmen einfach die aktuell sichtbaren Resorts aus der UI
    //    und zeigen nur deren Routen an.
    const visible = uiObj.getVisibleResorts ? uiObj.getVisibleResorts() : [];
    const visibleSet = new Set(visible.map(r => norm(r.name)));

    tree.setPredicate((props) => {
      const nm = props && (props.name || props.resort_name || props.resort) ? String(props.name || props.resort_name || props.resort) : "";
      return visibleSet.has(norm(nm));
    });
  }

  // Tree Overlay (re-)initialisieren und (optional) in Layer-Control aufnehmen
  async function ensureTreeOverlayForHome(homeId) {
    if (!window.TreeRoutesOverlay) return null;
    const url = `data/routes/home_${homeId}.geojson`;

    // Enabled-Status merken
    const hadTree = !!(tree && tree.getLayer && tree.getLayer());
    const wasEnabled = hadTree ? map.hasLayer(tree.getLayer()) : true; // default: an

    // Alte Instanz entfernen (Layer + Eintrag im LayerControl)
    if (tree && tree.getLayer && tree.getLayer()) {
      const oldLayer = tree.getLayer();
      try { if (map.hasLayer(oldLayer)) map.removeLayer(oldLayer); } catch (_) {}
      try { if (window.layerControl && typeof window.layerControl.removeLayer === "function") window.layerControl.removeLayer(oldLayer); } catch (_) {}
    }

    // Neu initialisieren (preserve enabled state)
    const next = await window.TreeRoutesOverlay.init(map, {
      url,
      enabled: wasEnabled,   // bleibt an/aus wie vorher
      baseOpacity: 0.18
    });

    tree = next;
    currentTreeHomeId = homeId;
    window.treeOverlay = tree;

    // Tree Routes aus Layer-Control entfernt - ersetzt durch Corridors
    // Code bleibt für eventuelle spätere Nutzung erhalten

    // applyFilters hooken: immer wenn Marker-Filter aktualisiert werden, Tree synchronisieren
    if (ui && typeof ui.applyFilters === "function") {
      const _apply = ui.applyFilters;
      if (!_apply.__treeHooked) {
        ui.applyFilters = function (pct) {
          _apply(pct);
          syncTreeWithUi(ui, pct);
        };
        ui.applyFilters.__treeHooked = true;

        // alte Alias-Funktion ebenfalls aktualisieren
        window.applyTimeFilter = ui.applyFilters;
        window.applyFilters = ui.applyFilters;
      }
    }

    // initial sync
    const initialPct = Number(timeSlider?.value ?? 100);
    syncTreeWithUi(ui, initialPct);

    return tree;
  }

  // Expose for home selector
  window.ensureTreeOverlayForHome = ensureTreeOverlayForHome;

  // Tree Routes Overlay deaktiviert - ersetzt durch Corridors

  // --------- Corridor Overlay (Hauptstrecken) ---------
  // Zeigt die meistgenutzten Streckenabschnitte mit variabler Linienbreite
  let corridorOverlay = null;

  async function ensureCorridorOverlayForHome(homeId) {
    if (!window.CorridorOverlay) return null;
    const url = `data/corridors/home_${homeId}.geojson`;

    // Alten Layer entfernen
    if (corridorOverlay && corridorOverlay.getLayer) {
      const oldLayer = corridorOverlay.getLayer();
      if (oldLayer) {
        map.removeLayer(oldLayer);
        if (window.layerControl) {
          window.layerControl.removeLayer(oldLayer);
        }
      }
    }

    try {
      // Initiale Weights basierend auf aktuellem Zoom
      const initWeights = getCorridorWeights(map.getZoom());
      corridorOverlay = await window.CorridorOverlay.init(map, {
        url,
        enabled: false,  // Default: aus (User kann es einschalten)
        minWeight: initWeights.minWeight,
        maxWeight: initWeights.maxWeight,
        baseOpacity: 0.75
      });

      window.corridorOverlay = corridorOverlay;

      // Only add to layer control if we have features
      if (window.layerControl && corridorOverlay.getLayer() && corridorOverlay.getFeatureCount() > 0) {
        console.log("[Corridor] Adding to layerControl...");
        window.layerControl.addOverlay(corridorOverlay.getLayer(), "Corridors");
        console.log("[Corridor] Added to layerControl.");
        // Refresh Bottom Sheet layers (Mobile) after adding Corridors
        if (typeof window.populateBottomSheetLayers === 'function') {
          window.populateBottomSheetLayers();
        }
      } else if (corridorOverlay.getFeatureCount() === 0) {
        console.log("[Corridor] No features for this home, skipping layer control.");
      }

      console.log(`Corridors loaded: ${corridorOverlay.getFeatureCount()} segments, max ${corridorOverlay.getMaxCount()} routes`);
    } catch (err) {
      console.warn("CorridorOverlay init skipped/failed:", err);
    }

    return corridorOverlay;
  }

  // Expose for home selector
  window.ensureCorridorOverlayForHome = ensureCorridorOverlayForHome;

  // Initial: Corridors für München laden
  (async () => {
    console.log("[Corridor] Starting init, CorridorOverlay available:", !!window.CorridorOverlay);
    console.log("[Corridor] layerControl available:", !!window.layerControl);
    try {
      const result = await ensureCorridorOverlayForHome("muc");
      console.log("[Corridor] Init result:", result);
      console.log("[Corridor] Layer added to control:", result && result.getLayer && !!result.getLayer());
    } catch (err) {
      console.warn("CorridorOverlay init skipped:", err);
    }
  })();

  function applyTravelTimesFromMap(ttMap) {
    const resortList = Object.values(resorts);
    minHours = Infinity;
    maxHours = 0;

    resortList.forEach(r => {
      // Lookup by stable_id (preferred), then by name (fallback)
      const tt = ttMap[r.stable_id] || ttMap[r.name];
      if (tt) {
        // Support both formats:
        // Old: { hours: 2.5, km: 180 }
        // New: { duration_min: 150, duration_sec: 9000, distance_km: 180 }
        let hours = null;
        let km = null;

        if (typeof tt.hours === "number") {
          hours = tt.hours;
        } else if (typeof tt.duration_min === "number") {
          hours = tt.duration_min / 60;
        }

        if (typeof tt.km === "number") {
          km = tt.km;
        } else if (typeof tt.distance_km === "number") {
          km = tt.distance_km;
        }

        if (hours !== null) {
          r.travelHours = hours;
          if (km !== null) r.distKm = km;
        }
      }
      // minHours/maxHours von ALLEN Resorts (echte Zeiten + Schätzungen)
      if (typeof r.travelHours === "number" && isFinite(r.travelHours)) {
        if (r.travelHours < minHours) minHours = r.travelHours;
        if (r.travelHours > maxHours) maxHours = r.travelHours;
      }
    });

    if (typeof rebuildDatalist === "function") {
      rebuildDatalist();
    }
    if (typeof timeSlider !== "undefined" && timeSlider) {
      timeSlider.value = 100;
    }
    updateTimeLabel(100);
    applyTimeFilter(100);
  }

  async function recalcTravelTimesFromOrigin() {
    const input = document.getElementById("home-input");
    const value = input.value.trim();

    let originLat;
    let originLon;

    if (!value) {
      originLat = MUC_LAT;
      originLon = MUC_LON;
    } else if (value.includes(",")) {
      const parts = value.split(",");
      originLat = parseFloat(parts[0]);
      originLon = parseFloat(parts[1]);
      if (!isFinite(originLat) || !isFinite(originLon)) {
        alert("Konnte Eingabe nicht als 'lat,lon' interpretieren.");
        return;
      }
    } else {
      if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
        alert("Bitte ORS_API_KEY in config.js eintragen.");
        return;
      }
      try {
        const url = "https://api.openrouteservice.org/geocode/search?api_key=" +
                    encodeURIComponent(ORS_API_KEY) +
                    "&text=" + encodeURIComponent(value) +
                    "&size=1";
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("Geocoding-Request fehlgeschlagen");
        }
        const data = await resp.json();
        const feats = data.features || [];
        if (!feats.length) {
          alert("Adresse konnte nicht gefunden werden.");
          return;
        }
        const coords = feats[0].geometry.coordinates;
        originLon = coords[0];
        originLat = coords[1];
      } catch (err) {
        console.error("Fehler beim Geocoding:", err);
        alert("Fehler beim Geocoding (Details in Konsole).");
        return;
      }
    }

    if (typeof map !== "undefined") {
      if (originMarker) {
        map.removeLayer(originMarker);
      }
      const originIcon = L.divIcon({
        html: `
          <div style="
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
          ">
            🏠
          </div>
        `,
        className: "",
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
      originMarker = L.marker([originLat, originLon], { icon: originIcon })
        .addTo(map)
        .bindTooltip("Startpunkt", { permanent: false });
    }

    const key = originLat.toFixed(3) + "," + originLon.toFixed(3);

    if (travelTimeCache[key]) {
      applyTravelTimesFromMap(travelTimeCache[key]);
      return;
    }

    const resortList = Object.values(resorts);
    const locations = [[originLon, originLat]].concat(
      resortList.map(r => [r.lon, r.lat])
    );
    const body = {
      locations: locations,
      metrics: ["distance", "duration"],
      units: "km",
      sources: [0],
      destinations: resortList.map((_, idx) => idx + 1)
    };

    if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
      alert("Bitte ORS_API_KEY in config.js eintragen.");
      return;
    }

    try {
      const resp = await fetch("https://api.openrouteservice.org/v2/matrix/driving-car", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": ORS_API_KEY
        },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        throw new Error("Matrix-Request fehlgeschlagen: " + resp.status);
      }
      const data = await resp.json();
      const durations = (data.durations && data.durations[0]) || [];
      const distances = (data.distances && data.distances[0]) || [];

      const ttMap = {};
      resortList.forEach((r, idx) => {
        const durSec = durations[idx];
        const distKm = distances[idx];
        if (typeof durSec === "number" && typeof distKm === "number") {
          const hours = durSec / 3600.0;
          ttMap[r.name] = { hours: hours, km: distKm };
        }
      });

      travelTimeCache[key] = ttMap;
      applyTravelTimesFromMap(ttMap);
    } catch (err) {
      console.error("Fehler beim Abrufen der Matrix:", err);
      alert("Fehler beim Abrufen der Fahrzeiten (Details in Konsole).");
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btn-calc-times");
    if (btn) {
      btn.addEventListener("click", () => {
        recalcTravelTimesFromOrigin();
      });
    }

    // GPS-Funktion für beide Buttons (Mobile home-box + Desktop slider-box)
    function handleGpsClick(buttonEl, originalText) {
      if (!navigator.geolocation) {
        alert("Geolocation wird von diesem Browser nicht unterstützt.");
        return;
      }

      buttonEl.disabled = true;
      buttonEl.textContent = "⏳";

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude.toFixed(6);
          const lon = pos.coords.longitude.toFixed(6);
          const input = document.getElementById("home-input");
          if (input) input.value = `${lat},${lon}`;

          buttonEl.disabled = false;
          buttonEl.textContent = originalText;

          recalcTravelTimesFromOrigin();
        },
        (err) => {
          buttonEl.disabled = false;
          buttonEl.textContent = originalText;
          console.error("GPS Fehler:", err);
          alert("GPS-Position konnte nicht ermittelt werden: " + err.message);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // GPS-Button in home-box (Mobile)
    const gpsBtn = document.getElementById("btn-gps-times");
    if (gpsBtn) {
      gpsBtn.addEventListener("click", () => handleGpsClick(gpsBtn, "📍 GPS"));
    }

    // GPS-Button in slider-box (Desktop)
    const gpsSliderBtn = document.getElementById("btn-gps-slider");
    if (gpsSliderBtn) {
      gpsSliderBtn.addEventListener("click", () => handleGpsClick(gpsSliderBtn, "📍"));
    }

    // Berechnen-Button in slider-box (Desktop)
    const calcSliderBtn = document.getElementById("btn-calc-slider");
    const homeInputSlider = document.getElementById("home-input-slider");
    if (calcSliderBtn && homeInputSlider) {
      calcSliderBtn.addEventListener("click", () => {
        // Wert ins home-input kopieren (wird von recalcTravelTimesFromOrigin gelesen)
        const homeInput = document.getElementById("home-input");
        if (homeInput) homeInput.value = homeInputSlider.value;
        recalcTravelTimesFromOrigin();
      });
      // Enter-Taste im Input-Feld
      homeInputSlider.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          calcSliderBtn.click();
        }
      });
    }
  });

  function loadTravelTimesJson(homeId) {
    // Kompatibilität: lädt vorkomputierte Fahrzeiten pro Home-Profil
    // Erwartet Datei: data/travel_times/home_<homeId>.json
    const stored = (window.HomeTravelTimes && typeof window.HomeTravelTimes.getSelectedHomeId === "function")
      ? window.HomeTravelTimes.getSelectedHomeId()
      : null;

    const hid = homeId || stored || (localStorage.getItem(CFG.home.storageKey)) || CFG.home.defaultId;
    if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
      return window.HomeTravelTimes.load(hid);
    }

    // Fallback (sollte praktisch nie passieren):
    fetch(`data/travel_times/home_${hid}.json`)
      .then(resp => resp.json())
      .then(data => applyTravelTimesFromMap(data))
      .catch(err => {
        console.error("Fehler beim Laden von travel_times (per home), nutze Luftlinie:", err);
        updateTimeLabel(100);
        applyTimeFilter(100);
      });
  }

  
  // --------- Home Dropdown (Tree Routes + Fahrzeiten auswählen) ---------
  document.addEventListener("DOMContentLoaded", () => {
    if (!window.HomeRoutesSelector) return;

    window.HomeRoutesSelector.init({
      homesUrl: "data/homes.json",
      routesDir: "data/routes",
      routeFile: (homeId) => `data/routes/home_${homeId}.geojson`,
      defaultHomeId: CFG.home.defaultId,
      selectId: "homeSelectSlider",
      boxId: "homeSelectorBox",
      desktopHostSelector: ".leaflet-top.leaflet-right",
      mobileHostId: "panel-filters",
      storageKey: CFG.home.storageKey,
      onHomeChanged: async (homeId, homeMeta) => {
        // Slider-Label updaten
        const lbl = document.querySelector('.slider-box label[for="time-slider"]');
        if (lbl) lbl.textContent = `Max. Fahrzeit ab ${homeMeta?.name || homeId}`;

        // Home-Marker auf Karte anzeigen (gleicher Style wie bei manueller Eingabe)
        if (homeMeta?.lat && homeMeta?.lon && typeof map !== "undefined") {
          if (originMarker) {
            map.removeLayer(originMarker);
          }
          const homeIcon = L.divIcon({
            html: `
              <div style="
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #ffffff;
                border: 2px solid #000000;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
              ">
                🏠
              </div>
            `,
            className: "home-origin-marker",
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          });
          originMarker = L.marker([homeMeta.lat, homeMeta.lon], { icon: homeIcon })
            .addTo(map)
            .bindTooltip(homeMeta.name || homeId, { permanent: false });
        }

        // Fahrzeiten pro Home laden
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.setSelectedHomeId === "function") {
          window.HomeTravelTimes.setSelectedHomeId(homeId);
        }
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
          try { await window.HomeTravelTimes.load(homeId); }
          catch (e) { console.warn("HomeTravelTimes load failed:", e); }
        }

        // Corridors neu laden (ohne Checkbox-Status zu verändern)
        if (typeof window.ensureCorridorOverlayForHome === "function") {
          try { await window.ensureCorridorOverlayForHome(homeId); }
          catch (e) { console.warn("ensureCorridorOverlayForHome failed:", e); }
        }
      }
    });
  });

document.addEventListener("DOMContentLoaded", () => {
    loadResortsAndInit();
  });

  // Favoriten-Stern Klick-Handler (delegiert auf document für Popups)
  document.addEventListener("click", (e) => {
    const star = e.target.closest(".fav-star");
    if (!star) return;

    e.stopPropagation(); // Verhindert Event-Bubbling

    const stableId = star.dataset.stableId;
    if (!stableId || !window.Favorites) return;

    try {
      const isNowFav = window.Favorites.toggleFavorite(stableId);

      // Update Stern im Popup
      star.textContent = isNowFav ? "★" : "☆";
      star.classList.toggle("active", isNowFav);
      star.title = isNowFav ? i18n.t("removeFromFavorites") : i18n.t("addToFavorites");
    } catch (err) {
      console.error("Favoriten-Toggle Fehler:", err);
    }
  });

  // Besucht-Toggle Klick-Handler (delegiert auf document für Popups)
  document.addEventListener("click", (e) => {
    const check = e.target.closest(".visited-check");
    if (!check) return;

    e.stopPropagation(); // Verhindert Event-Bubbling

    const stableId = check.dataset.stableId;
    if (!stableId || !window.Visited) return;

    try {
      const isNowVisited = window.Visited.toggleVisited(stableId);

      // Update Check im Popup
      check.textContent = isNowVisited ? "✓" : "○";
      check.classList.toggle("active", isNowVisited);
      check.title = isNowVisited ? i18n.t("markAsNotVisited") : i18n.t("markAsVisited");
    } catch (err) {
      console.error("Besucht-Toggle Fehler:", err);
    }
  });

  // Verbund-Link Klick-Handler (navigiert zum Verbund-Marker)
  document.addEventListener("click", (e) => {
    const link = e.target.closest(".verbund-link");
    if (!link) return;

    e.preventDefault();
    e.stopPropagation();

    const verbundId = link.dataset.verbundId;
    if (!verbundId || !verbundMarkers[verbundId]) return;

    const { marker, verbund } = verbundMarkers[verbundId];
    const latLng = marker.getLatLng();

    // Popup schließen, zur Verbund-Position fliegen, Popup öffnen
    map.closePopup();
    map.setView(latLng, Math.max(map.getZoom(), 9));
    marker.openPopup();

    // Verbindungslinien anzeigen
    showVerbundConnections(verbund);
  });

  // Popup Berg/Tal Toggle Handler (für 16-Tage-Prognose)
  document.addEventListener("click", (e) => {
    const btn = e.target.closest(".popup-loc-btn");
    if (!btn) return;

    e.stopPropagation();

    const loc = btn.dataset.loc;
    const stableId = btn.dataset.stableId;
    if (!loc || !stableId) return;

    // Toggle Button-Styles
    const container = btn.closest(".popup-location-toggle");
    if (container) {
      container.querySelectorAll(".popup-loc-btn").forEach(b => {
        const isActive = b.dataset.loc === loc;
        b.classList.toggle("active", isActive);
        b.style.background = isActive ? "#10b981" : "#f5f5f5";
        b.style.color = isActive ? "white" : "inherit";
      });
    }

    // Toggle Tabellen
    const details = btn.closest(".forecast-details");
    if (details) {
      const mountainTable = details.querySelector(".popup-forecast-mountain");
      const valleyTable = details.querySelector(".popup-forecast-valley");
      if (mountainTable) mountainTable.style.display = loc === "mountain" ? "" : "none";
      if (valleyTable) valleyTable.style.display = loc === "valley" ? "" : "none";
    }
  });

  // --- Language Toggle ---
  (function initLanguageToggle() {
    const langBtn = document.getElementById("lang-toggle");
    if (!langBtn) return;

    const flagGB = '<svg viewBox="0 0 60 30" width="24" height="12"><clipPath id="gb"><rect width="60" height="30"/></clipPath><g clip-path="url(#gb)"><path d="M0,0v30h60V0z" fill="#012169"/><path d="M0,0L60,30M60,0L0,30" stroke="#fff" stroke-width="6"/><path d="M0,0L60,30M60,0L0,30" stroke="#C8102E" stroke-width="4"/><path d="M30,0v30M0,15h60" stroke="#fff" stroke-width="10"/><path d="M30,0v30M0,15h60" stroke="#C8102E" stroke-width="6"/></g></svg>';
    const flagDE = '<svg viewBox="0 0 5 3" width="24" height="14"><rect width="5" height="1" y="0" fill="#000"/><rect width="5" height="1" y="1" fill="#D00"/><rect width="5" height="1" y="2" fill="#FFCE00"/></svg>';

    function updateLangButton() {
      const lang = i18n.getLang();
      langBtn.innerHTML = lang === "de" ? flagGB : flagDE;
      langBtn.title = lang === "de" ? "Switch to English" : "Auf Deutsch wechseln";
    }

    // Initial update
    updateLangButton();

    // Click handler
    langBtn.addEventListener("click", () => {
      i18n.toggleLang();
      updateLangButton();
      // Reload page to apply all translations (simplest approach)
      // Alternative: call updateLanguageUI() for live updates
      location.reload();
    });
  })();

  // --- i18n: Update static labels from data-i18n attributes ---
  (function initI18nLabels() {
    if (!window.i18n) return;
    const t = window.i18n.t;

    // Update textContent for elements with data-i18n
    document.querySelectorAll("[data-i18n]").forEach(el => {
      const key = el.dataset.i18n;
      if (key) el.textContent = t(key);
    });

    // Update title attributes
    document.querySelectorAll("[data-i18n-title]").forEach(el => {
      const key = el.dataset.i18nTitle;
      if (key) el.title = t(key);
    });

    // Update placeholder attributes
    document.querySelectorAll("[data-i18n-placeholder]").forEach(el => {
      const key = el.dataset.i18nPlaceholder;
      if (key) el.placeholder = t(key);
    });

    // Update aria-label attributes
    document.querySelectorAll("[data-i18n-aria]").forEach(el => {
      const key = el.dataset.i18nAria;
      if (key) el.setAttribute("aria-label", t(key));
    });

    // Update document title
    document.title = t("pageTitle");
  })();

  // Access Points auf Karte anzeigen (delegiert auf document für Popups)
  let accessPointMarkers = [];
  document.addEventListener("click", (e) => {
    const btn = e.target.closest(".show-access-points-btn");
    if (!btn) return;

    e.stopPropagation();

    // Alte Marker entfernen
    accessPointMarkers.forEach(m => map.removeLayer(m));
    accessPointMarkers = [];

    const resortId = btn.dataset.resortId;
    if (!resortId) return;

    // Resort finden
    const resort = window.__allResorts?.find(r => r.stable_id === resortId);
    if (!resort || !resort.accessPoints) return;

    // Marker für alle Access Points erstellen
    resort.accessPoints.forEach((ap, idx) => {
      const gmapsUrl = `https://www.google.com/maps?q=${ap.lat},${ap.lon}`;
      const elevStr = ap.elevation ? ` (${ap.elevation}m)` : '';

      const marker = L.circleMarker([ap.lat, ap.lon], {
        radius: 8,
        fillColor: '#2563eb',
        fillOpacity: 0.9,
        color: 'white',
        weight: 2
      })
      .bindTooltip(ap.name, { permanent: false, direction: 'top' })
      .bindPopup(`
        <div style="font-size:13px">
          <b>${ap.name}</b>${elevStr}<br/>
          <span style="color:#64748b">${ap.kind || 'Einstieg'}</span><br/>
          <a href="${gmapsUrl}" target="_blank" rel="noopener">Google Maps</a>
        </div>
      `)
      .addTo(map);

      accessPointMarkers.push(marker);
    });

    // Zur Gruppe zoomen
    if (accessPointMarkers.length > 0) {
      const group = L.featureGroup(accessPointMarkers);
      map.fitBounds(group.getBounds().pad(0.2));
    }

    // Button-Text ändern
    btn.textContent = '✓';
    btn.title = 'Einstiege werden angezeigt';
  });

  // --- Draggable Popup ---
  function makePopupDraggable(popup) {
    const container = popup.getElement();
    if (!container) return;

    const wrapper = container.querySelector('.leaflet-popup-content-wrapper');
    if (!wrapper) return;

    let isDragging = false;
    let startX, startY;
    let origLeft, origTop;

    function onMouseDown(e) {
      // Ignore if clicking on interactive elements
      if (e.target.closest('a, button, input, select, .fav-star, .visited-check, details')) return;

      isDragging = true;
      startX = e.clientX || (e.touches && e.touches[0].clientX);
      startY = e.clientY || (e.touches && e.touches[0].clientY);

      const style = window.getComputedStyle(container);
      origLeft = parseInt(style.left) || 0;
      origTop = parseInt(style.top) || 0;

      wrapper.classList.add('dragging');
      container.classList.add('dragging');

      // Disable map dragging while popup is dragged
      map.dragging.disable();

      e.preventDefault();
    }

    function onMouseMove(e) {
      if (!isDragging) return;

      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);

      const dx = clientX - startX;
      const dy = clientY - startY;

      container.style.left = (origLeft + dx) + 'px';
      container.style.top = (origTop + dy) + 'px';

      e.preventDefault();
    }

    function onMouseUp() {
      if (!isDragging) return;
      isDragging = false;

      wrapper.classList.remove('dragging');
      container.classList.remove('dragging');

      // Re-enable map dragging
      map.dragging.enable();
    }

    // Mouse events
    wrapper.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // Touch events
    wrapper.addEventListener('touchstart', onMouseDown, { passive: false });
    document.addEventListener('touchmove', onMouseMove, { passive: false });
    document.addEventListener('touchend', onMouseUp);

    // Cleanup when popup closes
    popup.on('remove', () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      document.removeEventListener('touchmove', onMouseMove);
      document.removeEventListener('touchend', onMouseUp);
    });
  }

  // Make all popups draggable
  map.on('popupopen', (e) => {
    makePopupDraggable(e.popup);
  });

  // Access Points entfernen wenn Popup geschlossen wird
  map.on('popupclose', () => {
    accessPointMarkers.forEach(m => map.removeLayer(m));
    accessPointMarkers = [];
  });

  // Slider-Box Toggle (Desktop + Mobile)
  (function() {
    const sliderBox = document.getElementById('slider-box');
    const toggleBtn = document.getElementById('slider-box-toggle');
    if (!sliderBox || !toggleBtn) return;

    // Collapse state aus Config
    const isMobile = window.innerWidth <= 768;
    const shouldCollapse = isMobile ? CFG.ui.sliderBoxCollapsedMobile : CFG.ui.sliderBoxCollapsedDesktop;
    if (shouldCollapse) {
      sliderBox.classList.add('collapsed');
      toggleBtn.setAttribute('aria-expanded', 'false');
    }

    toggleBtn.addEventListener('click', () => {
      const isCollapsed = sliderBox.classList.toggle('collapsed');
      toggleBtn.setAttribute('aria-expanded', !isCollapsed);
    });
  })();

  // Weather-Box Logic
  (function() {
    const weatherBox = document.getElementById('weather-box');
    const weatherToggleBtn = document.getElementById('weather-box-toggle');
    const weatherToggle = document.getElementById('weather-toggle');
    const dailyBtns = document.querySelectorAll('.day-row .day-btn');
    const cumulativeBtns = document.querySelectorAll('.weather-box .cumulative-btn');
    const snowMinSlider = document.getElementById('snow-min-slider');
    const snowMinLabel = document.getElementById('snow-min-label');
    const legendLabel = document.getElementById('legend-timeframe-label');

    if (!weatherBox || !weatherToggleBtn) return;

    // Collapse/Expand Toggle
    weatherToggleBtn.addEventListener('click', () => {
      const isCollapsed = weatherBox.classList.toggle('collapsed');
      weatherToggleBtn.setAttribute('aria-expanded', !isCollapsed);
    });

    // Weather State aus Config
    window.weatherFilterState = {
      enabled: CFG.weather.enabled,
      dayIndex: CFG.weather.dayIndex,
      cumulative: CFG.weather.cumulative,
      minSnowCm: CFG.weather.minSnowCm,
      location: CFG.weather.location
    };

    // Update legend label based on current selection
    function updateLegendLabel() {
      const state = window.weatherFilterState;
      const getDayLabel = (idx) => {
        if (idx === 0) return 'Heute';
        if (idx === 1) return 'Morgen';
        return `+${idx} Tage`;
      };
      if (state.cumulative) {
        legendLabel.textContent = state.dayIndex === 0
          ? `Legende (Heute)`
          : `Legende (Σ bis ${getDayLabel(state.dayIndex)})`;
      } else {
        legendLabel.textContent = `Legende (${getDayLabel(state.dayIndex)})`;
      }
    }

    // Debounced update to prevent memory leak from rapid slider movements
    let weatherUpdateTimer = null;
    function debouncedWeatherUpdate() {
      if (weatherUpdateTimer) clearTimeout(weatherUpdateTimer);
      weatherUpdateTimer = setTimeout(() => updateWeatherDisplay(), 150);
    }

    // On/Off Toggle
    weatherToggle?.addEventListener('change', () => {
      window.weatherFilterState.enabled = weatherToggle.checked;
      updateWeatherDisplay();
    });

    // Cumulative Toggle (Tag / Σ bis)
    cumulativeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        cumulativeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        window.weatherFilterState.cumulative = btn.dataset.cumulative === 'true';
        updateLegendLabel();
        updateDayButtonSnowDots(); // Show/hide dots based on mode
        if (window.weatherFilterState.enabled) {
          updateWeatherDisplay();
        }
      });
    });

    // Daily Buttons (Heute, +1, +2, ...)
    dailyBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        dailyBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        window.weatherFilterState.dayIndex = parseInt(btn.dataset.day);
        updateLegendLabel();
        if (window.weatherFilterState.enabled) {
          updateWeatherDisplay();
        }
      });
    });

    // Min Snow Slider
    snowMinSlider?.addEventListener('input', () => {
      const val = parseInt(snowMinSlider.value);
      window.weatherFilterState.minSnowCm = val;
      snowMinLabel.textContent = `≥${val} cm`;
      // Sync to mobile
      const mobileSlider = document.getElementById('snow-min-slider-mobile');
      const mobileLabel = document.getElementById('snow-min-label-mobile');
      if (mobileSlider) mobileSlider.value = val;
      if (mobileLabel) mobileLabel.textContent = `≥${val} cm`;
      if (window.weatherFilterState.enabled) {
        debouncedWeatherUpdate();
      }
    });

    // === Mobile Weather Controls Sync ===
    const mobileToggle = document.getElementById('weather-toggle-mobile');
    const mobileSnowSlider = document.getElementById('snow-min-slider-mobile');
    const mobileSnowLabel = document.getElementById('snow-min-label-mobile');

    // Mobile toggle syncs with desktop
    mobileToggle?.addEventListener('change', () => {
      window.weatherFilterState.enabled = mobileToggle.checked;
      if (weatherToggle) weatherToggle.checked = mobileToggle.checked;
      updateWeatherDisplay();
    });

    // Mobile cumulative toggle
    const mobileCumulativeBtns = document.querySelectorAll('#weather-mobile-section .cumulative-btn:not(.location-btn)');
    mobileCumulativeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        mobileCumulativeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        window.weatherFilterState.cumulative = btn.dataset.cumulative === 'true';
        // Sync to desktop
        cumulativeBtns.forEach(b => {
          b.classList.toggle('active', b.dataset.cumulative === btn.dataset.cumulative);
        });
        updateLegendLabel();
        if (window.weatherFilterState.enabled) {
          updateWeatherDisplay();
        }
      });
    });

    // Mobile day buttons
    const mobileDayBtns = document.querySelectorAll('#weather-mobile-section .day-btn');
    mobileDayBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        // Update mobile buttons
        mobileDayBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const day = parseInt(btn.dataset.day);
        window.weatherFilterState.dayIndex = day;
        // Sync to desktop (find matching day button)
        dailyBtns.forEach(b => {
          b.classList.toggle('active', parseInt(b.dataset.day) === day);
        });
        updateLegendLabel();
        if (window.weatherFilterState.enabled) {
          updateWeatherDisplay();
        }
      });
    });

    // Mobile snow slider
    mobileSnowSlider?.addEventListener('input', () => {
      const val = parseInt(mobileSnowSlider.value);
      window.weatherFilterState.minSnowCm = val;
      if (mobileSnowLabel) mobileSnowLabel.textContent = `≥${val} cm`;
      // Sync to desktop
      if (snowMinSlider) snowMinSlider.value = val;
      if (snowMinLabel) snowMinLabel.textContent = `≥${val} cm`;
      if (window.weatherFilterState.enabled) {
        debouncedWeatherUpdate();
      }
    });

    // === Info Button Handler ===
    const showWeatherInfo = () => {
      const state = window.weatherFilterState;
      const dayIdx = state?.dayIndex || 0;
      const isCumulative = state?.cumulative || false;

      const t = window.i18n ? window.i18n.t : (k) => k;

      // Formatiere Zeitstempel relativ (using i18n formatRelativeTime)
      const formatAge = (date) => {
        if (!date) return t('weatherInfoNotAvailable');
        if (window.i18n && window.i18n.formatRelativeTime) {
          return window.i18n.formatRelativeTime(date);
        }
        // Fallback
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        if (diffMins < 60) return t('minutesAgo', { n: diffMins });
        if (diffHours < 24) return t('hoursAgo', { n: diffHours });
        const diffDays = Math.floor(diffHours / 24);
        return t('daysAgo', { n: diffDays });
      };

      // Bestimme Datenfrische-Status
      const getFreshnessStatus = (date, maxAgeHours) => {
        if (!date) return { icon: '⚠️', text: t('weatherInfoNoData') };
        const ageHours = (new Date() - date) / 3600000;
        if (ageHours <= maxAgeHours) return { icon: '✅', text: t('weatherInfoDataCurrent') };
        if (ageHours <= maxAgeHours * 2) return { icon: '🟡', text: t('weatherInfoDataOlder') };
        return { icon: '🔴', text: t('weatherInfoDataOutdated') };
      };

      const omStatus = getFreshnessStatus(forecastMeta.openmeteo.updatedAt, 12);
      const omAge = formatAge(forecastMeta.openmeteo.updatedAt);

      const dayLabel = window.i18n && window.i18n.getDayLabel
        ? window.i18n.getDayLabel(dayIdx)
        : (dayIdx === 0 ? t('today') : dayIdx === 1 ? t('tomorrow') : `+${dayIdx}`);
      const modeLabel = isCumulative ? `${t('sumUntil')} ${dayLabel}` : dayLabel;
      const minSnow = state?.minSnowCm || 0;
      const sliderValue = minSnow > 0 ? `≥${minSnow}cm` : t('weatherInfoOff');

      // Remove existing dialog
      document.querySelector('.weather-info-backdrop')?.remove();
      document.querySelector('.weather-info-dialog')?.remove();

      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.className = 'weather-info-backdrop';
      document.body.appendChild(backdrop);

      // Create dialog
      const dialog = document.createElement('div');
      dialog.className = 'weather-info-dialog';
      dialog.innerHTML = `
        <div class="info-dialog-header">
          <h3>${t('weatherInfoTitle')}</h3>
          <button class="info-dialog-close" type="button">&times;</button>
        </div>
        <div class="info-dialog-content">
          <div class="info-section">
            <p><strong>${t('weatherInfoSelection', { mode: modeLabel })}</strong></p>
            <p>${omStatus.icon} ${t('weatherInfoData', { status: omStatus.text, age: omAge })}</p>
          </div>
          <div class="info-section">
            <h4>${t('weatherInfoMode')}</h4>
            <p>${t('weatherInfoModeDay')}<br>${t('weatherInfoModeSum')}</p>
          </div>
          <div class="info-section">
            <h4>🔵 ${t('snowIndicator') || 'Schnee-Indikatoren'}</h4>
            <p>${t('weatherInfoDots').replace(/\n/g, '<br>')}</p>
          </div>
          <div class="info-section">
            <h4>${t('weatherInfoSlider', { value: sliderValue })}</h4>
            <p>${t('weatherInfoSliderDesc').replace(/\n/g, '<br>')}</p>
          </div>
          <div class="info-section">
            <h4>${t('weatherInfoSource')}</h4>
            <p>${t('weatherInfoSourceOpenMeteo')}<br>
            ${omStatus.icon} ${omAge}<br>
            ${t('weatherInfoResorts', { count: forecastMeta.openmeteo.count })}</p>
          </div>
          <div class="info-section">
            <p>${t('weatherInfoAutoUpdates')}</p>
          </div>
        </div>
      `;
      document.body.appendChild(dialog);

      // Close handlers
      const closeDialog = () => {
        backdrop.remove();
        dialog.remove();
      };

      dialog.querySelector('.info-dialog-close').addEventListener('click', closeDialog);
      backdrop.addEventListener('click', closeDialog);

      // ESC key closes
      const escHandler = (e) => {
        if (e.key === 'Escape') {
          closeDialog();
          document.removeEventListener('keydown', escHandler);
        }
      };
      document.addEventListener('keydown', escHandler);
    };

    document.getElementById('weather-info-btn')?.addEventListener('click', showWeatherInfo);
    document.getElementById('weather-info-btn-mobile')?.addEventListener('click', showWeatherInfo);
  })();

  // --------- Travel Time Info Dialog ---------
  (function() {
    const t = window.i18n?.t || (k => k);
    let alpsBboxLayer = null;

    function showTravelTimeInfo() {
      // Count resorts with travel times
      const allResorts = Object.values(resorts);
      const withTravelTime = allResorts.filter(r => r.travelHours != null).length;
      const total = allResorts.length;

      // Remove existing dialog
      document.querySelector('.travel-time-info-backdrop')?.remove();
      document.querySelector('.travel-time-info-dialog')?.remove();

      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.className = 'travel-time-info-backdrop';
      document.body.appendChild(backdrop);

      // Create dialog
      const dialog = document.createElement('div');
      dialog.className = 'travel-time-info-dialog';
      dialog.innerHTML = `
        <div class="travel-time-info-dialog-header">
          <h3>${t('travelTimeInfoTitle')}</h3>
          <button class="travel-time-info-dialog-close" type="button">&times;</button>
        </div>
        <div class="travel-time-info-dialog-content">
          <div class="info-section">
            <h4>${t('travelTimeInfoHow')}</h4>
            <p>${t('travelTimeInfoExplain')}</p>
          </div>
          <div class="info-section">
            <h4>${t('travelTimeInfoRegion')}</h4>
            <p>${t('travelTimeInfoRegionDesc')}</p>
            <div class="coverage-stat">
              ${t('travelTimeInfoCount', { count: withTravelTime, total: total })}
            </div>
            <div class="bbox-toggle">
              <input type="checkbox" id="bbox-toggle-checkbox" ${alpsBboxLayer ? 'checked' : ''}>
              <label for="bbox-toggle-checkbox">${alpsBboxLayer ? t('travelTimeInfoHideBbox') : t('travelTimeInfoShowBbox')}</label>
            </div>
          </div>
          <div class="info-section">
            <h4>${t('travelTimeInfoGps')}</h4>
            <p>${t('travelTimeInfoGpsDesc')}</p>
          </div>
          <div class="info-section">
            <h4>${t('travelTimeInfoDifference')}</h4>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th></th>
                  <th>${t('travelTimeInfoPreCalc')}</th>
                  <th>${t('travelTimeInfoLive')}</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>${t('travelTimeInfoRowEngine')}</td>
                  <td>${t('travelTimeInfoRowEnginePreCalc')}</td>
                  <td>${t('travelTimeInfoRowEngineLive')}</td>
                </tr>
                <tr>
                  <td>${t('travelTimeInfoRowRoutes')}</td>
                  <td>${t('travelTimeInfoRowRoutesPreCalc')}</td>
                  <td>${t('travelTimeInfoRowRoutesLive')}</td>
                </tr>
                <tr>
                  <td>${t('travelTimeInfoRowCoverage')}</td>
                  <td>${t('travelTimeInfoRowCoveragePreCalc')}</td>
                  <td>${t('travelTimeInfoRowCoverageLive')}</td>
                </tr>
                <tr>
                  <td>${t('travelTimeInfoRowSpeed')}</td>
                  <td>${t('travelTimeInfoRowSpeedPreCalc')}</td>
                  <td>${t('travelTimeInfoRowSpeedLive')}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      `;
      document.body.appendChild(dialog);

      // Event listeners
      const closeDialog = () => {
        backdrop.remove();
        dialog.remove();
      };

      backdrop.addEventListener('click', closeDialog);
      dialog.querySelector('.travel-time-info-dialog-close').addEventListener('click', closeDialog);

      // Bbox toggle
      const checkbox = dialog.querySelector('#bbox-toggle-checkbox');
      const label = dialog.querySelector('label[for="bbox-toggle-checkbox"]');

      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          // Show actual Alps OSRM polygon from Geofabrik alps.poly
          // https://download.geofabrik.de/europe/alps.poly
          const alpsPolygon = [
            [46.22925, 15.27237], [46.08419, 14.17168], [45.81157, 13.76037], [45.71865, 13.64227],
            [45.79434, 13.40744], [45.98074, 13.42117], [46.07085, 13.39645], [46.14321, 13.27698],
            [46.12894, 12.98790], [46.06180, 12.63840], [46.00078, 12.55875], [45.95974, 12.50931],
            [45.85176, 12.41867], [45.77231, 12.22641], [45.73686, 12.06436], [45.69755, 11.69357],
            [45.68124, 11.60980], [45.55806, 11.58302], [45.39411, 11.37703], [45.36686, 11.07628],
            [45.38784, 10.96092], [45.41195, 10.67322], [45.44279, 10.35805], [45.47337, 10.16682],
            [45.49817, 10.06691], [45.61164, 9.92340], [45.63229, 9.81697], [45.65101, 9.74075],
            [45.66205, 9.64874], [45.67692, 9.53613], [45.69101, 9.38825], [45.74333, 9.15745],
            [45.78764, 9.06097], [45.78093, 8.90030], [45.62268, 8.65723], [45.53040, 8.43201],
            [45.38965, 8.12714], [45.25942, 7.81952], [44.98423, 7.71515], [44.65596, 7.60803],
            [44.52099, 7.57095], [44.44163, 7.65610], [44.41907, 7.83325], [44.40301, 7.96749],
            [44.40043, 8.01315], [44.40386, 8.06808], [44.40926, 8.18207], [44.37369, 8.33279],
            [44.33465, 8.51578], [44.17236, 8.78082], [43.66390, 8.45672], [43.43298, 7.72339],
            [42.70464, 6.66046], [42.69859, 5.96008], [43.00264, 4.84222], [43.99973, 4.98230],
            [44.29044, 4.92462], [44.72527, 4.87655], [44.95605, 4.99329], [45.36180, 5.48492],
            [45.66013, 5.72113], [46.38839, 5.82413], [46.42555, 6.34323], [46.52958, 6.72638],
            [46.78784, 7.14111], [46.84704, 7.47894], [47.14957, 7.70691], [47.29786, 8.70529],
            [47.35464, 8.80829], [47.52184, 8.88382], [47.70422, 9.82727], [47.97154, 10.84282],
            [47.95728, 12.48630], [48.10468, 13.33603], [48.04596, 13.98697], [48.15051, 14.62417],
            [48.16975, 14.73953], [48.31151, 15.18310], [48.40094, 15.59235], [48.39319, 16.06132],
            [48.38316, 16.27968], [48.29827, 16.52206], [48.25668, 16.55777], [47.69867, 16.60721],
            [47.63810, 16.64429], [47.50050, 16.76239], [47.33138, 16.52756], [46.42011, 15.64419],
            [46.38270, 15.60230], [46.26060, 15.43922], [46.24374, 15.36335], [46.22925, 15.27237]
          ];
          alpsBboxLayer = L.polygon(alpsPolygon, {
            color: "#ff0000",
            weight: 2,
            fill: true,
            fillOpacity: 0.1,
            dashArray: "10, 5"
          }).addTo(map);
          alpsBboxLayer.bindPopup("Geofabrik Alps OSRM Datenabdeckung<br><br>⚠️ München & Ljubljana liegen außerhalb!");
          label.textContent = t('travelTimeInfoHideBbox');
        } else {
          // Hide bbox
          if (alpsBboxLayer) {
            map.removeLayer(alpsBboxLayer);
            alpsBboxLayer = null;
          }
          label.textContent = t('travelTimeInfoShowBbox');
        }
      });

      // Close on Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          closeDialog();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    }

    // Event listener for info buttons (Desktop + Mobile)
    document.getElementById('travel-time-info-btn')?.addEventListener('click', showTravelTimeInfo);
    document.getElementById('bs-travel-time-info-btn')?.addEventListener('click', showTravelTimeInfo);

    // Expose for external access
    window.showTravelTimeInfo = showTravelTimeInfo;
  })();

  // Berechnet Schnee für einen bestimmten Zeitraum
  function getSnowForTimeframe(stableId, hours) {
    const omForecast = openMeteoForecasts[stableId];
    const gsForecast = snowForecasts[stableId];

    // Kurzfrist (24h, 48h): GeoSphere bevorzugen
    // WICHTIG: GeoSphere liefert kumulative Werte (snow_acc), nicht stündliche!
    // Daher nehmen wir den letzten Wert im Zeitraum, nicht die Summe.
    if (hours <= 48 && gsForecast?.forecasts?.length) {
      const forecasts = gsForecast.forecasts.slice(0, hours);
      // Letzten nicht-null Wert im Zeitraum finden (kumulativer Gesamtschnee)
      for (let i = forecasts.length - 1; i >= 0; i--) {
        const snow = forecasts[i].snowfall_cm;
        if (snow != null) {
          return Math.round(snow * 10) / 10;
        }
      }
      return 0;
    }

    // Mittelfrist (3T, 7T): Open-Meteo nutzen
    if (omForecast) {
      if (hours <= 72) return omForecast.snow_3d_cm || 0;
      return omForecast.snow_7d_cm || 0;
    }

    return 0;
  }

  // Holt die Forecast-Daten für die gewählte Location (Berg/Tal/Best)
  // Rückwärtskompatibel mit altem Format (ohne mountain/valley)
  function getLocationForecast(stableId, location) {
    const omForecast = openMeteoForecasts[stableId];
    if (!omForecast) return null;

    // Neues Format: mountain/valley Objekte
    if (omForecast.mountain || omForecast.valley) {
      if (location === 'best') {
        // Beide vorhanden: Maximum zurückgeben
        return { mountain: omForecast.mountain, valley: omForecast.valley };
      }
      return omForecast[location] || omForecast.mountain || omForecast.valley;
    }

    // Altes Format: direkt daily Array (Fallback)
    return omForecast;
  }

  // Berechnet Schnee für einen bestimmten Tag (0 = heute, 1 = morgen, etc.)
  // location: 'mountain', 'valley', oder 'best' (Maximum von beiden)
  function getSnowForDay(stableId, dayIndex, location) {
    location = location || window.weatherFilterState?.location || 'mountain';

    if (location === 'best') {
      const mountainSnow = getSnowForDay(stableId, dayIndex, 'mountain');
      const valleySnow = getSnowForDay(stableId, dayIndex, 'valley');
      return Math.max(mountainSnow, valleySnow);
    }

    const forecast = getLocationForecast(stableId, location);
    if (!forecast || !forecast.daily || !forecast.daily[dayIndex]) return 0;
    return forecast.daily[dayIndex].snowfall_cm || 0;
  }

  // Berechnet kumulativen Schnee von Tag 0 bis dayIndex (inklusive)
  function getSnowCumulative(stableId, dayIndex, location) {
    location = location || window.weatherFilterState?.location || 'mountain';

    if (location === 'best') {
      const mountainSum = getSnowCumulative(stableId, dayIndex, 'mountain');
      const valleySum = getSnowCumulative(stableId, dayIndex, 'valley');
      return Math.max(mountainSum, valleySum);
    }

    const forecast = getLocationForecast(stableId, location);
    if (!forecast || !forecast.daily) return 0;
    let sum = 0;
    for (let i = 0; i <= dayIndex && i < forecast.daily.length; i++) {
      sum += forecast.daily[i].snowfall_cm || 0;
    }
    return Math.round(sum * 10) / 10;
  }

  // Holt Forecast-Daten für einen bestimmten Tag (für Popup)
  function getDailyForecast(stableId, dayIndex, location) {
    location = location || 'mountain';
    const forecast = getLocationForecast(stableId, location);
    if (!forecast || !forecast.daily || !forecast.daily[dayIndex]) return null;
    return forecast.daily[dayIndex];
  }

  // Holt Berg- UND Tal-Forecast für Popup-Anzeige
  function getBothDailyForecasts(stableId, dayIndex) {
    const omForecast = openMeteoForecasts[stableId];
    if (!omForecast) return null;

    // Neues Format
    if (omForecast.mountain || omForecast.valley) {
      return {
        mountain: omForecast.mountain?.daily?.[dayIndex] || null,
        valley: omForecast.valley?.daily?.[dayIndex] || null,
        mountainElevation: omForecast.mountain?.elevation_m,
        valleyElevation: omForecast.valley?.elevation_m
      };
    }

    // Altes Format: nur ein Wert
    return {
      mountain: omForecast.daily?.[dayIndex] || null,
      valley: null
    };
  }

  // WMO Weather Code zu Icon Mapping
  function getWeatherIcon(code) {
    if (code == null) return '';
    // Schnee
    if ([71, 73, 75, 77, 85, 86].includes(code)) return '❄️';
    // Schneeregen
    if ([66, 67].includes(code)) return '🌨️';
    // Regen
    if ([51, 53, 55, 56, 57, 61, 63, 65, 80, 81, 82].includes(code)) return '🌧️';
    // Gewitter
    if ([95, 96, 99].includes(code)) return '⛈️';
    // Nebel
    if ([45, 48].includes(code)) return '🌫️';
    // Bewölkt
    if ([2, 3].includes(code)) return '⛅';
    // Leicht bewölkt
    if (code === 1) return '🌤️';
    // Klar
    if (code === 0) return '☀️';
    // Fallback
    return '☁️';
  }

  // Formatiert Datum für Anzeige (z.B. "Mo 13.")
  function formatShortDate(dateStr) {
    const date = new Date(dateStr);
    const days = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
    return `${days[date.getDay()]} ${date.getDate()}.`;
  }

  // Set of resort names hidden by snow filter (for export)
  window.snowHiddenResorts = new Set();

  // Update-Funktion für Wetter-Anzeige (Canvas-basiert für Performance)
  // Exposed globally so searchFilter can re-apply snow filter after other filters change
  window.updateWeatherDisplay = function updateWeatherDisplay() {
    const state = window.weatherFilterState;

    // Canvas Layer verwenden falls verfügbar
    const useCanvas = window.SnowBadgeCanvas;

    if (useCanvas) {
      useCanvas.clear();
    } else {
      // Fallback: alte DOM-basierte Badges entfernen
      Object.values(snowBadgeMarkers).forEach(m => map.removeLayer(m));
      Object.keys(snowBadgeMarkers).forEach(k => delete snowBadgeMarkers[k]);
    }

    // Clear hidden set at start of each update
    window.snowHiddenResorts.clear();

    if (!state.enabled) {
      // Show all markers (that pass other filters)
      Object.values(resortMarkers).forEach(m => {
        if (m._icon) m._icon.style.display = '';
        if (m._path) m._path.style.display = '';
      });
      if (useCanvas) useCanvas.setEnabled(false);
      if (typeof updateResortCounter === 'function') updateResortCounter();
      console.log('Weather display disabled');
      return;
    }

    if (useCanvas) useCanvas.setEnabled(true);

    let badgeCount = 0;
    let hiddenCount = 0;
    const badgesToAdd = [];

    Object.values(resorts).forEach(r => {
      if (!r.stable_id || !r.lat || !r.lon) return;

      // Single day vs cumulative sum up to day
      const snow = state.cumulative
        ? getSnowCumulative(r.stable_id, state.dayIndex)
        : getSnowForDay(r.stable_id, state.dayIndex);
      const marker = resortMarkers[norm(r.name)];

      // Filter: Min Snow
      if (snow < state.minSnowCm) {
        if (marker) {
          if (marker._icon) marker._icon.style.display = 'none';
          if (marker._path) marker._path.style.display = 'none';
        }
        window.snowHiddenResorts.add(r.name);
        hiddenCount++;
        return;
      }

      // Show marker
      if (marker) {
        if (marker._icon) marker._icon.style.display = '';
        if (marker._path) marker._path.style.display = '';
      }

      // Badge nur ab 5cm anzeigen
      if (snow >= 5) {
        badgesToAdd.push({
          lat: r.lat,
          lon: r.lon,
          snow: snow,
          stableId: r.stable_id
        });
        badgeCount++;
      }
    });

    // Alle Badges auf einmal setzen (effizienter)
    if (useCanvas) {
      useCanvas.setBadges(badgesToAdd);
    } else {
      // Fallback: DOM-basierte Badges (langsam)
      badgesToAdd.forEach(b => {
        const color = getBergfexSnowColor(b.snow);
        const size = getSnowBadgeSize(b.snow);
        const snowText = Math.round(b.snow);

        const dayLabel = state.dayIndex === 0 ? 'Heute' : `+${state.dayIndex}`;
        const modeLabel = state.cumulative ? `Σ bis ${dayLabel}` : dayLabel;
        const badgeHtml = `<div class="snow-badge snow-badge-${size}" style="background:${color}" title="${snowText}cm (${modeLabel})">${snowText}</div>`;
        const iconSize = size === 'large' ? 22 : size === 'medium' ? 18 : 14;
        const icon = L.divIcon({
          html: badgeHtml,
          className: 'snow-badge-wrapper',
          iconSize: [iconSize, iconSize],
          iconAnchor: [-4, iconSize]
        });

        const badge = L.marker([b.lat, b.lon], {
          icon,
          interactive: false,
          pane: 'markerPane'
        }).addTo(map);

        snowBadgeMarkers[b.stableId] = badge;
      });
    }

    const modeInfo = state.cumulative ? `Σ bis Tag ${state.dayIndex}` : `Tag ${state.dayIndex}`;
    console.log(`Weather display: ${badgeCount} badges (canvas: ${!!useCanvas}), ${hiddenCount} hidden (min: ${state.minSnowCm}cm, ${modeInfo})`);

    if (typeof updateResortCounter === 'function') updateResortCounter();
  }

</script>

<div id="mobile-panel-backdrop" aria-hidden="true"></div>
<aside id="mobile-panel" aria-label="Filter und Layer">
    <details class="panel-accordion" open>
    <summary>Layer</summary>
    <div id="panel-layers" class="panel-section"></div>
  </details>

  <details class="panel-accordion">
    <summary>Filter</summary>
    <div id="panel-filters" class="panel-section"></div>
  </details>

  <details class="panel-accordion">
    <summary>Export</summary>
    <div id="panel-export" class="panel-section"></div>
  </details>

  <details class="panel-accordion">
    <summary>GPS</summary>
    <div id="panel-gps" class="panel-section"></div>
  </details>
</aside>

<!-- Bottom Sheet (Mobile Only) -->
<div id="bottom-sheet-backdrop" aria-hidden="true"></div>
<div id="bottom-sheet" role="dialog" aria-label="Filter und Einstellungen" data-state="hidden">
  <!-- Swipe Handle Area -->
  <div class="bs-handle-area" role="button" aria-label="Ziehen zum Erweitern" tabindex="0">
    <div class="bs-handle"></div>
  </div>

  <!-- Peek State Content -->
  <div class="bs-peek-content">
    <span id="bs-resort-counter" class="bs-counter">0 / 0</span>
    <div class="bs-chips" id="bs-filter-chips">
      <!-- Horizontal scrolling filter chips - populated by JS -->
    </div>
  </div>

  <!-- Scrollable Content Area -->
  <div class="bs-content" id="bs-content">
    <!-- Half State: Sliders -->
    <section class="bs-section" id="bs-sliders">
      <h3 class="bs-section-title" data-i18n="travelTimeAndFilter">Fahrzeit & Filter</h3>
      <!-- Startpoint selector -->
      <div class="bs-startpoint-row">
        <select id="bs-home-select" class="control-select"></select>
        <button id="bs-gps-btn" type="button" class="bs-gps-btn" title="GPS">📍</button>
      </div>
      <!-- Travel time slider -->
      <div class="bs-slider-row">
        <label for="bs-time-slider" data-i18n="maxTravelTime">Max. Fahrzeit</label>
        <button type="button" class="travel-time-info-btn" id="bs-travel-time-info-btn" data-i18n-title="travelTimeInfoTitle" title="Fahrzeit-Info">ℹ️</button>
        <span id="bs-time-label" class="bs-slider-value">bis ca. 0h 00m</span>
      </div>
      <input id="bs-time-slider" type="range" min="0" max="100" value="100" />

      <div class="bs-divider"></div>

      <!-- Filter sliders -->
      <div class="bs-slider-row">
        <label for="bs-pistes-slider" data-i18n="minPistes">Min. Pistenkilometer</label>
        <span id="bs-pistes-label" class="bs-slider-value">0 km</span>
      </div>
      <input id="bs-pistes-slider" type="range" min="0" max="300" value="0" step="5" />

      <div class="bs-slider-row">
        <label for="bs-lifts-slider" data-i18n="minLifts">Min. Lifte</label>
        <span id="bs-lifts-label" class="bs-slider-value">0</span>
      </div>
      <input id="bs-lifts-slider" type="range" min="0" max="100" value="0" />

      <div class="bs-slider-row">
        <label for="bs-elevation-slider" data-i18n="minElevation">Min. Höhe</label>
        <span id="bs-elevation-label" class="bs-slider-value">0 m</span>
      </div>
      <input id="bs-elevation-slider" type="range" min="0" max="4000" value="0" step="100" />
    </section>

    <!-- Weather Section -->
    <section class="bs-section" id="bs-weather">
      <h3 class="bs-section-title">❄️ <span data-i18n="snowAndWeather">Schnee & Wetter</span></h3>
      <div class="bs-weather-toggle-row">
        <span data-i18n="snowDisplay">Schnee-Anzeige</span>
        <label class="bs-toggle-switch">
          <input type="checkbox" id="bs-weather-toggle">
          <span class="bs-toggle-slider"></span>
        </label>
      </div>
      <!-- Mode toggle -->
      <div class="bs-mode-row">
        <span data-i18n="mode">Modus:</span>
        <button type="button" class="bs-mode-btn" data-cumulative="false" data-i18n="day">Tag</button>
        <button type="button" class="bs-mode-btn active" data-cumulative="true" data-i18n="sumUntil">Σ bis</button>
      </div>
      <!-- Day buttons -->
      <div class="bs-day-row">
        <button type="button" class="bs-day-btn" data-day="0" data-i18n="todayShort">Heu</button>
        <button type="button" class="bs-day-btn" data-day="1">+1</button>
        <button type="button" class="bs-day-btn" data-day="3">+3</button>
        <button type="button" class="bs-day-btn active" data-day="7">+7</button>
      </div>
      <!-- Snow filter slider -->
      <div class="bs-slider-row">
        <label for="bs-snow-slider" data-i18n="snowForecast">Schnee-Vorhersage</label>
        <span id="bs-snow-label" class="bs-slider-value">≥0 cm</span>
      </div>
      <input id="bs-snow-slider" type="range" min="0" max="100" value="0" step="5" />
    </section>

    <!-- Full State: Additional Filters -->
    <section class="bs-section bs-full-only" id="bs-filters">
      <h3 class="bs-section-title" data-i18n="filter">Filter</h3>
      <div id="bs-filter-content"></div>
    </section>

    <!-- Full State: Layers -->
    <section class="bs-section bs-full-only" id="bs-layers">
      <h3 class="bs-section-title">Layer</h3>
      <div id="bs-layer-content"></div>
    </section>

    <!-- Full State: Settings -->
    <section class="bs-section bs-full-only" id="bs-settings">
      <h3 class="bs-section-title" data-i18n="settings">Einstellungen</h3>
      <div class="bs-filter-group">
        <div class="bs-filter-group-title" data-i18n="language">SPRACHE</div>
        <div class="bs-filter-group-chips">
          <button type="button" class="bs-chip bs-lang-btn" data-lang="de"><svg viewBox="0 0 5 3" width="28" height="17" style="vertical-align:middle;margin-right:6px;border-radius:2px;"><rect width="5" height="1" y="0" fill="#000"/><rect width="5" height="1" y="1" fill="#D00"/><rect width="5" height="1" y="2" fill="#FFCE00"/></svg>Deutsch</button>
          <button type="button" class="bs-chip bs-lang-btn" data-lang="en"><svg viewBox="0 0 60 30" width="28" height="14" style="vertical-align:middle;margin-right:6px;border-radius:2px;"><clipPath id="gb-bs"><rect width="60" height="30"/></clipPath><g clip-path="url(#gb-bs)"><path d="M0,0v30h60V0z" fill="#012169"/><path d="M0,0L60,30M60,0L0,30" stroke="#fff" stroke-width="6"/><path d="M0,0L60,30M60,0L0,30" stroke="#C8102E" stroke-width="4"/><path d="M30,0v30M0,15h60" stroke="#fff" stroke-width="10"/><path d="M30,0v30M0,15h60" stroke="#C8102E" stroke-width="6"/></g></svg>English</button>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
(function initBottomSheet() {
  'use strict';

  const sheet = document.getElementById('bottom-sheet');
  const backdrop = document.getElementById('bottom-sheet-backdrop');
  const handleArea = sheet?.querySelector('.bs-handle-area');

  if (!sheet || !handleArea) return;

  // Media query for mobile detection
  const mq = window.matchMedia('(max-width: 720px)');

  // State management
  const STATES = ['hidden', 'peek', 'half', 'full'];
  const HANDLE_HEIGHT = 32;
  const PEEK_HEIGHT = 72;

  // Get actual sheet height from DOM
  function getSheetHeight() {
    return sheet.offsetHeight || window.innerHeight;
  }

  let currentState = 'hidden';
  let startY = 0;
  let startTranslate = 0;
  let isDragging = false;

  // Calculate translate value for each state
  function getTranslateForState(state) {
    const sheetHeight = getSheetHeight();
    switch (state) {
      case 'hidden': return sheetHeight - HANDLE_HEIGHT; // Only handle visible (44px)
      case 'peek': return sheetHeight - PEEK_HEIGHT;     // Show 72px
      case 'half': return sheetHeight * 0.5;             // Show 50%
      case 'full': return 0;                              // Show everything
      default: return sheetHeight - HANDLE_HEIGHT;
    }
  }

  // Set state
  function setState(newState, animate = true) {
    if (!STATES.includes(newState)) return;

    currentState = newState;
    sheet.dataset.state = newState;

    // Update body class for FAB positioning
    document.body.classList.remove('bs-hidden', 'bs-peek', 'bs-half', 'bs-full');
    document.body.classList.add(`bs-${newState}`);

    // Backdrop visibility
    if (newState === 'full') {
      backdrop.classList.add('active');
    } else {
      backdrop.classList.remove('active');
    }

    // Apply transform
    if (animate) {
      sheet.classList.remove('dragging');
    }
    sheet.style.transform = `translateY(${getTranslateForState(newState)}px)`;
  }

  // Get current translate Y
  function getCurrentTranslateY() {
    const style = window.getComputedStyle(sheet);
    const matrix = new DOMMatrix(style.transform);
    return matrix.m42;
  }

  // Determine next state based on velocity and position
  function snapToNearestState(currentY, velocityY) {
    const sheetHeight = getSheetHeight();
    const currentHeight = sheetHeight - currentY;

    // Velocity thresholds (px/ms)
    const VELOCITY_THRESHOLD = 0.5;

    // If swiping fast, go in that direction
    if (Math.abs(velocityY) > VELOCITY_THRESHOLD) {
      if (velocityY < 0) {
        // Swiping up (expanding)
        if (currentState === 'hidden') return 'peek';
        if (currentState === 'peek') return 'half';
        if (currentState === 'half') return 'full';
        return 'full';
      } else {
        // Swiping down (collapsing)
        if (currentState === 'full') return 'half';
        if (currentState === 'half') return 'peek';
        if (currentState === 'peek') return 'hidden';
        return 'hidden';
      }
    }

    // Calculate heights for each state
    const hiddenHeight = HANDLE_HEIGHT;
    const peekHeight = PEEK_HEIGHT;
    const halfHeight = sheetHeight * 0.5;
    const fullHeight = sheetHeight;

    // Snap to nearest state
    const hiddenDist = Math.abs(currentHeight - hiddenHeight);
    const peekDist = Math.abs(currentHeight - peekHeight);
    const halfDist = Math.abs(currentHeight - halfHeight);
    const fullDist = Math.abs(currentHeight - fullHeight);

    const minDist = Math.min(hiddenDist, peekDist, halfDist, fullDist);

    if (minDist === hiddenDist) return 'hidden';
    if (minDist === peekDist) return 'peek';
    if (minDist === halfDist) return 'half';
    return 'full';
  }

  // Touch handlers
  function onTouchStart(e) {
    if (e.touches.length !== 1) return;

    isDragging = true;
    startY = e.touches[0].clientY;
    startTranslate = getCurrentTranslateY();
    sheet.classList.add('dragging');

    sheet._touchStartTime = Date.now();
    sheet._touchStartY = startY;
  }

  function onTouchMove(e) {
    if (!isDragging) return;

    const currentY = e.touches[0].clientY;
    const deltaY = currentY - startY;
    let newTranslate = startTranslate + deltaY;

    // Clamp to valid range (hidden to full)
    const maxTranslate = getTranslateForState('hidden');
    const minTranslate = getTranslateForState('full');
    newTranslate = Math.max(minTranslate, Math.min(maxTranslate, newTranslate));

    sheet.style.transform = `translateY(${newTranslate}px)`;

    e.preventDefault();
  }

  function onTouchEnd(e) {
    if (!isDragging) return;

    isDragging = false;

    // Calculate velocity
    const endTime = Date.now();
    const endY = e.changedTouches[0].clientY;
    const duration = endTime - (sheet._touchStartTime || endTime);
    const velocityY = duration > 0 ? (endY - (sheet._touchStartY || endY)) / duration : 0;

    const currentTranslate = getCurrentTranslateY();
    const newState = snapToNearestState(currentTranslate, velocityY);

    setState(newState, true);
  }

  // Mouse handlers (for desktop testing)
  function onMouseDown(e) {
    isDragging = true;
    startY = e.clientY;
    startTranslate = getCurrentTranslateY();
    sheet.classList.add('dragging');
    sheet._touchStartTime = Date.now();
    sheet._touchStartY = startY;
    e.preventDefault();
  }

  function onMouseMove(e) {
    if (!isDragging) return;

    const deltaY = e.clientY - startY;
    let newTranslate = startTranslate + deltaY;

    // Clamp to valid range (hidden to full)
    const maxTranslate = getTranslateForState('hidden');
    const minTranslate = getTranslateForState('full');
    newTranslate = Math.max(minTranslate, Math.min(maxTranslate, newTranslate));

    sheet.style.transform = `translateY(${newTranslate}px)`;
  }

  function onMouseUp(e) {
    if (!isDragging) return;

    isDragging = false;

    const endTime = Date.now();
    const duration = endTime - (sheet._touchStartTime || endTime);
    const velocityY = duration > 0 ? (e.clientY - (sheet._touchStartY || e.clientY)) / duration : 0;

    const currentTranslate = getCurrentTranslateY();
    const newState = snapToNearestState(currentTranslate, velocityY);

    setState(newState, true);
  }

  // Keyboard accessibility
  function onKeyDown(e) {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const nextIndex = (STATES.indexOf(currentState) + 1) % STATES.length;
      setState(STATES[nextIndex]);
    } else if (e.key === 'Escape') {
      setState('peek');
    }
  }

  // Bind events to handle area only
  handleArea.addEventListener('touchstart', onTouchStart, { passive: false });
  handleArea.addEventListener('touchmove', onTouchMove, { passive: false });
  handleArea.addEventListener('touchend', onTouchEnd, { passive: true });
  handleArea.addEventListener('mousedown', onMouseDown);
  handleArea.addEventListener('keydown', onKeyDown);

  // Global mouse events for drag
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);

  // Backdrop click closes to hidden
  backdrop.addEventListener('click', () => setState('hidden'));

  // Handle resize - recalculate transform for current state
  let resizeTimer;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      if (!mq.matches) return; // Skip on desktop
      setState(currentState, false); // Recalculate with new sheet height
    }, 100);
  });

  // Expose API globally
  window.bottomSheet = {
    setState,
    getState: () => currentState,
    expand: () => setState('full'),
    collapse: () => setState('peek'),
    toggle: () => setState(currentState === 'peek' ? 'half' : 'peek')
  };

  // Initialize function
  function initializeSheet() {
    setState('hidden', false); // Start with only handle visible
    document.body.classList.add('bs-hidden');
  }

  // Initialize on mobile, and reinitialize when switching to mobile
  if (mq.matches) {
    initializeSheet();
  }

  // Listen for media query changes (e.g., DevTools mobile toggle)
  mq.addEventListener('change', (e) => {
    if (e.matches) {
      initializeSheet();
    } else {
      // Reset when switching to desktop
      document.body.classList.remove('bs-hidden', 'bs-peek', 'bs-half', 'bs-full');
    }
  });
})();
</script>

<script>
(function initBottomSheetContent() {
  'use strict';

  const mq = window.matchMedia('(max-width: 720px)');
  const isMobile = () => mq && mq.matches;

  // Store observers for cleanup (Memory Leak Fix)
  let counterObserver = null;
  let homeSelectorObserver = null;

  // Counter synchronization
  function syncCounter() {
    const bsCounter = document.getElementById('bs-resort-counter');
    const originalCounter = document.getElementById('resort-counter');

    if (bsCounter && originalCounter) {
      bsCounter.textContent = originalCounter.textContent;

      // Disconnect previous observer if exists
      if (counterObserver) {
        counterObserver.disconnect();
      }

      counterObserver = new MutationObserver(() => {
        bsCounter.textContent = originalCounter.textContent;
      });
      counterObserver.observe(originalCounter, { childList: true, characterData: true, subtree: true });
    }
  }

  // Generate filter chips (Event Delegation - listener set up once in setupEventDelegation)
  function updateFilterChips() {
    const chipsContainer = document.getElementById('bs-filter-chips');
    if (!chipsContainer) return;

    const t = window.i18n ? window.i18n.t.bind(window.i18n) : k => k;

    const chips = [
      { id: 'chip-at', label: '🇦🇹', filterId: 'flt-at' },
      { id: 'chip-de', label: '🇩🇪', filterId: 'flt-de' },
      { id: 'chip-ch', label: '🇨🇭', filterId: 'flt-ch' },
      { id: 'chip-it', label: '🇮🇹', filterId: 'flt-it' },
      { id: 'chip-fr', label: '🇫🇷', filterId: 'flt-fr' },
      { id: 'chip-si', label: '🇸🇮', filterId: 'flt-si' },
      { id: 'chip-glacier', label: '❄️', filterId: 'flt-glacier' },
      { id: 'chip-favorites', label: '⭐', filterId: 'flt-favorites' },
      { id: 'chip-visited', label: '✓', filterId: 'flt-visited' },
      { id: 'chip-sct', label: 'SCT', filterId: 'flt-sct' },
      { id: 'chip-ssc', label: 'SSC', filterId: 'flt-ssc' },
    ];

    chipsContainer.innerHTML = chips.map(chip => {
      const sourceEl = document.getElementById(chip.filterId);
      const isActive = sourceEl ? sourceEl.checked : false;
      return `<button class="bs-chip ${isActive ? 'active' : ''}" data-filter="${chip.filterId}">${chip.label}</button>`;
    }).join('');
    // No event listeners here - handled by event delegation
  }

  // Sync slider: Bottom Sheet <-> Original
  function syncSlider(bsId, origId, bsLabelId, origLabelId, formatFn) {
    const bsSlider = document.getElementById(bsId);
    const origSlider = document.getElementById(origId);
    const bsLabel = document.getElementById(bsLabelId);
    const origLabel = origLabelId ? document.getElementById(origLabelId) : null;

    if (!bsSlider || !origSlider) return;

    // Initial sync
    bsSlider.value = origSlider.value;
    bsSlider.max = origSlider.max;
    bsSlider.min = origSlider.min;
    if (bsLabel && origLabel) {
      bsLabel.textContent = origLabel.textContent;
    } else if (bsLabel && formatFn) {
      bsLabel.textContent = formatFn(origSlider.value);
    }

    // BS -> Original
    bsSlider.addEventListener('input', () => {
      origSlider.value = bsSlider.value;
      origSlider.dispatchEvent(new Event('input', { bubbles: true }));
      if (bsLabel && formatFn) {
        bsLabel.textContent = formatFn(bsSlider.value);
      }
    });

    // Original -> BS
    origSlider.addEventListener('input', () => {
      bsSlider.value = origSlider.value;
      if (bsLabel && origLabel) {
        bsLabel.textContent = origLabel.textContent;
      } else if (bsLabel && formatFn) {
        bsLabel.textContent = formatFn(origSlider.value);
      }
    });
  }

  // Sync home selector
  function syncHomeSelector() {
    const bsSelect = document.getElementById('bs-home-select');
    const origSelect = document.getElementById('homeSelectSlider');

    if (!bsSelect || !origSelect) return;

    // Copy options
    bsSelect.innerHTML = origSelect.innerHTML;
    bsSelect.value = origSelect.value;

    bsSelect.addEventListener('change', () => {
      origSelect.value = bsSelect.value;
      origSelect.dispatchEvent(new Event('change', { bubbles: true }));
    });

    // Disconnect previous observer if exists (Memory Leak Fix)
    if (homeSelectorObserver) {
      homeSelectorObserver.disconnect();
    }

    // Observe for new options
    homeSelectorObserver = new MutationObserver(() => {
      bsSelect.innerHTML = origSelect.innerHTML;
      bsSelect.value = origSelect.value;
    });
    homeSelectorObserver.observe(origSelect, { childList: true });
  }

  // Sync weather toggle
  function syncWeatherToggle() {
    const bsToggle = document.getElementById('bs-weather-toggle');
    const origToggle = document.getElementById('weather-toggle');

    if (!bsToggle || !origToggle) return;

    bsToggle.checked = origToggle.checked;

    bsToggle.addEventListener('change', () => {
      origToggle.checked = bsToggle.checked;
      origToggle.dispatchEvent(new Event('change', { bubbles: true }));
    });

    origToggle.addEventListener('change', () => {
      bsToggle.checked = origToggle.checked;
    });
  }

  // Sync weather mode buttons
  function syncWeatherMode() {
    const bsModeBtns = document.querySelectorAll('#bs-weather .bs-mode-btn');
    const origModeBtns = document.querySelectorAll('.weather-box .cumulative-btn:not(.location-btn)');

    bsModeBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        bsModeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const isCumulative = btn.dataset.cumulative === 'true';
        if (window.weatherFilterState) {
          window.weatherFilterState.cumulative = isCumulative;
        }

        // Sync with original buttons
        origModeBtns.forEach(ob => {
          ob.classList.toggle('active', ob.dataset.cumulative === btn.dataset.cumulative);
        });

        if (typeof updateWeatherDisplay === 'function') {
          updateWeatherDisplay();
        }
      });
    });
  }

  // Sync weather day buttons
  function syncWeatherDays() {
    const bsDayBtns = document.querySelectorAll('#bs-weather .bs-day-btn');

    bsDayBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        bsDayBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        const dayIndex = parseInt(btn.dataset.day);
        if (window.weatherFilterState) {
          window.weatherFilterState.dayIndex = dayIndex;
        }

        if (typeof updateWeatherDisplay === 'function') {
          updateWeatherDisplay();
        }
      });
    });
  }

  // Sync snow slider
  function syncSnowSlider() {
    const bsSlider = document.getElementById('bs-snow-slider');
    const bsLabel = document.getElementById('bs-snow-label');
    const origSlider = document.getElementById('snow-min-slider');

    if (!bsSlider) return;

    if (origSlider) {
      bsSlider.value = origSlider.value;
    }

    bsSlider.addEventListener('input', () => {
      const val = parseInt(bsSlider.value);
      if (bsLabel) bsLabel.textContent = `≥${val} cm`;

      if (window.weatherFilterState) {
        window.weatherFilterState.minSnowCm = val;
      }
      if (origSlider) {
        origSlider.value = val;
        origSlider.dispatchEvent(new Event('input', { bubbles: true }));
      }
      if (typeof updateWeatherDisplay === 'function') {
        updateWeatherDisplay();
      }
    });
  }

  // GPS button in bottom sheet
  function setupGpsButton() {
    const bsGpsBtn = document.getElementById('bs-gps-btn');
    const origGpsBtn = document.getElementById('btn-gps-slider');

    if (bsGpsBtn && origGpsBtn) {
      bsGpsBtn.addEventListener('click', () => {
        origGpsBtn.click();
      });
    }
  }

  // Build filter chips for full state (instead of copying checkboxes)
  function populateFilters() {
    const bsFilterContent = document.getElementById('bs-filter-content');
    if (!bsFilterContent) return;

    const t = window.i18n ? window.i18n.t.bind(window.i18n) : k => k;

    // Define filter groups with chips
    const filterGroups = [
      {
        title: t('highlight'),
        chips: [
          { id: 'flt-favorites', label: '⭐ ' + t('favorites') },
          { id: 'flt-visited', label: '✓ ' + t('visited') },
          { id: 'flt-glacier', label: '❄️ ' + t('glacier') },
          { id: 'flt-verbunde', label: '🔷 ' + t('verbunde') },
        ]
      },
      {
        title: t('passes') || 'Skipässe',
        chips: [
          { id: 'flt-sct', label: 'SCT' },
          { id: 'flt-ssc', label: 'SSC' },
          { id: 'flt-both', label: t('bothPasses') },
        ],
        includeDropdown: true
      },
      {
        title: t('other'),
        chips: [
          { id: 'flt-only-highlights', label: t('onlyHighlights') },
          { id: 'flt-dark', label: '🌙 ' + t('darkMode') },
        ]
      }
    ];

    let html = '';

    filterGroups.forEach(group => {
      html += `<div class="bs-filter-group">`;
      html += `<div class="bs-filter-group-title">${group.title}</div>`;
      html += `<div class="bs-filter-group-chips">`;

      group.chips.forEach(chip => {
        const origEl = document.getElementById(chip.id);
        const isActive = origEl ? origEl.checked : false;
        html += `<button type="button" class="bs-chip ${isActive ? 'active' : ''}" data-filter="${chip.id}">${chip.label}</button>`;
      });

      html += `</div>`;

      // Add passes dropdown if needed
      if (group.includeDropdown) {
        const origDropdown = document.getElementById('flt-pass-dropdown');
        if (origDropdown) {
          html += `<div class="bs-dropdown-row">`;
          html += `<select id="bs-pass-dropdown" class="bs-dropdown">${origDropdown.innerHTML}</select>`;
          html += `</div>`;
        }
      }

      html += `</div>`;
    });

    bsFilterContent.innerHTML = html;
    // No event listeners here - handled by event delegation

    // Sync passes dropdown value (listener is set up once in setupEventDelegation)
    const bsDropdown = document.getElementById('bs-pass-dropdown');
    const origDropdown = document.getElementById('flt-pass-dropdown');
    if (bsDropdown && origDropdown) {
      bsDropdown.value = origDropdown.value;
    }
  }

  // Build layer chips for full state
  // Exposed globally for corridor overlay to refresh after async load
  function populateLayers() {
    const bsLayerContent = document.getElementById('bs-layer-content');
    const origLayerControl = document.querySelector('.leaflet-control-layers-list');

    if (!bsLayerContent || !origLayerControl) return;

    // Get basemap radios and overlay checkboxes (fresh query each time)
    const getBaseInputs = () => origLayerControl.querySelectorAll('.leaflet-control-layers-base input[type="radio"]');
    const getOverlayInputs = () => origLayerControl.querySelectorAll('.leaflet-control-layers-overlays input[type="checkbox"]');

    const baseInputs = getBaseInputs();
    const overlayInputs = getOverlayInputs();

    let html = '';

    // Basemap chips (radio-like: only one active)
    if (baseInputs.length > 0) {
      html += `<div class="bs-filter-group">`;
      html += `<div class="bs-filter-group-title">KARTE</div>`;
      html += `<div class="bs-filter-group-chips">`;

      baseInputs.forEach((input, index) => {
        const label = input.closest('label') || input.parentElement;
        const labelText = label ? label.textContent.trim() : `Layer ${index + 1}`;
        const isActive = input.checked;
        html += `<button type="button" class="bs-chip bs-layer-base ${isActive ? 'active' : ''}" data-layer-index="${index}">${labelText}</button>`;
      });

      html += `</div></div>`;
    }

    // Overlay chips (checkbox-like: multiple can be active)
    if (overlayInputs.length > 0) {
      html += `<div class="bs-filter-group">`;
      html += `<div class="bs-filter-group-title">OVERLAYS</div>`;
      html += `<div class="bs-filter-group-chips">`;

      overlayInputs.forEach((input, index) => {
        const label = input.closest('label') || input.parentElement;
        const labelText = label ? label.textContent.trim() : `Overlay ${index + 1}`;
        const isActive = input.checked;
        html += `<button type="button" class="bs-chip bs-layer-overlay ${isActive ? 'active' : ''}" data-overlay-index="${index}">${labelText}</button>`;
      });

      html += `</div></div>`;
    }

    bsLayerContent.innerHTML = html;
    // No event listeners here - handled by event delegation
  }

  // Setup language switcher
  function setupLanguageSwitcher() {
    const langBtns = document.querySelectorAll('.bs-lang-btn');
    if (!langBtns.length) return;

    // Get current language
    const currentLang = window.i18n ? window.i18n.currentLang : 'de';

    // Set initial active state
    langBtns.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.lang === currentLang);
    });

    // Click handlers
    langBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const newLang = btn.dataset.lang;

        // Update i18n
        if (window.i18n && window.i18n.setLang) {
          window.i18n.setLang(newLang);
        }

        // Update active states
        langBtns.forEach(b => {
          b.classList.toggle('active', b.dataset.lang === newLang);
        });

        // Refresh filter chips and filter content with new translations
        updateFilterChips();
        populateFilters();
      });
    });
  }

  // Event Delegation Setup (Memory Leak Fix - listeners are set up ONCE)
  let eventDelegationInitialized = false;
  function setupEventDelegation() {
    if (eventDelegationInitialized) return;
    eventDelegationInitialized = true;

    const origLayerControl = document.querySelector('.leaflet-control-layers-list');
    const getBaseInputs = () => origLayerControl?.querySelectorAll('.leaflet-control-layers-base input[type="radio"]') || [];
    const getOverlayInputs = () => origLayerControl?.querySelectorAll('.leaflet-control-layers-overlays input[type="checkbox"]') || [];

    // Delegate: Filter chips container (peek state)
    const chipsContainer = document.getElementById('bs-filter-chips');
    if (chipsContainer) {
      chipsContainer.addEventListener('click', (e) => {
        const chip = e.target.closest('.bs-chip');
        if (!chip) return;
        const filterId = chip.dataset.filter;
        const sourceEl = document.getElementById(filterId);
        if (sourceEl) {
          sourceEl.checked = !sourceEl.checked;
          sourceEl.dispatchEvent(new Event('change', { bubbles: true }));
          chip.classList.toggle('active', sourceEl.checked);
        }
      });
    }

    // Delegate: Filter content (full state)
    const bsFilterContent = document.getElementById('bs-filter-content');
    if (bsFilterContent) {
      bsFilterContent.addEventListener('click', (e) => {
        const chip = e.target.closest('.bs-chip');
        if (!chip) return;
        const filterId = chip.dataset.filter;
        const origEl = document.getElementById(filterId);
        if (origEl) {
          origEl.checked = !origEl.checked;
          origEl.dispatchEvent(new Event('change', { bubbles: true }));
          chip.classList.toggle('active', origEl.checked);
          updateFilterChips(); // Update peek chips too
        }
      });

      // Delegate: Passes dropdown
      bsFilterContent.addEventListener('change', (e) => {
        if (e.target.id === 'bs-pass-dropdown') {
          const origDropdown = document.getElementById('flt-pass-dropdown');
          if (origDropdown) {
            origDropdown.value = e.target.value;
            origDropdown.dispatchEvent(new Event('change', { bubbles: true }));
          }
        }
      });
    }

    // Delegate: Layer content
    const bsLayerContent = document.getElementById('bs-layer-content');
    if (bsLayerContent) {
      bsLayerContent.addEventListener('click', (e) => {
        const chip = e.target.closest('.bs-chip');
        if (!chip) return;

        // Basemap chips (radio behavior)
        if (chip.classList.contains('bs-layer-base')) {
          const index = parseInt(chip.dataset.layerIndex);
          const currentInputs = getBaseInputs();
          const origInput = currentInputs[index];
          if (origInput && !origInput.checked) {
            origInput.click();
            // Update all basemap chips
            bsLayerContent.querySelectorAll('.bs-layer-base').forEach((c, i) => {
              c.classList.toggle('active', i === index);
            });
          }
        }

        // Overlay chips (checkbox behavior)
        if (chip.classList.contains('bs-layer-overlay')) {
          const index = parseInt(chip.dataset.overlayIndex);
          const currentInputs = getOverlayInputs();
          const origInput = currentInputs[index];
          if (origInput) {
            origInput.click();
            chip.classList.toggle('active', origInput.checked);
          }
        }
      });
    }
  }

  // Initialize
  function init() {
    if (!isMobile()) return;

    syncCounter();

    // Wait for filter controls to be created
    const waitForControls = setInterval(() => {
      const filterBox = document.querySelector('.filter-box .panel-content');
      const homeSelect = document.getElementById('homeSelectSlider');
      const timeSlider = document.getElementById('time-slider');

      if (filterBox && homeSelect && timeSlider) {
        clearInterval(waitForControls);

        // Setup event delegation ONCE before populating
        setupEventDelegation();

        updateFilterChips();
        syncHomeSelector();
        setupGpsButton();

        // Sync sliders
        syncSlider('bs-time-slider', 'time-slider', 'bs-time-label', 'time-slider-label');
        syncSlider('bs-pistes-slider', 'pistes-slider', 'bs-pistes-label', null, v => `${v} km`);
        syncSlider('bs-lifts-slider', 'lifts-slider', 'bs-lifts-label', null, v => v);
        syncSlider('bs-elevation-slider', 'elevation-slider', 'bs-elevation-label', null, v => `${v} m`);

        syncWeatherToggle();
        syncWeatherMode();
        syncWeatherDays();
        syncSnowSlider();

        populateFilters();

        // Layer control might load later
        setTimeout(populateLayers, 500);

        // Expose populateLayers globally for corridor overlay refresh
        window.populateBottomSheetLayers = populateLayers;

        // Setup language switcher
        setupLanguageSwitcher();

        // Update chips when filters change
        document.addEventListener('change', (e) => {
          if (e.target.id && e.target.id.startsWith('flt-')) {
            updateFilterChips();
          }
        });

        // Sync Bottom Sheet pass dropdown when desktop dropdown is populated
        window.addEventListener('pass-dropdown-populated', () => {
          const bsDropdown = document.getElementById('bs-pass-dropdown');
          const origDropdown = document.getElementById('flt-pass-dropdown');
          if (bsDropdown && origDropdown) {
            bsDropdown.innerHTML = origDropdown.innerHTML;
            bsDropdown.value = origDropdown.value;
          }
        });

        // Bind info button click handler (element exists now)
        const bsTravelInfoBtn = document.getElementById('bs-travel-time-info-btn');
        if (bsTravelInfoBtn && window.showTravelTimeInfo) {
          bsTravelInfoBtn.addEventListener('click', window.showTravelTimeInfo);
        }
      }
    }, 200);

    // Timeout after 10 seconds
    setTimeout(() => clearInterval(waitForControls), 10000);
  }

  // Run after everything is loaded
  if (document.readyState === 'complete') {
    setTimeout(init, 100);
  } else {
    window.addEventListener('load', () => setTimeout(init, 100));
  }
})();
</script>

<script>
  (function initMobilePanel(){
    const btn = document.getElementById('mobile-panel-toggle');
    const backdrop = document.getElementById('mobile-panel-backdrop');
    const panel = document.getElementById('mobile-panel');
    const panelLayers = document.getElementById('panel-layers');
    const panelFilters = document.getElementById('panel-filters');
    const panelExport = document.getElementById('panel-export');
    const panelGps = document.getElementById('panel-gps');
    if (!btn || !backdrop || !panel || !panelLayers || !panelFilters || !panelExport) return;

    const mq = window.matchMedia('(max-width: 720px)');
    const isMobile = () => mq && mq.matches;

    const openPanel = () => {
      document.body.classList.add('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'true');
      backdrop.setAttribute('aria-hidden','false');
    };
    const closePanel = () => {
      document.body.classList.remove('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'false');
      backdrop.setAttribute('aria-hidden','true');
    };

    btn.addEventListener('click', () => {
      document.body.classList.contains('mobile-panel-open') ? closePanel() : openPanel();
    });
    backdrop.addEventListener('click', closePanel);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePanel(); });

    function ensureDesktopStack(){
      const corner = document.querySelector('.leaflet-top.leaflet-right');
      if (!corner) return null;
      let stack = document.getElementById('desktop-control-stack');
      if (!stack) {
        stack = document.createElement('div');
        stack.id = 'desktop-control-stack';
        stack.className = 'desktop-control-stack';
        corner.prepend(stack);
      }
      return stack;
    }

    function placeControls(){
      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');
      const gpsBox = document.querySelector('.gps-box');

      if (isMobile()) {
        if (layers && layers.parentNode !== panelLayers) panelLayers.appendChild(layers);
        if (filters && filters.parentNode !== panelFilters) panelFilters.appendChild(filters);
        if (exportBox && exportBox.parentNode !== panelExport) panelExport.appendChild(exportBox);
        if (gpsBox && panelGps && gpsBox.parentNode !== panelGps) panelGps.appendChild(gpsBox);
      } else {
        const stack = ensureDesktopStack();
        if (!stack) return;
        if (layers && layers.parentNode !== stack) stack.appendChild(layers);
        if (filters && filters.parentNode !== stack) stack.appendChild(filters);
        if (exportBox && exportBox.parentNode !== stack) stack.appendChild(exportBox);
        if (gpsBox && gpsBox.parentNode !== stack) stack.appendChild(gpsBox);
        closePanel(); // ensure panel isn't stuck open when resizing to desktop
      }
    }

    // Controls are created after map init -> retry a few times
    let tries = 0;
    const timer = setInterval(() => {
      placeControls();
      tries += 1;

      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');
      const gpsBox = document.querySelector('.gps-box');
      if ((layers && filters && exportBox && gpsBox) || tries > 50) clearInterval(timer);
    }, 200);

    window.addEventListener('resize', () => placeControls());
    if (mq && mq.addEventListener) mq.addEventListener('change', () => placeControls());
  })();
</script>

</body>
</html>
