<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Ski-P√§sse: Snow Card Tirol & SuperSkiCard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  
  <link rel="icon" href="favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="favicon-32.png" sizes="32x32">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">


  <style>
    
/* --- Unified Control Cards (Layer / Filter / Export) --- */
:root{
  --panel-bg: #ffffff;
  --panel-border: rgba(0,0,0,0.18);
  --panel-radius: 14px;
  --panel-shadow: 0 8px 22px rgba(0,0,0,0.16);
  --panel-pad: 10px 12px;
  --panel-title-size: 13px;
  --panel-title-weight: 700;
  --panel-muted: rgba(0,0,0,0.62);
  --control-gap: 10px;
}

.panel-card{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  box-sizing: border-box;
}

.panel-title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

.panel-group-title{
  font-size: 11px;
  font-weight: 800;
  letter-spacing: .02em;
  text-transform: uppercase;
  color: var(--panel-muted);
  margin: 10px 0 6px 0;
}

.panel-card label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
  user-select:none;
}
.panel-card input[type="checkbox"],
.panel-card input[type="radio"]{
  margin:0;
}

/* Desktop: rechte Control-Spalte sauber stapeln */
.leaflet-top.leaflet-right{
  display:flex;
  flex-direction:column;
  gap: var(--control-gap);
}
.leaflet-top.leaflet-right .leaflet-control{
  margin: 0 !important; /* gap regelt Abstand */
}

/* Stack-Reihenfolge + Scroll, damit auf Desktop keine Controls "verschwinden" */
.leaflet-top.leaflet-right{
  max-height: calc(100% - 12px);
  overflow-y: auto;
  padding-right: 2px;
}
.leaflet-top.leaflet-right .leaflet-control-layers{ order: 1; }
.leaflet-top.leaflet-right .filter-box.leaflet-control{ order: 2; }
.leaflet-top.leaflet-right .export-box.leaflet-control{ order: 3; }

/* Filter-Labels sauber untereinander */
.filter-box label{
  display:flex;
  align-items:center;
  gap:8px;
  width:100%;
  margin: 6px 0;
}
.filter-box input[type="checkbox"]{ margin:0; }

/* Export-Hinweis komplett ausblenden (falls vorhanden) */
.export-box .hint{ display:none; }

/* Export-Buttons etwas kompakter */
.export-box button{
  height: 32px;
  font-size: 12px;
  border-radius: 10px;
  margin-top: 6px;
}

/* --- Filter-Box --- */
.filter-box.leaflet-control,
.export-box.leaflet-control,
.leaflet-control-layers{
  width: 210px;
}
.filter-box.leaflet-control,
.export-box.leaflet-control{
  background: var(--panel-bg);
  padding: var(--panel-pad);
  border: 1px solid var(--panel-border);
  border-radius: var(--panel-radius);
  box-shadow: var(--panel-shadow);
  font-size: 13px;
  line-height: 1.35;
  box-sizing:border-box;
  width: 210px;
}
.filter-box .title,
.export-box .title{
  font-weight: var(--panel-title-weight);
  font-size: var(--panel-title-size);
  margin: 0 0 8px 0;
  color: rgba(0,0,0,0.86);
}

/* Filter-Gruppen√ºberschriften */
.filter-box .filter-group-title{
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.03em;
  color: rgba(0,0,0,0.5);
  margin: 12px 0 6px 0;
  padding-top: 8px;
  border-top: 1px solid rgba(0,0,0,0.1);
}
.filter-box .filter-group-title:first-of-type{
  margin-top: 4px;
  padding-top: 0;
  border-top: none;
}

/* Leaflet Layers Control wie Panel-Card */
.leaflet-control-layers{
  width: 210px;
  background: var(--panel-bg) !important;
  padding: var(--panel-pad) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--panel-radius) !important;
  box-shadow: var(--panel-shadow) !important;
}
.leaflet-control-layers .leaflet-control-layers-separator{
  border-top: 1px solid rgba(0,0,0,0.12);
  margin: 8px 0;
}
.leaflet-control-layers label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.leaflet-control-layers input{
  margin: 0;
}

/* Export Buttons etwas "ruhiger" */
.export-box button{
  width:100%;
  height: 36px;
  padding: 0 10px;
  margin: 6px 0 0 0;
  font-size: 13px;
  font-weight: 600;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,0.35);
  background:#f3f3f3;
  cursor:pointer;
}
.export-box button:hover{ background:#e9e9e9; }
.export-box .hint{
  margin-top:8px;
  font-size:11px;
  color: rgba(0,0,0,0.68);
}
html, body {
      height: 100%;
      margin: 0;
    }
    :root { --app-h: 100dvh; }
    @supports not (height: 100dvh) { :root { --app-h: 100vh; } }
    #map {
      height: var(--app-h);
      width: 100vw;
    }

    .legend-box {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 9999;
      background: white;
      padding: 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
    }
.search-box {
  position: fixed !important;
  top: 10px;
  left: 50px;
  z-index: 10000;
  background: white;
  padding: 10px 10px 12px 10px;
  width: 390px;
  max-width: calc(100vw - 40px);
  box-sizing: border-box;
  border: 1px solid #888;
  font-size: 13px;
  line-height: 1.35;
  box-shadow: 0 8px 22px rgba(0,0,0,0.16);
  border-radius: 12px;
}
.search-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
.search-box input {
  width: 100%;
  height: 36px;
  padding: 8px 10px;
  font-size: 14px;
  border: 1px solid #bbb;
  border-radius: 10px;
  box-sizing: border-box;
  outline: none;
}
.search-box input:focus {
  border-color: #777;
}
.search-row {
  display: flex;
  gap: 8px;
  align-items: stretch;
  flex-wrap: nowrap;
}
.search-row input {
      flex: 1 1 auto;
      min-width: 0;
    }
#search-btn {
  flex: 0 0 auto;
  height: 36px;
  padding: 0 12px;
  font-size: 13px;
  font-weight: 600;
  border: 1px solid #666;
  border-radius: 10px;
  background: #f0f0f0;
  cursor: pointer;
  white-space: nowrap;
}
#search-btn:hover{ background:#e0e0e0; }
#clear-verbund-btn {
  flex: 0 0 auto;
}
#clear-verbund-btn:disabled {
  opacity: 0.55;
  cursor: default;
}
#clear-verbund-btn:disabled {
      opacity: 0.55;
      cursor: default;
    }
.slider-box {
      position: fixed;
      bottom: 110px;        /* sitzt √ºber der Legende */
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px); /* mobil: passt sich an */
      box-sizing: border-box;
    }

    .slider-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .slider-box input[type="range"] {
      width: 100%;
    }

    /* Fahrzeit-Slider mit Farbverlauf (passend zur Corridor-Skala) */
    #time-slider {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      outline: none;
      /* Gradient: gr√ºn (0-1h) ‚Üí hellgr√ºn (1-2h) ‚Üí gelb (2-3h) ‚Üí orange (3-4h) ‚Üí rot (4h+) */
      /* Bei 6h max: 1h=17%, 2h=33%, 3h=50%, 4h=67% */
      background: linear-gradient(to right,
        #1a9850 0%,      /* gr√ºn - Start */
        #1a9850 15%,     /* gr√ºn - bis ~1h */
        #91cf60 25%,     /* hellgr√ºn - ~1.5h */
        #fee08b 40%,     /* gelb - ~2.5h */
        #fc8d59 55%,     /* orange - ~3.5h */
        #d73027 75%,     /* rot - ~4.5h */
        #d73027 100%     /* rot - Ende */
      );
    }

    /* Slider-Thumb (der Anfasser) */
    #time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    #time-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    /* Firefox Track-Styling */
    #time-slider::-moz-range-track {
      height: 8px;
      border-radius: 4px;
      background: linear-gradient(to right,
        #1a9850 0%, #1a9850 15%, #91cf60 25%,
        #fee08b 40%, #fc8d59 55%, #d73027 75%, #d73027 100%
      );
    }
    .slider-box .time-label {
      margin-top: 4px;
      font-size: 12px;
      color: #444;
    }

    /* Box f√ºr Startadresse & Button */
    .home-box {
      position: fixed;
      bottom: 120px;           
      left: 20px;
      z-index: 10000;
      background: white;
      padding: 8px 10px;
      border: 1px solid #888;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
      max-width: 260px;
      width: calc(100vw - 40px);
      box-sizing: border-box;
    }

    /* Desktop: Home-Box ausblenden (Dropdown sitzt oben im Slider) */
    @media (min-width: 721px){
      .home-box{ display:none !important; }
    }

    .home-box label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
    }
    .home-box input {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border: 1px solid #bbb;
      border-radius: 3px;
      box-sizing: border-box;
      margin-bottom: 6px;
    }
    .home-box button {
      width: 100%;
      padding: 4px 6px;
      font-size: 13px;
      border-radius: 3px;
      border: 1px solid #666;
      background: #f0f0f0;
      cursor: pointer;
    }
    .home-box button:hover {
      background: #e0e0e0;
    }

    /* Counter unten rechts */
    .counter-box {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      background: white;
      padding: 6px 10px;
      border: 1px solid #888;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      border-radius: 4px;
    }
  
    /* Responsive: Mobile Layout */
    @media (max-width: 720px) {
      /* --- Strong overrides for mobile topbar layout --- */
      .search-box .search-row{ flex-wrap: nowrap !important; }
      #resort-search{ min-width: 0 !important; }
      #search-btn{ min-width: 56px; }
      #clear-verbund-btn,
      #mobile-panel-toggle{ width: 44px; min-width: 44px; height: 44px; padding: 0 !important; }
      #clear-verbund-btn{ border-radius: 10px !important; }

      /* Zoom: unten rechts √ºber dem Counter */
      .leaflet-control-zoom{
        position: fixed !important;
        right: 12px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 64px) !important;
        left: auto !important;
        top: auto !important;
        z-index: 4000 !important;
      }
      .leaflet-control-zoom a{
        width: 40px;
        height: 40px;
        line-height: 40px;
        font-size: 20px;
      }

      /* Auf Mobile aufr√§umen */
      .home-box { display: none !important; }               /* Startadresse ausblenden */
      /* Export ausblenden */
      .legend-box { display: none !important; }             /* optional: Legende ausblenden */

      /* Suchleiste oben als "Card" */
      .search-box label{ display:none; }

      /* Top-Bar: Input + Go + X + Men√º in EINER Zeile */
      #search-btn{
        height: 44px;
        padding: 0 10px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
        min-width: 56px;
        flex: 0 0 auto !important;
      }
      #clear-verbund-btn,
      #mobile-panel-toggle{
        width: 44px;
        min-width: 44px;
        height: 44px;
        padding: 0 !important;
        flex: 0 0 auto !important;
      }
      /* falls irgendwo noch alte Flex-Regeln greifen */
      #clear-verbund-btn{ margin-left: 0 !important; }

      .search-box {
        top: calc(env(safe-area-inset-top, 0px) + 8px) !important;
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        max-width: none !important;
        padding: 8px 10px 10px 10px !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        backdrop-filter: blur(8px);
        background: rgba(255,255,255,0.92) !important;
      }
      .search-box label {
        display: block;
        font-size: 14px !important;
        margin-bottom: 6px !important;
      }

      .search-row { gap: 8px !important; flex-wrap: wrap !important; }

      #resort-search {
        flex: 1 1 220px !important;
        min-width: 180px;
        height: 44px;
        padding: 10px 12px !important;
        font-size: 16px !important; /* verhindert iOS auto-zoom */
        border-radius: 10px !important;
      }

      #search-btn,
      #clear-verbund-btn {
        height: 44px;
        padding: 0 12px !important;
        font-size: 14px !important;
        border-radius: 10px !important;
      }
/* Leaflet Controls nicht unter der Suchbox verstecken */
      .leaflet-top.leaflet-right {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        right: 12px !important;
        z-index: 2000;
      }
      .leaflet-top.leaflet-left {
        top: calc(env(safe-area-inset-top, 0px) + 118px) !important;
        left: 8px !important;
        z-index: 2000;
      }

      /* Filter-Box: scrollf√§hig und touch-freundlich */
      .filter-box.leaflet-control {
        width: min(52vw, 260px) !important;
        max-height: 48vh;
        overflow: auto;
        border-radius: 14px;
      }
      .filter-box label { padding: 8px 2px; }
      .filter-box input[type="checkbox"] { width: 20px; height: 20px; }

      /* Layer-Control: komfortabler auf Touch */
      .leaflet-control-layers {
        width: min(52vw, 260px) !important;
        border-radius: 14px;
        max-height: 48vh;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .leaflet-control-layers-toggle { width: 44px; height: 44px; }
      .leaflet-control-layers label { padding: 8px 2px; }

      /* Slider unten als "Bottom Bar" */
      .slider-box {
        left: 8px !important;
        right: 12px !important;
        width: auto !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 10px) !important;
        border-radius: 14px !important;
        box-shadow: 0 10px 25px rgba(0,0,0,0.18) !important;
        background: rgba(255,255,255,0.92) !important;
        backdrop-filter: blur(8px);
        transition: transform 0.3s ease;
      }

      /* Toggle-Button f√ºr mobile Slider-Box */
      .slider-box-toggle {
        display: flex !important;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 28px;
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
        margin: -8px 0 4px 0;
      }
      .slider-box-toggle .toggle-icon {
        font-size: 14px;
        color: #666;
        transition: transform 0.3s ease;
      }
      .slider-box.collapsed .toggle-icon {
        transform: rotate(180deg);
      }
      .slider-box.collapsed .slider-box-content {
        display: none;
      }
      .slider-box.collapsed {
        padding: 4px 12px !important;
      }

      /* Counter √ºber dem Slider, damit nichts √ºberlappt */
      .counter-box {
        right: 12px !important;
        bottom: calc(env(safe-area-inset-bottom, 0px) + 12px) !important;
        border-radius: 12px !important;
      }
    }

    /* Layer-Control: nie "abschneiden" und scrollbar machen */
    .leaflet-top.leaflet-right { z-index: 2000; }
    .leaflet-control-layers { max-height: 70vh; overflow-y: auto; overflow-x: hidden; }


    /* A11y helpers */
    .sr-only{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }
.icon-btn{
  width:36px;
  height:36px;
  border:1px solid #666;
  border-radius:10px;
  background:#f0f0f0;
  cursor:pointer;
  font-size:16px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:0;
  flex: 0 0 auto;
}
.icon-btn:hover{ background:#e0e0e0; }

    /* Button text variants */
    #clear-verbund-btn .btn-short{ display:none; }
    #clear-verbund-btn .btn-full{ display:inline; }

    /* Mobile Slide-In Panel (Filter + Layer) */
    #mobile-panel-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
      z-index: 3500;
    }
    #mobile-panel{
      position: fixed;
      top: var(--search-bottom, 76px);
      right: 0;
      height: calc(100dvh - var(--search-bottom, 76px));
      width: min(84vw, 340px);
      background: rgba(255,255,255,0.96);
      backdrop-filter: blur(10px);
      box-shadow: -12px 0 28px rgba(0,0,0,0.22);
      transform: translateX(102%);
      transition: transform .22s ease;
      z-index: 3600;
      padding: 14px 12px calc(env(safe-area-inset-bottom, 0px) + 12px) 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Controls im Mobile-Panel sollen volle Breite nutzen */
    #mobile-panel .leaflet-control,
    #mobile-panel .leaflet-control-layers,
    #mobile-panel .filter-box.leaflet-control{
      width: 100% !important;
      max-width: none !important;
    }
    #mobile-panel .leaflet-control-layers-list{
      margin: 0 !important;
    }
    #mobile-panel h3{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: .85;
    }
    #mobile-panel .panel-section{
      overflow: auto;
      border-radius: 14px;
    }
    body.mobile-panel-open #mobile-panel-backdrop{
      opacity: 1;
      pointer-events: auto;
    }
    body.mobile-panel-open #mobile-panel{
      transform: translateX(0);
    }
    @media (min-width: 721px){
      #mobile-panel, #mobile-panel-backdrop, #mobile-panel-toggle{ display:none !important; }
    }

.control-select {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(0,0,0,.2);
  background: white;
}




/* --- Fix: Legacy-Startpunkt-Box ausblenden (falls sie noch existiert) --- */
#homeSelectorBox,
.homeSelectorBox,
.leaflet-control.home-selector,
.leaflet-control.homeSelector {
  display: none !important;
}

/* --- Fix: Seite nicht scrollbar (verhindert wei√üen Leerraum unten auf Mobile) --- */
html, body {
  overflow: hidden;
}

/* --- Slider-Box wirklich als Overlay (nicht im Dokumentfluss) --- */
.slider-box {
  position: fixed !important;
  left: 20px;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
}

/* Toggle-Button nur auf Mobile anzeigen */
.slider-box-toggle {
  display: none;
}

/* Mobile: etwas kompakter, damit nichts √ºberlappt */
@media (max-width: 640px){
  .slider-box{
    left: 12px;
    bottom: calc(12px + env(safe-area-inset-bottom, 0px));
    max-width: min(320px, calc(100vw - 24px));
    width: calc(100vw - 24px);
  }
}

/* Startpunkt (Dropdown) oberhalb des Sliders */
.startpoint-row{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:6px;
}
.startpoint-row .control-select{
  flex:1;
}
.gps-btn{
  padding:4px 8px;
  font-size:14px;
  border:1px solid #888;
  border-radius:4px;
  background:#f5f5f5;
  cursor:pointer;
  line-height:1;
}
.gps-btn:hover{
  background:#e8e8e8;
}
.gps-btn:disabled{
  opacity:0.6;
  cursor:wait;
}
.startpoint-input-row{
  display:flex;
  flex-direction:row;
  align-items:center;
  gap:6px;
  margin-top:6px;
}
.startpoint-input{
  flex:1;
  padding:4px 6px;
  font-size:12px;
  border:1px solid #aaa;
  border-radius:4px;
  min-width:0;
}
.calc-btn{
  padding:4px 8px;
  font-size:12px;
  border:1px solid #888;
  border-radius:4px;
  background:#f5f5f5;
  cursor:pointer;
  line-height:1;
}
.calc-btn:hover{
  background:#e8e8e8;
}
.startpoint-title{
  font-weight:600;
  font-size:12px;
  opacity:.9;
}
.slider-sep{
  height:1px;
  background: rgba(0,0,0,.12);
  margin: 10px 0 8px 0;
}


/* Label + Fahrzeit in einer Zeile */
.time-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:6px;
}
.time-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
}
.time-value{
  font-weight:700;
  color:#1a73e8;
  white-space:nowrap;
}

/* Neue Filter-Slider Zeilen */
.filter-slider-row{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:10px;
  margin-bottom:4px;
  margin-top:8px;
}
.filter-slider-row label{
  margin:0;
  flex: 1 1 auto;
  min-width:0;
  font-size:12px;
}
.filter-value{
  font-weight:600;
  color:#1a73e8;
  white-space:nowrap;
  font-size:12px;
}

/* Mobile Panel: etwas aufger√§umter */
#mobile-panel h3{
  letter-spacing: .2px;
}
#mobile-panel .panel-section{
  display:flex;
  flex-direction:column;
  gap: 10px;
}

/* --- Desktop: Home-Box dauerhaft ausblenden (Dropdown sitzt im Slider) --- */
@media (min-width: 721px){
  .home-box{ display:none !important; }
}

/* --- Desktop: sauberer Stack in Leaflet top-right --- */
.desktop-control-stack{
  display:flex;
  flex-direction:column;
  gap: 10px;
}
.desktop-control-stack .leaflet-control{
  margin: 0 !important;
}

/* --- Mobile: Counter wirklich ganz nach unten rechts --- */
@media (max-width: 720px){
  .counter-box{
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 12px) !important;
  }
}

/* --- Mobile Panel: Accordion --- */
.panel-accordion{
  margin: 0;
  padding: 0;
  border: 0;
  background: transparent;
}
#mobile-panel details.panel-accordion > summary{
  list-style: none;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  font-weight: 800;
  font-size: 14px;
  padding: 6px 2px;
  margin: 0;
}
#mobile-panel details.panel-accordion > summary::-webkit-details-marker{ display:none; }
#mobile-panel details.panel-accordion > summary::after{
  content: "‚ñæ";
  opacity: .65;
  font-size: 14px;
  transform: translateY(-1px);
}
#mobile-panel details.panel-accordion[open] > summary::after{ content: "‚ñ¥"; }
#mobile-panel details.panel-accordion + details.panel-accordion{ margin-top: 8px; }



/* --- Last search highlight (ring + subtle pulse) --- */
.leaflet-interactive.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}
img.leaflet-marker-icon.last-search-marker {
  animation: lastSearchBounce 0.9s ease-out 0s 1;
  filter: drop-shadow(0 0 6px rgba(255, 204, 0, 0.75));
}

.last-search-indicator {
  /* color of the ring (override Leaflet default path styling) */
  stroke: rgba(255, 204, 0, 0.95);
  stroke-width: 3;
  fill: transparent;
}
.last-search-indicator.pulse {
  animation: lastSearchRing 1.2s ease-out 0s 1;
  transform-origin: center;
}

@keyframes lastSearchRing {
  0%   { opacity: 1; transform: scale(0.6); }
  100% { opacity: 0; transform: scale(1.8); }
}
@keyframes lastSearchBounce {
  0%   { transform: translateY(0); }
  20%  { transform: translateY(-10px); }
  45%  { transform: translateY(0); }
  65%  { transform: translateY(-6px); }
  100% { transform: translateY(0); }
}


/* --- FIX: Desktop right controls unified width + edge spacing --- */
:root{
  --right-controls-w: 210px;
  --right-controls-pad: 12px;
}

/* Abstand zum rechten/oberen Rand (wirkt wie "margin" zur Karte) */
.leaflet-top.leaflet-right{
  padding-right: var(--right-controls-pad) !important;
  padding-top: var(--right-controls-pad) !important;
}

/* Alle Panel-Controls (Layers / Filters / Export) exakt gleich breit (outer width) */
.leaflet-top.leaflet-right .leaflet-control-layers,
.leaflet-top.leaflet-right .filter-box.leaflet-control,
.leaflet-top.leaflet-right .export-box.leaflet-control{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important; /* Leaflet layers war sonst content-box -> wird breiter */
}

/* Sicherheit: auch im expanded state gleich breit */
.leaflet-top.leaflet-right .leaflet-control-layers.leaflet-control-layers-expanded{
  width: var(--right-controls-w) !important;
  box-sizing: border-box !important;
}



/* --- FIX: Unified UI font sizes (side panel + right controls) --- */
:root{
  --ui-font-size: 14px;
  --ui-font-size-small: 12px;
  --ui-font-size-title: 14px;
}

/* Desktop right controls */
.leaflet-top.leaflet-right .leaflet-control{
  font-size: var(--ui-font-size) !important;
}

/* Mobile side panel: accordion titles + all Leaflet controls inside */
#mobile-panel details.panel-accordion > summary{
  font-size: var(--ui-font-size-title) !important;
}

#mobile-panel .leaflet-control,
#mobile-panel .leaflet-control-layers,
#mobile-panel .filter-box,
#mobile-panel .export-box{
  font-size: var(--ui-font-size) !important;
}

#mobile-panel .leaflet-control-layers label,
#mobile-panel .leaflet-control-layers-list,
#mobile-panel .filter-box label{
  font-size: var(--ui-font-size) !important;
}

/* Small caps headings inside Leaflet layer control (KARTE / OVERLAYS) */
#mobile-panel .leaflet-control-layers-base,
#mobile-panel .leaflet-control-layers-overlays{
  font-size: var(--ui-font-size-small) !important;
}

/* Export buttons in panel/desktop */
.export-box button{
  font-size: var(--ui-font-size) !important;
}


/* --- Font: modern, highly legible on mobile + desktop (no external downloads) --- */
:root{
  /* "Inter" if installed, otherwise system UI fonts */
  --ui-font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}

/* Apply everywhere */
html, body{
  font-family: var(--ui-font-family) !important;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

button, input, select, textarea{
  font-family: var(--ui-font-family) !important;
}

/* Leaflet UI inherits reliably */
.leaflet-container,
.leaflet-control,
.leaflet-popup,
.leaflet-tooltip{
  font-family: var(--ui-font-family) !important;
}


/* --- Unified checkbox/radio sizing (mobile + desktop) --- */
:root{
  --ui-check-size: 18px;   /* try 16-20px */
  --ui-check-scale: 1.1;   /* helps on browsers that ignore width/height on native inputs */
}

/* Target Leaflet layers control + our filter box (desktop) */
.leaflet-control-layers input[type="checkbox"],
.leaflet-control-layers input[type="radio"],
.filter-box input[type="checkbox"],
.filter-box input[type="radio"],
.export-box input[type="checkbox"],
.export-box input[type="radio"],
/* Target everything inside the mobile side panel */
#mobile-panel input[type="checkbox"],
#mobile-panel input[type="radio"]{
  inline-size: var(--ui-check-size);
  block-size: var(--ui-check-size);
  transform: scale(var(--ui-check-scale));
  transform-origin: center;
  vertical-align: middle;
  margin-right: 8px;
}

/* Keep label text nicely aligned */
.leaflet-control-layers label,
.filter-box label,
#mobile-panel label{
  line-height: 1.35;
  display: flex;
  align-items: center;
  gap: 8px;
}

/* When using flex+gap, don't double-space from margin-right */
.leaflet-control-layers label input,
.filter-box label input,
#mobile-panel label input{
  margin-right: 0;
}


/* --- FIX: Mobile panel horizontal overflow (Layers control was wider due to content-box + padding) --- */
#mobile-panel .panel-section{
  overflow-x: hidden !important;  /* prevent sideways scroll */
  overflow-y: auto !important;
}

#mobile-panel .leaflet-control-layers,
#mobile-panel .leaflet-control-layers.leaflet-control-layers-expanded{
  box-sizing: border-box !important; /* include padding/border in width */
  max-width: 100% !important;
  width: 100% !important;
}


/* --- FIX: Filter box tiny horizontal scroll in mobile panel --- */
#mobile-panel .filter-box.leaflet-control{
  box-sizing: border-box !important;
  width: 100% !important;
  max-width: 100% !important;
  overflow-x: hidden !important; /* keep vertical scroll, kill horizontal */
}

/* Some browsers still create 1‚Äì2px overflow due to label/gap -> clamp */
#mobile-panel .filter-box.leaflet-control *{
  max-width: 100% !important;
}

/* GPS toggle inside export box */
.export-box label{
  display:flex;
  align-items:center;
  gap:8px;
  margin: 6px 0;
}
.export-box .gps-hint{
  font-size: 11px;
  color: rgba(0,0,0,0.68);
  margin-top: 4px;
}


/* GPS center button */
.gps-control .gps-row{
  display:flex;
  align-items:center;
  gap:10px;
}
.gps-control .gps-center-btn{
  margin-left:auto;
  padding: 4px 8px;
  font-size: 12px;
  line-height: 1.2;
  border: 1px solid rgba(0,0,0,0.18);
  border-radius: 10px;
  background: rgba(255,255,255,0.9);
  cursor: pointer;
}
.gps-control .gps-center-btn:active{
  transform: translateY(1px);
}

/* GPS Map Button (standalone, above zoom controls on mobile) */
.gps-map-btn-container {
  margin-bottom: 10px !important;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
  border-radius: 50% !important;
  overflow: hidden;
  border: none !important;
}
.gps-map-btn {
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  width: 40px !important;
  height: 40px !important;
  line-height: 40px !important;
  padding: 0 !important;
  margin: 0 !important;
  background: #fff;
  color: #444;
  text-decoration: none;
  cursor: pointer;
  transition: background 0.15s ease, color 0.15s ease;
  border: none !important;
  border-radius: 50% !important;
}
.gps-map-btn:hover {
  background: #f5f5f5;
  color: #333;
}
.gps-map-btn:active {
  background: #e8e8e8;
}
.gps-map-btn.gps-active {
  background: #4285F4;
  color: #fff;
}
.gps-map-btn.gps-active:hover {
  background: #3367D6;
  color: #fff;
}
.gps-map-btn svg {
  display: block;
}

/* Desktop: hide map button, use panel checkbox instead */
@media (min-width: 721px) {
  .gps-map-btn-container {
    display: none !important;
  }
}

/* Mobile: GPS button fixed above zoom controls */
@media (max-width: 720px) {
  .gps-map-btn-container {
    position: fixed !important;
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 156px) !important;
    left: auto !important;
    top: auto !important;
    z-index: 4000 !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.25) !important;
  }
  .gps-map-btn {
    width: 48px !important;
    height: 48px !important;
  }
  .gps-map-btn svg {
    width: 26px;
    height: 26px;
  }
}

/* GPS pulse effect when centering on location */
@keyframes gps-pulse {
  0% {
    transform: scale(1);
    opacity: 0.8;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}
.gps-pulse-ring {
  position: absolute;
  width: 20px;
  height: 20px;
  border: 3px solid #4285F4;
  border-radius: 50%;
  pointer-events: none;
  animation: gps-pulse 0.8s ease-out forwards;
}

</style>

</head>
<body>

<div id="map"></div>

<!-- Counter sichtbare Resorts -->
<div id="resort-counter" class="counter-box">
  0 / 0
</div>

<!-- Suchfeld -->
<form id="resort-search-form" class="search-box" autocomplete="off">
  <label for="resort-search" class="sr-only">Skigebiet suchen</label>
  <div class="search-row">
    <input
      id="resort-search"
      list="resort-datalist"
      type="search"
      inputmode="search"
      enterkeyhint="search"
      autocapitalize="off"
      placeholder="Let's..."
    />
    <button id="search-btn" type="submit" title="Suche ausf√ºhren">Go</button>
    <button id="clear-verbund-btn" type="button" disabled class="icon-btn icon-btn--danger" aria-label="Verbundfilter aufheben" title="Verbundfilter aufheben">‚úï</button>
    <button id="mobile-panel-toggle" class="icon-btn" type="button" aria-pressed="false" title="Filter & Layer" aria-label="Filter und Layer √∂ffnen">‚ò∞</button>
    </div>
  <datalist id="resort-datalist"></datalist>
</form>

<!-- Startadresse & Button -->
<div class="home-box">
  <label for="home-input">Startadresse (Adresse oder lat,lon)</label>
  <input
    id="home-input"
    type="text"
    placeholder="z.B. M√ºnchen, Marienplatz oder 48.12,11.57"
  />
  <button id="btn-calc-times" type="button">Fahrzeiten berechnen</button>
  <button id="btn-gps-times" type="button" title="GPS-Standort verwenden">üìç GPS</button>
</div>

<!-- Fahrzeit-Slider + Startpunkt -->
<div class="slider-box collapsed" id="slider-box">
  <button type="button" id="slider-box-toggle" class="slider-box-toggle" aria-label="Filter ein-/ausklappen" aria-expanded="false">
    <span class="toggle-icon">&#9660;</span>
  </button>
  <div class="slider-box-content">
  <div class="startpoint-row">
    <select id="homeSelectSlider" class="control-select" aria-label="Startpunkt ausw√§hlen"></select>
    <button id="btn-gps-slider" type="button" class="gps-btn" title="GPS-Standort verwenden">üìç</button>
  </div>
  <div class="startpoint-input-row">
    <input id="home-input-slider" type="text" placeholder="Adresse oder lat,lon" class="startpoint-input" />
    <button id="btn-calc-slider" type="button" class="calc-btn" title="Fahrzeiten berechnen">‚ñ∂</button>
  </div>

  <div class="slider-sep"></div>

  <div class="time-row">
  <label for="time-slider" id="time-slider-title">Max. Fahrzeit</label>
  <span id="time-slider-label" class="time-value">bis ca. 0h 00m</span>
</div>
<input id="time-slider" type="range" min="0" max="100" value="100" />

  <div class="slider-sep"></div>

  <!-- Neue Filter: Pistenkilometer, Lifte, H√∂he -->
  <div class="filter-slider-row">
    <label for="pistes-slider">Min. Pistenkilometer</label>
    <span id="pistes-slider-label" class="filter-value">0 km</span>
  </div>
  <input id="pistes-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="lifts-slider">Min. Lifte</label>
    <span id="lifts-slider-label" class="filter-value">0</span>
  </div>
  <input id="lifts-slider" type="range" min="0" max="100" value="0" />

  <div class="filter-slider-row">
    <label for="elevation-slider">Min. H√∂he</label>
    <span id="elevation-slider-label" class="filter-value">0 m</span>
  </div>
  <input id="elevation-slider" type="range" min="0" max="100" value="0" />
  </div><!-- /.slider-box-content -->
</div>

<!-- Home Selector Host (Placeholder f√ºr HomeRoutesSelector; Dropdown sitzt im Slider) -->
<div id="homeSelectorBox" class="filter-box leaflet-control" style="display:none;"></div>

<!-- isochroneControl -->
<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- Protomaps Leaflet (PMTiles + Vector rendering) -->
<script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>

<!-- Wird sp√§ter f√ºr Live Travel Times im Profil gebraucht -->
<script src="js/config.js"></script>

<script src="js/searchFilter.js"></script>


<script src="js/treeRoutesOverlay.js"></script>
<script src="js/corridorOverlay.js"></script>
<script src="js/homeRoutesSelector.js"></script>
<script src="js/homeTravelTimes.js"></script>


<script src="js/gpsControl.js"></script>
<script>
  // --------- Basis-Einstellungen ---------
  // ORS_API_KEY wird aus config.js gelesen (nicht in Git einchecken).
  const ORS_API_KEY = (window.APP_CONFIG && window.APP_CONFIG.ORS_API_KEY) ? window.APP_CONFIG.ORS_API_KEY : "DEIN_ORS_API_KEY";

  const MUC_LAT = 48.137;
  const MUC_LON = 11.575;
  const AVG_SPEED_KMH = 70.0;
  
  function getResortNameFromInput(raw) {
    if (!raw) return '';
    const parts = raw.split(/\s[‚Äì-]\s/);
    return parts[0].trim();
  }

  function toRad(x) {
    return x * Math.PI / 180;
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371.0;
    const phi1 = toRad(lat1);
    const phi2 = toRad(lat2);
    const dphi = toRad(lat2 - lat1);
    const dlambda = toRad(lon2 - lon1);
    const a = Math.sin(dphi / 2) ** 2 +
              Math.cos(phi1) * Math.cos(phi2) * Math.sin(dlambda / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  
  function buildDriveText(r) {
    let distTxt = "";
    if (r.distKm != null && isFinite(r.distKm)) {
      distTxt = `${Math.round(r.distKm)} km`;
    }
    let timeTxt = "";
    if (r.travelHours != null && isFinite(r.travelHours)) {
      timeTxt = fmtTime(r.travelHours);
    }

    if (distTxt && timeTxt) return `${distTxt} ¬∑ ca. ${timeTxt}`;
    if (distTxt)           return distTxt;
    if (timeTxt)           return "ca. " + timeTxt;
    return "keine Angabe";
  }

  function makePopupHtml(r) {
    const hasSct = hasPass(r, PASS_ID_SCT);
    const hasSsc = hasPass(r, PASS_ID_SSC);

    const passes = [];
    if (hasSct) passes.push("Snow Card Tirol");
    if (hasSsc) passes.push("SuperSkiCard");
    if (r.nearMuc && !hasSct && !hasSsc) passes.push("Weitere Gebiete s√ºdlich von M√ºnchen");
    const passesStr = passes.length ? passes.join(", ") : "‚Äì";

    const driveTxt = buildDriveText(r);
    const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;

    let websiteLine = "";
    if (r.website) {
      const url = r.website.startsWith("http") ? r.website : "https://" + r.website;
      const label = url.replace(/^https?:\/\//, "");
      websiteLine = `<b>Website:</b> <a href="${url}" target="_blank" rel="noopener noreferrer">${label}</a><br/>`;
    }

    return `
      <div style="font-size:13px">
        <b>${r.name}</b><br/>
        <b>P√§sse:</b> ${passesStr}<br/>
        <b>Gletscher:</b> ${r.glacier ? "Ja" : "Nein"}<br/>
        ${websiteLine}
        <b>Ab Zuhause:</b> ${driveTxt}<br/>
        <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer">
          In Google Maps √∂ffnen
        </a>
      </div>
    `;
  }
  
  function fmtTime(hoursFloat) {
    const totalMin = Math.round(hoursFloat * 60);
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return `${h}h ${m.toString().padStart(2, "0")}m`;
  }

  function norm(name) {
    return name
      .toLowerCase()
      .replace(/‚Äì/g, "-")
      .replace(/‚Äî/g, "-")
      .replace(/  +/g, " ")
      .trim();
  }

  // Pass-IDs aus der Datenbank
  const PASS_ID_SCT = "snowcard-tirol";
  const PASS_ID_SSC = "superskicard";

  // Hilfsfunktion: Pr√ºft ob ein Resort einen bestimmten Pass hat
  function hasPass(r, passId) {
    if (!r.passes || !Array.isArray(r.passes)) return false;
    return r.passes.some(p => p.stable_id === passId);
  }

  // --------- Grunddaten ---------
  const sctList = [/* nur noch Referenz, echte Daten aus resorts.json */];
  const sscList = [];
  const nearMucList = [];

  const resorts = {};
  const resortMarkers = {};
  window.__resortsReady = false;
  let minHours = Infinity;
  let maxHours = 0;

  const travelTimeCache = {};
  let originMarker = null;
  
  // Gesamtzahl der Resorts
  let totalResorts = 0;

  // Karte - zentriert √ºber den Alpen, alle Skigebiete sichtbar
  const map = L.map("map").setView([46.8, 11.0], 7);
  // Debug/DevTools access
  window.map = map;

  const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap-Mitwirkende"
  });
  osm.addTo(map);

  // Optional: Topo-Look mit Relief (zeigt H√∂hen/Topologie etwas deutlicher)
  const topo = L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
    maxZoom: 17,
    attribution: "Map data: &copy; OpenStreetMap-Mitwirkende, SRTM | Map style: &copy; OpenTopoMap"
  });

  // --------- PMTiles Overlay (Pisten & Lifte) ---------
  // Lege die Dateien in deinem Projekt z.B. unter /tiles ab:
  //   ./tiles/pistes.pmtiles
  //   ./tiles/lifts.pmtiles
  const PMTILES_PISTES_URL = "./tiles/pistes.pmtiles";
  const PMTILES_LIFTS_URL  = "./tiles/lifts.pmtiles";

  // Protomaps rendert Vector-Tiles als Canvas-Kacheln in Leaflet.
  // (Sehr performant, ideal als Overlay. Interaktion auf einzelne Pisten ist nur eingeschr√§nkt.)
  class LineSymbolizer {
    constructor(styleFn) { this.styleFn = styleFn; }
    draw(ctx, geom, z, feature) {
      const s = this.styleFn(feature.props || {}, z);
      if (!s) return;
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.globalAlpha = (s.opacity ?? 1);
      ctx.strokeStyle = s.color;
      ctx.lineWidth = s.width;
      if (s.dash) ctx.setLineDash(s.dash);
      else ctx.setLineDash([]);

      ctx.beginPath();
      // geom: Array<LineString>, each is Array<Point> with {x,y}
      for (const line of geom) {
        for (let i = 0; i < line.length; i++) {
          const p = line[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  // Wichtig: Diese Layernamen ("pistes" / "lifts") m√ºssen beim Erzeugen der PMTiles so gesetzt werden.
  // Wenn du sp√§ter andere Layernamen hast, einfach hier anpassen.
  const PISTES_RULES = [{
    dataLayer: "pistes",
    symbolizer: new LineSymbolizer((props, z) => {
      const d = (props["piste:difficulty"] || "").toLowerCase();
      const width = z < 10 ? 2.0 : z < 12 ? 3.0 : 4.4;

      if (d === "easy" || d === "novice" || d === "blue")  return { color: "#2b6cff", width, opacity: 0.95 };
      if (d === "intermediate" || d === "red")             return { color: "#e53935", width, opacity: 0.95 };
      if (d === "advanced" || d === "expert" || d === "black") return { color: "#111111", width, opacity: 0.95 };
      return { color: "#6f6f6f", width, opacity: 0.9 };
    })
  }];

  const LIFTS_RULES = [{
    dataLayer: "lifts",
    symbolizer: new LineSymbolizer((props, z) => {
      const width = z < 10 ? 1.2 : z < 12 ? 1.8 : 2.4;
      return { color: "#111111", width, opacity: 0.8, dash: [4, 3] };
    })
  }];

  // Overlay-Layer NICHT direkt hinzuf√ºgen (kommt per Layer-Control Checkbox)
  const pistesLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_PISTES_URL,
    paintRules: PISTES_RULES,
    labelRules: []
  }) : null;

  const liftsLayer = (typeof protomapsL !== "undefined") ? protomapsL.leafletLayer({
    url: PMTILES_LIFTS_URL,
    paintRules: LIFTS_RULES,
    labelRules: []
  }) : null;

// Ein Layer f√ºr alle Resort-Marker (Filter steuern Sichtbarkeit)
  const markerLayer = L.layerGroup().addTo(map);
  const COLOR_SCT   = "#9C2419";
  const COLOR_SSC   = "#004A8F";
  const COLOR_BOTH  = "#9C27B0";
  const COLOR_MUC   = "#2E7D32";
  const COLOR_OTHER = "#888888";

  // --------- Zoom-abh√§ngige Skalierung ---------
  // Arrays zum Speichern der verschiedenen Marker-Typen f√ºr Zoom-Updates
  const circleMarkers = [];
  const glacierMarkers = [];

  // Berechnet Marker-Radius basierend auf Zoom-Level
  function getMarkerRadius(zoom) {
    if (zoom >= 9) return 8;
    if (zoom >= 8) return 7;
    if (zoom >= 7) return 6;
    if (zoom >= 6) return 5;
    return 4;
  }

  // Berechnet Gletscher-Icon-Gr√∂√üe basierend auf Zoom-Level
  function getGlacierIconSize(zoom) {
    if (zoom >= 9) return 26;
    if (zoom >= 8) return 22;
    if (zoom >= 7) return 18;
    if (zoom >= 6) return 14;
    return 12;
  }

  // Erstellt Gletscher-Icon mit dynamischer Gr√∂√üe (Microsoft Fluent Emoji Snowflake mit Gradient)
  function createGlacierIcon(color, size) {
    const svgSize = Math.round(size * 0.7);
    const uid = Math.random().toString(36).substr(2, 9); // Unique ID f√ºr Gradient
    // Microsoft Fluent Emoji Snowflake Form mit Farbverlauf (MIT License)
    const snowflakeSvg = `
      <svg width="${svgSize}" height="${svgSize}" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="snowGrad${uid}" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#43C4F5"/>
            <stop offset="100%" stop-color="#3D8DF3"/>
          </linearGradient>
        </defs>
        <path fill="url(#snowGrad${uid})" d="M23.5638 18.9L28.6756 17.54C29.229 17.39 29.8126 17.69 29.9636 18.25C30.1145 18.81 29.7824 19.37 29.229 19.52L26.1197 20.35L28.3435 21.62C28.8265 21.9 28.9976 22.51 28.7158 22.99C28.4341 23.47 27.8203 23.64 27.3373 23.36L25.1135 22.09L25.9486 25.18C26.0996 25.74 25.7776 26.3 25.2141 26.45C24.6506 26.6 24.0871 26.27 23.9361 25.72L22.5677 20.64L20.2533 19.31C19.5389 20.1 18.593 20.68 17.5062 20.9V23.53L21.2495 27.25C21.652 27.65 21.652 28.31 21.2495 28.71C20.847 29.11 20.1829 29.11 19.7804 28.71L17.5062 26.45V29C17.5062 29.55 17.0534 30 16.5 30C15.9466 30 15.4938 29.55 15.4938 29V26.46L13.2196 28.72C12.8171 29.12 12.153 29.12 11.7505 28.72C11.348 28.32 11.348 27.66 11.7505 27.26L15.4938 23.54V20.91C14.3969 20.69 13.4611 20.11 12.7467 19.32L10.4424 20.64L9.07391 25.72C8.92298 26.27 8.34942 26.6 7.79598 26.45C7.24255 26.3 6.91049 25.73 7.06142 25.18L7.89661 22.09L5.6728 23.37C5.18981 23.64 4.576 23.48 4.29425 23C4.0125 22.52 4.18356 21.91 4.6565 21.65L6.8803 20.37L3.771 19.54C3.21757 19.39 2.88551 18.82 3.03644 18.27C3.18738 17.72 3.76094 17.39 4.31437 17.54L9.4261 18.9L11.7405 17.57C11.5694 17.08 11.4587 16.55 11.4587 16C11.4587 15.45 11.5694 14.92 11.7405 14.45L9.4261 13.12L4.31437 14.48C3.75088 14.63 3.18738 14.3 3.03644 13.75C2.88551 13.19 3.21757 12.63 3.771 12.48L6.8803 11.65L4.6565 10.37C4.18356 10.09 4.0125 9.48 4.29425 9C4.56594 8.52 5.18981 8.36 5.66274 8.63L7.89661 9.91L7.06142 6.82C6.91049 6.27 7.24255 5.71 7.79598 5.56C8.34942 5.41 8.91291 5.74 9.06385 6.29L10.4323 11.37L12.7366 12.69C13.4511 11.9 14.3969 11.32 15.4837 11.1V8.47L11.7405 4.75C11.338 4.35 11.338 3.69 11.7405 3.29C12.143 2.89 12.8071 2.89 13.2096 3.29L15.4837 5.55V3C15.4837 2.45 15.9365 2 16.4899 2C17.0434 2 17.4962 2.45 17.4962 3V5.55L19.7703 3.29C20.1728 2.89 20.8369 2.89 21.2394 3.29C21.6419 3.69 21.6419 4.35 21.2394 4.75L17.4962 8.47V11.1C18.5829 11.32 19.5288 11.9 20.2332 12.68L22.5475 11.35L23.916 6.27C24.067 5.72 24.6405 5.39 25.194 5.54C25.7474 5.69 26.0795 6.26 25.9285 6.81L25.0933 9.9L27.3171 8.63C27.8001 8.36 28.4139 8.52 28.6957 9C28.9674 9.48 28.8064 10.09 28.3334 10.36L26.1096 11.63L29.2189 12.46C29.7724 12.61 30.1044 13.18 29.9535 13.73C29.8026 14.28 29.229 14.61 28.6756 14.46L23.5638 13.1L21.2495 14.43C21.4205 14.92 21.5312 15.45 21.5312 16C21.5312 16.55 21.4205 17.07 21.2495 17.57L23.5638 18.9ZM19.5087 16C19.5087 14.3431 18.1572 13 16.49 13C14.8228 13 13.4712 14.3431 13.4712 16C13.4712 17.6569 14.8228 19 16.49 19C18.1572 19 19.5087 17.6569 19.5087 16Z"/>
      </svg>`;
    return L.divIcon({
      html: `
        <div style="
          width: ${size}px;
          height: ${size}px;
          border-radius: 50%;
          border: 2px solid ${color};
          background: white;
          display: flex;
          align-items: center;
          justify-content: center;
        ">
          ${snowflakeSvg}
        </div>
      `,
      className: "",
      iconSize: [size, size],
      iconAnchor: [size/2, size/2],
      popupAnchor: [0, -size/2]
    });
  }

  // Cache f√ºr letzte Zoom-Gr√∂√üen (verhindert unn√∂tige DOM-Updates)
  let lastMarkerRadius = null;
  let lastGlacierSize = null;
  let lastCorridorWeightKey = null;

  // Aktualisiert alle Marker-Gr√∂√üen basierend auf dem aktuellen Zoom
  // Optimiert: Nur updaten wenn sich die Gr√∂√üen-Stufe tats√§chlich √§ndert
  function updateMarkerSizes() {
    const zoom = map.getZoom();
    const radius = getMarkerRadius(zoom);
    const iconSize = getGlacierIconSize(zoom);

    // CircleMarker nur updaten wenn Radius sich √§ndert
    if (radius !== lastMarkerRadius) {
      lastMarkerRadius = radius;
      circleMarkers.forEach(m => {
        m.setRadius(radius);
      });
    }

    // Gletscher-Icons nur updaten wenn Gr√∂√üe sich √§ndert (teuer: DOM-Neuerstellen)
    if (iconSize !== lastGlacierSize) {
      lastGlacierSize = iconSize;
      glacierMarkers.forEach(({ marker, color }) => {
        marker.setIcon(createGlacierIcon(color, iconSize));
      });
    }
  }

  // Berechnet Corridor-Linienbreite basierend auf Zoom-Level
  function getCorridorWeights(zoom) {
    if (zoom >= 9) return { minWeight: 2, maxWeight: 10, key: "z9" };
    if (zoom >= 8) return { minWeight: 1.5, maxWeight: 8, key: "z8" };
    if (zoom >= 7) return { minWeight: 1.2, maxWeight: 6, key: "z7" };
    if (zoom >= 6) return { minWeight: 1, maxWeight: 4, key: "z6" };
    return { minWeight: 0.8, maxWeight: 3, key: "z5" };
  }

  // Aktualisiert Corridor-Linienbreiten basierend auf dem aktuellen Zoom
  // Optimiert: Nur updaten wenn sich die Weight-Stufe tats√§chlich √§ndert
  function updateCorridorWeights() {
    if (!window.corridorOverlay || !window.corridorOverlay.setStyle) return;
    const zoom = map.getZoom();
    const weights = getCorridorWeights(zoom);

    // Nur updaten wenn sich die Stufe √§ndert
    if (weights.key !== lastCorridorWeightKey) {
      lastCorridorWeightKey = weights.key;
      window.corridorOverlay.setStyle(weights);
    }
  }

  // Counter aktualisieren
  function updateResortCounter() {
    const box = document.getElementById("resort-counter");
    if (!box) return;

    let visible = 0;
    Object.values(resortMarkers).forEach(marker => {
      if (map.hasLayer(marker)) {
        visible++;
      }
    });

    box.textContent = `${visible} / ${totalResorts}`;
  }
  function initResortsFromJson(list) {
    list.forEach(r => {
      const key = norm(r.name);

      // Resort-Objekt direkt √ºbernehmen (mit passes-Array)
      resorts[key] = {
        name: r.name,
        lat: r.lat,
        lon: r.lon,
        country: r.country || null,
        region: r.region || null,
        passes: r.passes || [],
        glacier: !!r.glacier,
        nearMuc: !!r.nearMuc,
        website: (typeof r.website === "string" && r.website.trim()) ? r.website.trim() : null,
        groupId: (typeof r.groupId === "string" && r.groupId.trim()) ? r.groupId.trim() : null,
        groupName: (typeof r.groupName === "string" && r.groupName.trim()) ? r.groupName.trim() : null,
        entryType: (typeof r.entryType === "string" && r.entryType.trim()) ? r.entryType.trim() : null,
        entryName: (typeof r.entryName === "string" && r.entryName.trim()) ? r.entryName.trim() : null,
        liftsTotal: (r.liftsTotal != null) ? Number(r.liftsTotal) : null,
        pistesKm: (r.pistesKm != null) ? Number(r.pistesKm) : null,
        maxElevation: (r.maxElevation != null) ? Number(r.maxElevation) : null
      };
    });
  }

  function loadResortsAndInit() {
    fetch("data/resorts.json")
      .then(resp => {
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        return resp.json();
      })
      .then(list => {
        initResortsFromJson(list);

        totalResorts = Object.keys(resorts).length;

        buildMarkers();
        window.__resortsReady = true;
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.onResortsReady === "function") {
          try { window.HomeTravelTimes.onResortsReady(); } catch (e) { console.warn(e); }
        }
if (typeof rebuildDatalist === "function") {
          rebuildDatalist();
        }
        // Neue Filter-Slider initialisieren
        if (window.ui && typeof window.ui.computeFilterRanges === "function") {
          window.ui.computeFilterRanges();
          window.ui.updateFilterSliderLabels();
        }
        updateTimeLabel(100);
        applyTimeFilter(100);
                if (typeof loadTravelTimesJson === "function") {
          loadTravelTimesJson();
        }
      })
      .catch(err => {
        console.error("Fehler beim Laden von resorts.json:", err);
        alert("Fehler beim Laden der Skigebiete (Details in Konsole).");
      });
  }

  function buildMarkers() {
    Object.values(resorts).forEach(r => {
      const hasSct = hasPass(r, PASS_ID_SCT);
      const hasSsc = hasPass(r, PASS_ID_SSC);

      const passes = [];
      if (hasSct) passes.push("Snow Card Tirol");
      if (hasSsc) passes.push("SuperSkiCard");
      if (r.nearMuc && !hasSct && !hasSsc) passes.push("Extra: ab M√ºnchen");
      const passesStr = passes.length ? passes.join(", ") : "‚Äì";

      let color = COLOR_OTHER;
      if (hasSct && hasSsc)      color = COLOR_BOTH;
      else if (hasSct)           color = COLOR_SCT;
      else if (hasSsc)           color = COLOR_SSC;
      else if (r.nearMuc)        color = COLOR_MUC;

      const distKm   = haversineKm(MUC_LAT, MUC_LON, r.lat, r.lon);
      const estHours = distKm / AVG_SPEED_KMH;
      r.distKm = distKm;
      r.travelHours = estHours;
      if (estHours < minHours) minHours = estHours;
      if (estHours > maxHours) maxHours = estHours;

      const mapsUrl = `https://www.google.com/maps?q=${r.lat},${r.lon}`;
      const driveTxt = `${Math.round(distKm)} km ¬∑ ca. ${fmtTime(estHours)}`;

      let marker;
      const currentZoom = map.getZoom();

      if (r.glacier) {
        const iconSize = getGlacierIconSize(currentZoom);
        marker = L.marker([r.lat, r.lon], { icon: createGlacierIcon(color, iconSize) });
        glacierMarkers.push({ marker, color });
      } else {
        const radius = getMarkerRadius(currentZoom);
        marker = L.circleMarker([r.lat, r.lon], {
          radius: radius,
          color: color,
          fillColor: color,
          fillOpacity: 0.95,
          weight: 2
        });
        circleMarkers.push(marker);
      }

      marker
        .bindPopup(() => makePopupHtml(r))
        .bindTooltip(`${r.name} (${passesStr})`);
      markerLayer.addLayer(marker);
      resortMarkers[norm(r.name)] = marker;
    });

    // einmal initial nach Markerbau updaten
    updateResortCounter();
  }

  // Zoom-Event-Handler f√ºr Marker-Gr√∂√üenanpassung
  map.on("zoomend", function() {
    updateMarkerSizes();
    // Corridor-Skalierung entfernt (Performance: zu teuer bei vielen Segmenten)
  });

  const timeSlider = document.getElementById("time-slider");
  

  const baseLayers = {
    "OSM": osm,
    "Topo (Relief)": topo
  };

  const overlays = {};
  if (pistesLayer) overlays["Pists"] = pistesLayer;
  if (liftsLayer)  overlays["Lifts"]  = liftsLayer;

  window.layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// --------- Live OSM Overpass Overlay (Alpe d'Huez) ---------
// Quick, no-tiles approach: fetch OSM data from Overpass and render as GeoJSON.
// BBox source: map.getBounds().toBBoxString() returned west,south,east,north.
const ALPE_LIVE_BOUNDS = {
  west: 5.814495389733874,
  south: 45.03078564735712,
  east: 6.400547330651842,
  north: 45.180779880904076
};
// Overpass expects: (south,west,north,east)
const ALPE_OVERPASS_BBOX = `${ALPE_LIVE_BOUNDS.south},${ALPE_LIVE_BOUNDS.west},${ALPE_LIVE_BOUNDS.north},${ALPE_LIVE_BOUNDS.east}`;

const OVERPASS_ENDPOINTS = [
  "https://overpass-api.de/api/interpreter",
  "https://overpass.kumi.systems/api/interpreter",
  "https://overpass.nchc.org.tw/api/interpreter"
];

const alpeLiveLiftsLayer = L.layerGroup().addTo(map);
const alpeLivePistesLayer = L.layerGroup().addTo(map);
let alpeLiveLoaded = false;
let alpeLiveLoading = false;

async function fetchOverpassJSON(query) {
  // Overpass does NOT require an API key.
  // In practice, browser POST requests are sometimes blocked (CORS / overloaded servers),
  // so we try GET first (most reliable from GitHub Pages), then POST as a fallback.
  const encoded = encodeURIComponent(query);

  let lastErr = null;
  for (const baseUrl of OVERPASS_ENDPOINTS) {
    // --- Try GET ---
    try {
      const getUrl = `${baseUrl}?data=${encoded}`;
      const res = await fetch(getUrl, { method: "GET", mode: "cors", cache: "no-store" });
      if (!res.ok) throw new Error(`Overpass GET HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      lastErr = e;
    }

    // --- Try POST (fallback) ---
    try {
      const res = await fetch(baseUrl, {
        method: "POST",
        mode: "cors",
        cache: "no-store",
        headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
        body: "data=" + encoded
      });
      if (!res.ok) throw new Error(`Overpass POST HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error("Overpass request failed");
}

function setAlpeLiveStatus(msg) {
  const el = document.getElementById("alpe-live-status");
  if (el) el.textContent = msg || "";
}

function getTags(feature) {
  const p = feature && feature.properties ? feature.properties : {};
  return (p.tags && typeof p.tags === "object") ? p.tags : p;
}

function pisteStyle(tags, z) {
  const d = String(tags["piste:difficulty"] || "").toLowerCase();
  // Keep it close to your PMTiles styling
  if (d === "easy" || d === "novice" || d === "blue")  return { color: "#2b6cff", weight: 3, opacity: 0.95 };
  if (d === "intermediate" || d === "red")             return { color: "#e53935", weight: 3, opacity: 0.95 };
  if (d === "advanced" || d === "expert" || d === "black") return { color: "#111111", weight: 3, opacity: 0.95 };
  return { color: "#6f6f6f", weight: 2.5, opacity: 0.9 };
}

function overpassWaysToFeatureCollections(osmJson) {
  const lifts = [];
  const pistes = [];

  const els = (osmJson && osmJson.elements) ? osmJson.elements : [];
  for (const el of els) {
    if (!el || el.type !== "way") continue;
    const tags = el.tags || {};
    const geom = el.geometry;
    if (!Array.isArray(geom) || geom.length < 2) continue;

    const coords = geom.map(p => [p.lon, p.lat]).filter(c => Number.isFinite(c[0]) && Number.isFinite(c[1]));
    if (coords.length < 2) continue;

    const feat = {
      type: "Feature",
      geometry: { type: "LineString", coordinates: coords },
      properties: { ...tags, osm_id: el.id, osm_type: "way" }
    };

    if (tags.aerialway) lifts.push(feat);
    if (tags["piste:type"]) pistes.push(feat);
  }

  return {
    lifts: { type: "FeatureCollection", features: lifts },
    pistes: { type: "FeatureCollection", features: pistes },
  };
}

async function loadAlpeLiveOSM(force=false) {
  if (alpeLiveLoading) return;
  if (alpeLiveLoaded && !force) return;
  alpeLiveLoading = true;
  setAlpeLiveStatus("Lade Alpe d'Huez (Overpass)‚Ä¶");

  try {
    // We request geometries directly from Overpass (`out geom`) so we don't need osmtogeojson.
    // Overpass bbox format: south,west,north,east
    const query = `
      [out:json][timeout:60];
      (
        way["aerialway"](${ALPE_OVERPASS_BBOX});
        way["piste:type"](${ALPE_OVERPASS_BBOX});
      );
      out tags geom;
    `;

    const osmJson = await fetchOverpassJSON(query);
    const { lifts, pistes } = overpassWaysToFeatureCollections(osmJson);

    // Replace data in layer groups
    alpeLiveLiftsLayer.clearLayers();
    alpeLivePistesLayer.clearLayers();

    const liftsCount = lifts.features.length;
    const pistesCount = pistes.features.length;

    const liftsGeo = L.geoJSON(lifts, {
      style: () => ({ color: "#111111", weight: 2.2, opacity: 0.85, dashArray: "5,4" }),
      onEachFeature: (f, layer) => {
        const t = getTags(f);
        const nm = t.name || t.ref || t.aerialway;
        if (nm) layer.bindTooltip(String(nm), { sticky: true });
      }
    });
    liftsGeo.addTo(alpeLiveLiftsLayer);

    const pistesGeo = L.geoJSON(pistes, {
      style: (f) => pisteStyle(getTags(f)),
      onEachFeature: (f, layer) => {
        const t = getTags(f);
        const nm = t.name || t.ref || t["piste:name"] || t["piste:type"];
        if (nm) layer.bindTooltip(String(nm), { sticky: true });
      }
    });
    pistesGeo.addTo(alpeLivePistesLayer);

    alpeLiveLoaded = true;

    if (liftsCount === 0 && pistesCount === 0) {
      setAlpeLiveStatus("Keine Live-Daten gefunden (OSM).");
    } else {
      setAlpeLiveStatus(`Geladen: ${pistesCount} Pisten / ${liftsCount} Lifte`);
    }
  } catch (e) {
    console.error("Alpe live Overpass error:", e);
    setAlpeLiveStatus("Fehler beim Laden (Overpass).");
  } finally {
    alpeLiveLoading = false;
  }
}


function clearAlpeLiveOSM() {
  try {
    alpeLiveLiftsLayer.clearLayers();
    alpeLivePistesLayer.clearLayers();
  } catch (_) {}
  alpeLiveLoaded = false;
}

async function reloadAlpeLiveOSM() {
  clearAlpeLiveOSM();
  // Only reload if at least one of the live layers is currently enabled
  const enabled = map.hasLayer(alpeLiveLiftsLayer) || map.hasLayer(alpeLivePistesLayer);
  if (enabled) {
    await loadAlpeLiveOSM(true);
  } else {
    setAlpeLiveStatus("Reload bereit ‚Äì Overlay aktivieren, um zu laden.");
  }
}

// Add overlays to your existing layers control
if (window.layerControl && typeof window.layerControl.addOverlay === "function") {
  window.layerControl.addOverlay(alpeLivePistesLayer, "Alpe d'Huez ‚Äì Pisten (Live)");
  window.layerControl.addOverlay(alpeLiveLiftsLayer,  "Alpe d'Huez ‚Äì Lifte (Live)");
}


// If the user has the live overlays enabled by default (or via persisted state), load immediately
if (map.hasLayer(alpeLivePistesLayer) || map.hasLayer(alpeLiveLiftsLayer)) {
  loadAlpeLiveOSM();
}

// Lazy-load on first enable (so you don't hit Overpass until needed)
map.on("overlayadd", (e) => {
  if (e.layer === alpeLivePistesLayer || e.layer === alpeLiveLiftsLayer) {
    loadAlpeLiveOSM();
  }
});




map.on("overlayremove", (e) => {
  if (e.layer === alpeLivePistesLayer || e.layer === alpeLiveLiftsLayer) {
    setAlpeLiveStatus("");
  }
});
// --- Panel: Layer-Control optisch/inhaltlich gliedern (Karte vs Overlays) ---
(function decorateLayerControl(){
  try{
    const lc = window.layerControl;
    const c = lc && lc.getContainer ? lc.getContainer() : document.querySelector('.leaflet-control-layers');
    if (!c) return;

    // Gruppen√ºberschriften
    const base = c.querySelector('.leaflet-control-layers-base');
    const ov   = c.querySelector('.leaflet-control-layers-overlays');
    if (base && !(base.previousElementSibling && base.previousElementSibling.classList.contains('panel-group-title'))){
      base.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Karte</div>');
    }
    if (ov && !(ov.previousElementSibling && ov.previousElementSibling.classList.contains('panel-group-title'))){
      ov.insertAdjacentHTML('beforebegin', '<div class="panel-group-title">Overlays</div>');
    }

    // Reload-Button + Status f√ºr Live-Overpass (damit man bei Overpass-Problemen neu versuchen kann)
    if (!c.querySelector('#alpe-live-reload')) {
      const wrap = document.createElement('div');
      wrap.style.marginTop = '8px';
      wrap.innerHTML = `
        <button id="alpe-live-reload" type="button" style="width:100%;height:32px;border-radius:10px;border:1px solid rgba(0,0,0,0.35);background:#f3f3f3;cursor:pointer;font-size:12px;font-weight:600;">
          Reload Alpe d'Huez (Live)
        </button>
        <div id="alpe-live-status" style="margin-top:6px;font-size:11px;color:rgba(0,0,0,0.68);"></div>
      `;
      c.appendChild(wrap);

      const btn = wrap.querySelector('#alpe-live-reload');
      btn.addEventListener('click', () => { reloadAlpeLiveOSM(); });
      setAlpeLiveStatus('');
    }
  } catch(e){
    console.warn('decorateLayerControl failed', e);
  }
})();
// --------- Suche & Filter initialisieren (ausgelagert in searchFilter.js) ---------

  // --- Zoom-Reset: mobile anders als Desktop (wird von searchFilter.js √ºber resetMapView() genutzt) ---
  // Passe RESET_ZOOM_MOBILE in den DevTools an, bis es sich f√ºr dich richtig anf√ºhlt.
  const RESET_CENTER = [47.2, 12.2];
  const RESET_ZOOM_DESKTOP = 9;
  const RESET_ZOOM_MOBILE  = 8; // <‚Äî hier testen/√§ndern

  const isMobileViewport = () => window.matchMedia("(max-width: 720px)").matches;

  function resetView(map) {
    // Optional: Popups schlie√üen, damit Reset "clean" wirkt
    try { map.closePopup(); } catch (_) {}

    const opts = { animate: true, duration: 0.8 };

    if (isMobileViewport()) {
      map.flyTo(RESET_CENTER, RESET_ZOOM_MOBILE, opts);

      // Optional: leicht nach unten schieben, falls die Top-Bar zu viel √ºberdeckt (Wert anpassen/auskommentieren)
      // try { map.panBy([0, 80], { animate: true, duration: 0.35 }); } catch (_) {}
    } else {
      map.flyTo(RESET_CENTER, RESET_ZOOM_DESKTOP, opts);
    }
  }

  const ui = window.initSearchAndFilters({
    map,
    resorts,
    resortMarkers,
    markerLayer,
    fmtTime,
    norm,
    getMinHours: () => minHours,
    getMaxHours: () => maxHours,
    updateResortCounter,
    createFilterControl: true,
    createExportControl: true
  ,
    resetView});
  window.ui = ui;

  // --------- GPS: aktuelle Position anzeigen (mobil) ---------
  if (window.GpsControl && typeof window.GpsControl.init === "function") {
    try { window.GpsControl.init(map); } catch (e) { console.warn("GpsControl init failed", e); }
  }

// Alte Funktionsnamen weiterhin verf√ºgbar halten (damit bestehender Code unver√§ndert bleibt)
  window.rebuildDatalist   = ui.rebuildDatalist;
  window.updateTimeLabel   = ui.updateTimeLabel;
  window.applyTimeFilter   = ui.applyTimeFilter;
  window.focusResortByName = ui.focusResortByName;
  // Suche & Filter wurden in searchFilter.js ausgelagert.


  // --------- Tree Routes Overlay (Reachability "Chaos"-Layer) ---------
  // Erwartete Dateien: data/routes/home_<homeId>.geojson (z.B. home_muc.geojson)
  // Home-Auswahl erfolgt √ºber das Dropdown (HomeRoutesSelector) und l√§dt die passende Datei.
  let tree = null;
  let currentTreeHomeId = "muc"; // Fallback; wird bei Init vom Selector √ºberschrieben

  function pctToLimitHours(pct) {
    const p = Math.max(0, Math.min(100, Number(pct))) / 100;
    // minHours/maxHours werden aus travel_times.json (oder OSRM/ORS) gesetzt
    if (!isFinite(minHours) || !isFinite(maxHours) || minHours === Infinity) return Infinity;
    return minHours + p * (maxHours - minHours);
  }

  function syncTreeWithUi(uiObj, pct) {
    if (!tree || !uiObj) return;

    // 1) Zeitlimit aus Slider-Prozent
    const limitHours = (pct >= 99) ? Infinity : pctToLimitHours(pct);
    tree.setMaxHours(limitHours);

    // 2) Weitere Filter: Wir √ºbernehmen einfach die aktuell sichtbaren Resorts aus der UI
    //    und zeigen nur deren Routen an.
    const visible = uiObj.getVisibleResorts ? uiObj.getVisibleResorts() : [];
    const visibleSet = new Set(visible.map(r => norm(r.name)));

    tree.setPredicate((props) => {
      const nm = props && (props.name || props.resort_name || props.resort) ? String(props.name || props.resort_name || props.resort) : "";
      return visibleSet.has(norm(nm));
    });
  }

  // Tree Overlay (re-)initialisieren und (optional) in Layer-Control aufnehmen
  async function ensureTreeOverlayForHome(homeId) {
    if (!window.TreeRoutesOverlay) return null;
    const url = `data/routes/home_${homeId}.geojson`;

    // Enabled-Status merken
    const hadTree = !!(tree && tree.getLayer && tree.getLayer());
    const wasEnabled = hadTree ? map.hasLayer(tree.getLayer()) : true; // default: an

    // Alte Instanz entfernen (Layer + Eintrag im LayerControl)
    if (tree && tree.getLayer && tree.getLayer()) {
      const oldLayer = tree.getLayer();
      try { if (map.hasLayer(oldLayer)) map.removeLayer(oldLayer); } catch (_) {}
      try { if (window.layerControl && typeof window.layerControl.removeLayer === "function") window.layerControl.removeLayer(oldLayer); } catch (_) {}
    }

    // Neu initialisieren (preserve enabled state)
    const next = await window.TreeRoutesOverlay.init(map, {
      url,
      enabled: wasEnabled,   // bleibt an/aus wie vorher
      baseOpacity: 0.18
    });

    tree = next;
    currentTreeHomeId = homeId;
    window.treeOverlay = tree;

    // Tree Routes aus Layer-Control entfernt - ersetzt durch Corridors
    // Code bleibt f√ºr eventuelle sp√§tere Nutzung erhalten

    // applyFilters hooken: immer wenn Marker-Filter aktualisiert werden, Tree synchronisieren
    if (ui && typeof ui.applyFilters === "function") {
      const _apply = ui.applyFilters;
      if (!_apply.__treeHooked) {
        ui.applyFilters = function (pct) {
          _apply(pct);
          syncTreeWithUi(ui, pct);
        };
        ui.applyFilters.__treeHooked = true;

        // alte Alias-Funktion ebenfalls aktualisieren
        window.applyTimeFilter = ui.applyFilters;
        window.applyFilters = ui.applyFilters;
      }
    }

    // initial sync
    const initialPct = Number(timeSlider?.value ?? 100);
    syncTreeWithUi(ui, initialPct);

    return tree;
  }

  // Expose for home selector
  window.ensureTreeOverlayForHome = ensureTreeOverlayForHome;

  // Tree Routes Overlay deaktiviert - ersetzt durch Corridors

  // --------- Corridor Overlay (Hauptstrecken) ---------
  // Zeigt die meistgenutzten Streckenabschnitte mit variabler Linienbreite
  let corridorOverlay = null;

  async function ensureCorridorOverlayForHome(homeId) {
    if (!window.CorridorOverlay) return null;
    const url = `data/corridors/home_${homeId}.geojson`;

    // Alten Layer entfernen
    if (corridorOverlay && corridorOverlay.getLayer) {
      const oldLayer = corridorOverlay.getLayer();
      if (oldLayer) {
        map.removeLayer(oldLayer);
        if (window.layerControl) {
          window.layerControl.removeLayer(oldLayer);
        }
      }
    }

    try {
      // Initiale Weights basierend auf aktuellem Zoom
      const initWeights = getCorridorWeights(map.getZoom());
      corridorOverlay = await window.CorridorOverlay.init(map, {
        url,
        enabled: false,  // Default: aus (User kann es einschalten)
        minWeight: initWeights.minWeight,
        maxWeight: initWeights.maxWeight,
        baseOpacity: 0.75
      });

      window.corridorOverlay = corridorOverlay;

      if (window.layerControl && corridorOverlay.getLayer()) {
        window.layerControl.addOverlay(corridorOverlay.getLayer(), "Corridors (Hauptstrecken)");
      }

      console.log(`Corridors loaded: ${corridorOverlay.getFeatureCount()} segments, max ${corridorOverlay.getMaxCount()} routes`);
    } catch (err) {
      console.warn("CorridorOverlay init skipped/failed:", err);
    }

    return corridorOverlay;
  }

  // Expose for home selector
  window.ensureCorridorOverlayForHome = ensureCorridorOverlayForHome;

  // Initial: Corridors f√ºr M√ºnchen laden
  (async () => {
    try {
      await ensureCorridorOverlayForHome("muc");
    } catch (err) {
      console.warn("CorridorOverlay init skipped:", err);
    }
  })();

  function applyTravelTimesFromMap(ttMap) {
    const resortList = Object.values(resorts);
    minHours = Infinity;
    maxHours = 0;

    resortList.forEach(r => {
      const tt = ttMap[r.name];
      if (tt && typeof tt.hours === "number" && typeof tt.km === "number") {
        // Echte Fahrzeit aus travel_times √ºberschreibt Sch√§tzung
        r.travelHours = tt.hours;
        r.distKm = tt.km;
      }
      // minHours/maxHours von ALLEN Resorts (echte Zeiten + Sch√§tzungen)
      if (typeof r.travelHours === "number" && isFinite(r.travelHours)) {
        if (r.travelHours < minHours) minHours = r.travelHours;
        if (r.travelHours > maxHours) maxHours = r.travelHours;
      }
    });

    if (typeof rebuildDatalist === "function") {
      rebuildDatalist();
    }
    if (typeof timeSlider !== "undefined" && timeSlider) {
      timeSlider.value = 100;
    }
    updateTimeLabel(100);
    applyTimeFilter(100);    
  }

  async function recalcTravelTimesFromOrigin() {
    const input = document.getElementById("home-input");
    const value = input.value.trim();

    let originLat;
    let originLon;

    if (!value) {
      originLat = MUC_LAT;
      originLon = MUC_LON;
    } else if (value.includes(",")) {
      const parts = value.split(",");
      originLat = parseFloat(parts[0]);
      originLon = parseFloat(parts[1]);
      if (!isFinite(originLat) || !isFinite(originLon)) {
        alert("Konnte Eingabe nicht als 'lat,lon' interpretieren.");
        return;
      }
    } else {
      if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
        alert("Bitte ORS_API_KEY in config.js eintragen.");
        return;
      }
      try {
        const url = "https://api.openrouteservice.org/geocode/search?api_key=" +
                    encodeURIComponent(ORS_API_KEY) +
                    "&text=" + encodeURIComponent(value) +
                    "&size=1";
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("Geocoding-Request fehlgeschlagen");
        }
        const data = await resp.json();
        const feats = data.features || [];
        if (!feats.length) {
          alert("Adresse konnte nicht gefunden werden.");
          return;
        }
        const coords = feats[0].geometry.coordinates;
        originLon = coords[0];
        originLat = coords[1];
      } catch (err) {
        console.error("Fehler beim Geocoding:", err);
        alert("Fehler beim Geocoding (Details in Konsole).");
        return;
      }
    }

    if (typeof map !== "undefined") {
      if (originMarker) {
        map.removeLayer(originMarker);
      }
      const originIcon = L.divIcon({
        html: `
          <div style="
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
          ">
            üè†
          </div>
        `,
        className: "",
        iconSize: [20, 20],
        iconAnchor: [10, 10]
      });
      originMarker = L.marker([originLat, originLon], { icon: originIcon })
        .addTo(map)
        .bindTooltip("Startpunkt", { permanent: false });
    }

    const key = originLat.toFixed(3) + "," + originLon.toFixed(3);

    if (travelTimeCache[key]) {
      applyTravelTimesFromMap(travelTimeCache[key]);
      return;
    }

    const resortList = Object.values(resorts);
    const locations = [[originLon, originLat]].concat(
      resortList.map(r => [r.lon, r.lat])
    );
    const body = {
      locations: locations,
      metrics: ["distance", "duration"],
      units: "km",
      sources: [0],
      destinations: resortList.map((_, idx) => idx + 1)
    };

    if (!ORS_API_KEY || ORS_API_KEY === "DEIN_ORS_API_KEY") {
      alert("Bitte ORS_API_KEY in config.js eintragen.");
      return;
    }

    try {
      const resp = await fetch("https://api.openrouteservice.org/v2/matrix/driving-car", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": ORS_API_KEY
        },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        throw new Error("Matrix-Request fehlgeschlagen: " + resp.status);
      }
      const data = await resp.json();
      const durations = (data.durations && data.durations[0]) || [];
      const distances = (data.distances && data.distances[0]) || [];

      const ttMap = {};
      resortList.forEach((r, idx) => {
        const durSec = durations[idx];
        const distKm = distances[idx];
        if (typeof durSec === "number" && typeof distKm === "number") {
          const hours = durSec / 3600.0;
          ttMap[r.name] = { hours: hours, km: distKm };
        }
      });

      travelTimeCache[key] = ttMap;
      applyTravelTimesFromMap(ttMap);
    } catch (err) {
      console.error("Fehler beim Abrufen der Matrix:", err);
      alert("Fehler beim Abrufen der Fahrzeiten (Details in Konsole).");
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btn-calc-times");
    if (btn) {
      btn.addEventListener("click", () => {
        recalcTravelTimesFromOrigin();
      });
    }

    // GPS-Funktion f√ºr beide Buttons (Mobile home-box + Desktop slider-box)
    function handleGpsClick(buttonEl, originalText) {
      if (!navigator.geolocation) {
        alert("Geolocation wird von diesem Browser nicht unterst√ºtzt.");
        return;
      }

      buttonEl.disabled = true;
      buttonEl.textContent = "‚è≥";

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lat = pos.coords.latitude.toFixed(6);
          const lon = pos.coords.longitude.toFixed(6);
          const input = document.getElementById("home-input");
          if (input) input.value = `${lat},${lon}`;

          buttonEl.disabled = false;
          buttonEl.textContent = originalText;

          recalcTravelTimesFromOrigin();
        },
        (err) => {
          buttonEl.disabled = false;
          buttonEl.textContent = originalText;
          console.error("GPS Fehler:", err);
          alert("GPS-Position konnte nicht ermittelt werden: " + err.message);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // GPS-Button in home-box (Mobile)
    const gpsBtn = document.getElementById("btn-gps-times");
    if (gpsBtn) {
      gpsBtn.addEventListener("click", () => handleGpsClick(gpsBtn, "üìç GPS"));
    }

    // GPS-Button in slider-box (Desktop)
    const gpsSliderBtn = document.getElementById("btn-gps-slider");
    if (gpsSliderBtn) {
      gpsSliderBtn.addEventListener("click", () => handleGpsClick(gpsSliderBtn, "üìç"));
    }

    // Berechnen-Button in slider-box (Desktop)
    const calcSliderBtn = document.getElementById("btn-calc-slider");
    const homeInputSlider = document.getElementById("home-input-slider");
    if (calcSliderBtn && homeInputSlider) {
      calcSliderBtn.addEventListener("click", () => {
        // Wert ins home-input kopieren (wird von recalcTravelTimesFromOrigin gelesen)
        const homeInput = document.getElementById("home-input");
        if (homeInput) homeInput.value = homeInputSlider.value;
        recalcTravelTimesFromOrigin();
      });
      // Enter-Taste im Input-Feld
      homeInputSlider.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          calcSliderBtn.click();
        }
      });
    }
  });

  function loadTravelTimesJson(homeId) {
    // Kompatibilit√§t: l√§dt vorkomputierte Fahrzeiten pro Home-Profil
    // Erwartet Datei: data/travel_times/home_<homeId>.json
    const stored = (window.HomeTravelTimes && typeof window.HomeTravelTimes.getSelectedHomeId === "function")
      ? window.HomeTravelTimes.getSelectedHomeId()
      : null;

    const hid = homeId || stored || (localStorage.getItem("skimap.selectedHomeId")) || "muc";
    if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
      return window.HomeTravelTimes.load(hid);
    }

    // Fallback (sollte praktisch nie passieren):
    fetch(`data/travel_times/home_${hid}.json`)
      .then(resp => resp.json())
      .then(data => applyTravelTimesFromMap(data))
      .catch(err => {
        console.error("Fehler beim Laden von travel_times (per home), nutze Luftlinie:", err);
        updateTimeLabel(100);
        applyTimeFilter(100);
      });
  }

  
  // --------- Home Dropdown (Tree Routes + Fahrzeiten ausw√§hlen) ---------
  document.addEventListener("DOMContentLoaded", () => {
    if (!window.HomeRoutesSelector) return;

    window.HomeRoutesSelector.init({
      homesUrl: "data/homes.json",
      routesDir: "data/routes",
      routeFile: (homeId) => `data/routes/home_${homeId}.geojson`,
      defaultHomeId: "muc",
      selectId: "homeSelectSlider",
      boxId: "homeSelectorBox",
      desktopHostSelector: ".leaflet-top.leaflet-right",
      mobileHostId: "panel-filters",
      storageKey: "skimap.selectedHomeId",
      onHomeChanged: async (homeId, homeMeta) => {
        // Slider-Label updaten
        const lbl = document.querySelector('.slider-box label[for="time-slider"]');
        if (lbl) lbl.textContent = `Max. Fahrzeit ab ${homeMeta?.name || homeId}`;

        // Fahrzeiten pro Home laden
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.setSelectedHomeId === "function") {
          window.HomeTravelTimes.setSelectedHomeId(homeId);
        }
        if (window.HomeTravelTimes && typeof window.HomeTravelTimes.load === "function") {
          try { await window.HomeTravelTimes.load(homeId); }
          catch (e) { console.warn("HomeTravelTimes load failed:", e); }
        }

        // Corridors neu laden (ohne Checkbox-Status zu ver√§ndern)
        if (typeof window.ensureCorridorOverlayForHome === "function") {
          try { await window.ensureCorridorOverlayForHome(homeId); }
          catch (e) { console.warn("ensureCorridorOverlayForHome failed:", e); }
        }
      }
    });
  });

document.addEventListener("DOMContentLoaded", () => {
    loadResortsAndInit();
  });

  // Slider-Box Toggle f√ºr Mobile
  (function() {
    const sliderBox = document.getElementById('slider-box');
    const toggleBtn = document.getElementById('slider-box-toggle');
    if (!sliderBox || !toggleBtn) return;

    toggleBtn.addEventListener('click', () => {
      const isCollapsed = sliderBox.classList.toggle('collapsed');
      toggleBtn.setAttribute('aria-expanded', !isCollapsed);
    });
  })();

</script>

<div id="mobile-panel-backdrop" aria-hidden="true"></div>
<aside id="mobile-panel" aria-label="Filter und Layer">
    <details class="panel-accordion" open>
    <summary>Layer</summary>
    <div id="panel-layers" class="panel-section"></div>
  </details>

  <details class="panel-accordion">
    <summary>Filter</summary>
    <div id="panel-filters" class="panel-section"></div>
  </details>

  <details class="panel-accordion">
    <summary>Export</summary>
    <div id="panel-export" class="panel-section"></div>
  </details>
</aside>


<script>
  (function initMobilePanel(){
    const btn = document.getElementById('mobile-panel-toggle');
    const backdrop = document.getElementById('mobile-panel-backdrop');
    const panel = document.getElementById('mobile-panel');
    const panelLayers = document.getElementById('panel-layers');
    const panelFilters = document.getElementById('panel-filters');
    const panelExport = document.getElementById('panel-export');
    if (!btn || !backdrop || !panel || !panelLayers || !panelFilters || !panelExport) return;

    const mq = window.matchMedia('(max-width: 720px)');
    const isMobile = () => mq && mq.matches;

    const openPanel = () => {
      document.body.classList.add('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'true');
      backdrop.setAttribute('aria-hidden','false');
    };
    const closePanel = () => {
      document.body.classList.remove('mobile-panel-open');
      btn.setAttribute('aria-pressed', 'false');
      backdrop.setAttribute('aria-hidden','true');
    };

    btn.addEventListener('click', () => {
      document.body.classList.contains('mobile-panel-open') ? closePanel() : openPanel();
    });
    backdrop.addEventListener('click', closePanel);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePanel(); });

    function ensureDesktopStack(){
      const corner = document.querySelector('.leaflet-top.leaflet-right');
      if (!corner) return null;
      let stack = document.getElementById('desktop-control-stack');
      if (!stack) {
        stack = document.createElement('div');
        stack.id = 'desktop-control-stack';
        stack.className = 'desktop-control-stack';
        corner.prepend(stack);
      }
      return stack;
    }

    function placeControls(){
      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');

      if (isMobile()) {
        if (layers && layers.parentNode !== panelLayers) panelLayers.appendChild(layers);
        if (filters && filters.parentNode !== panelFilters) panelFilters.appendChild(filters);
        if (exportBox && exportBox.parentNode !== panelExport) panelExport.appendChild(exportBox);
      } else {
        const stack = ensureDesktopStack();
        if (!stack) return;
        if (layers && layers.parentNode !== stack) stack.appendChild(layers);
        if (filters && filters.parentNode !== stack) stack.appendChild(filters);
        if (exportBox && exportBox.parentNode !== stack) stack.appendChild(exportBox);
        closePanel(); // ensure panel isn't stuck open when resizing to desktop
      }
    }

    // Controls are created after map init -> retry a few times
    let tries = 0;
    const timer = setInterval(() => {
      placeControls();
      tries += 1;

      const layers = document.querySelector('.leaflet-control-layers');
      const filters = document.querySelector('.filter-box');
      const exportBox = document.querySelector('.export-box');
      if ((layers && filters && exportBox) || tries > 50) clearInterval(timer);
    }, 200);

    window.addEventListener('resize', () => placeControls());
    if (mq && mq.addEventListener) mq.addEventListener('change', () => placeControls());
  })();
</script>

</body>
</html>
