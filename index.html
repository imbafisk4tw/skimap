<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Skigebiete Alpen – Snow Card Tirol &amp; SuperSkiCard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <!-- Leaflet MarkerCluster CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #222;
    }

    /* Seite in zwei Bereiche unterteilen: Oben Controls, darunter Karte */
    body {
      display: flex;
      flex-direction: column;
    }

    h2 {
      margin: 0 0 6px 0;
      font-size: 16px;
    }

    #controls {
      padding: 10px 12px;
      background: #f8f8f8;
      border-bottom: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px 16px;
      font-size: 14px;
    }

    #map {
      flex: 1;
      width: 100%;
    }

    label {
      font-size: 13px;
    }

    details {
      margin: 0 0 4px 0;
    }

    details summary {
      cursor: pointer;
      font-weight: 600;
      outline: none;
      list-style: none;
    }

    details summary::marker {
      display: none;
    }

    details summary::before {
      content: "▶";
      display: inline-block;
      margin-right: 8px;
      font-size: 11px;
      transform: rotate(0deg);
      transition: transform 0.1s linear;
    }

    details[open] summary::before {
      transform: rotate(90deg);
    }

    #filters-container {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      align-items: flex-start;
    }

    .filter-group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      font-size: 13px;
    }

    .filter-group span.label {
      font-weight: 500;
    }

    .inline-label {
      font-weight: 500;
      margin-right: 4px;
    }

    input[type="range"] {
      vertical-align: middle;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-right: 10px;
    }

    .legend-color-box {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      display: inline-block;
      border: 1px solid #555;
    }

    /* Farben passend zu den Leaflet-Icons */
    .legend-color-sct,
    .legend-color-sct-ssc {
      background: #2e8b57;
    }

    .legend-color-ssc {
      background: #ff4500;
    }

    .legend-color-nearmuc {
      background: #4169e1;
    }

    .legend-color-glacier {
      background: #1e90ff;
    }

    #time-label {
      font-weight: 600;
    }

    .controls-section-title {
      font-weight: 600;
      margin-right: 8px;
    }

    #search-controls,
    #filter-controls,
    #legend-controls,
    #home-controls {
      padding: 4px 0;
    }

    #search-controls label {
      margin-right: 4px;
    }

    .description-text {
      font-size: 12px;
      color: #444;
      margin-top: 4px;
    }

    /* Stil für "keine Fahrzeit" in Popup */
    .no-time {
      color: #999;
      font-style: italic;
    }

    /* Box für Startadresse & Button */
    .home-address-box {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
    }

    .home-address-box label {
      margin-right: 4px;
    }

    #home-address-input {
      padding: 2px 6px;
      font-size: 12px;
      min-width: 160px;
    }

    #home-address-btn {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid #888;
      background: #fff;
      cursor: pointer;
    }

    #home-address-btn:hover {
      background: #eee;
    }

    #home-address-note {
      font-size: 11px;
      color: #555;
    }

    /* Box für Startmarker-Info */
    .origin-marker-label {
      font-size: 11px;
      font-weight: 600;
      padding: 2px 4px;
      background: #fff;
      border-radius: 3px;
      border: 1px solid #aaa;
    }

    /* Cache-Info */
    #cache-info {
      font-size: 11px;
      color: #555;
    }

    /* Suchfeld + Autocomplete */
    #resort-search {
      padding: 2px 6px;
      font-size: 12px;
      min-width: 160px;
    }

    /* Counter-Box unten rechts */
    .counter-box {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      background: white;
      padding: 6px 10px;
      border: 1px solid #888;
      font-size: 12px;
      line-height: 1.4;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div id="controls">
    <div id="search-controls">
      <span class="controls-section-title">Suche:</span>
      <label for="resort-search">Skigebiet:</label>
      <input list="resort-datalist" id="resort-search" placeholder="Name eingeben..." />
      <datalist id="resort-datalist"></datalist>
      <span class="description-text">
        Tippe den Namen eines Skigebiets, z.B. "Sölden", und wähle es aus der Vorschlagsliste.
      </span>
    </div>

    <div id="home-controls">
      <details open>
        <summary>Startadresse (Fahrzeit-Berechnung)</summary>
        <div class="home-address-box">
          <label for="home-address-input">Adresse:</label>
          <input id="home-address-input" type="text" placeholder="z.B. Marienplatz, München" />
          <button id="home-address-btn">Fahrzeiten aktualisieren</button>
        </div>
        <div id="home-address-note">
          Die Adresse gilt für diese Sitzung. Der Startpunkt wird auf der Karte markiert.
        </div>
        <div id="cache-info">
          Bereits berechnete Fahrzeiten werden im Browser zwischengespeichert (Session).
        </div>
      </details>
    </div>

    <div id="filter-controls">
      <details open>
        <summary>Fahrzeitfilter &amp; Layer</summary>
        <div id="filters-container">
          <div class="filter-group">
            <span class="inline-label">Fahrzeit max.:</span>
            <input type="range" id="time-slider" min="0" max="100" value="100" />
            <span id="time-label">–</span>
          </div>

          <div class="filter-group">
            <span class="label">Layer:</span>
            <label>
              <input type="checkbox" id="layer-sct" checked />
              Snow Card Tirol
            </label>
            <label>
              <input type="checkbox" id="layer-ssc" checked />
              SuperSkiCard
            </label>
            <label>
              <input type="checkbox" id="layer-overlap" checked />
              Überlappung (SCT &amp; SSC)
            </label>
            <label>
              <input type="checkbox" id="layer-glacier" checked />
              Gletschergebiete
            </label>
            <label>
              <input type="checkbox" id="layer-nearmuc" checked />
              Nahe München (&lt; 120 Min)
            </label>
          </div>
        </div>
      </details>
    </div>

    <div id="legend-controls">
      <details>
        <summary>Legende / Hinweise</summary>
        <div class="filter-group">
          <span class="legend-item">
            <span class="legend-color-box legend-color-sct"></span> Snow Card Tirol
          </span>
          <span class="legend-item">
            <span class="legend-color-box legend-color-ssc"></span> SuperSkiCard
          </span>
          <span class="legend-item">
            <span class="legend-color-box legend-color-nearmuc"></span> Nahe München
          </span>
          <span class="legend-item">
            <span class="legend-color-box legend-color-glacier"></span> Gletschergebiet
          </span>
        </div>
        <div class="description-text">
          Im Popup wird die Fahrzeit von der gewählten Startadresse angezeigt (sofern vorhanden).
        </div>
      </details>
    </div>
  </div>

  <div id="map"></div>

  <!-- Counter sichtbare Resorts -->
  <div id="resort-counter" class="counter-box">
    0 / 0
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Leaflet MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Minimaler Polyfill für fetch in sehr alten Browsern (optional) -->
  <script>
    if (!window.fetch) {
      console.warn(
        "Dieser Browser unterstützt eventuell kein fetch(). Die Seite funktioniert ggf. nur eingeschränkt."
      );
    }
  </script>

  <script>
    // ---------- Hilfsfunktionen ----------

    function norm(str) {
      return (str || "")
        .toLowerCase()
        .normalize("NFD")
        .replace(/\p{Diacritic}/gu, "")
        .replace(/ß/g, "ss")
        .replace(/\s+/g, " ")
        .trim();
    }

    function fmtTime(hours) {
      if (hours == null || !isFinite(hours)) return "-";
      const totalMinutes = Math.round(hours * 60);
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;
      if (h === 0) return `${m} Min`;
      if (m === 0) return `${h} Std`;
      return `${h} Std ${m} Min`;
    }

    function fmtDistance(km) {
      if (km == null || !isFinite(km)) return "-";
      if (km < 1) {
        const m = Math.round(km * 1000);
        return `${m} m`;
      }
      return `${km.toFixed(1)} km`;
    }

    // ---------- Leaflet-Karte & Layer ----------

    const map = L.map("map").setView([47.2, 12.2], 7.5);

    // Counter bei Layer-Toggles aktualisieren
    map.on("overlayadd", updateResortCounter);
    map.on("overlayremove", updateResortCounter);

    const baseLayer = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> Mitwirkende',
    }).addTo(map);

    const sctLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 12,
    });
    const sscLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 12,
    });
    const overlapLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 12,
    });
    const glacierLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 12,
    });
    const nearMucLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 12,
    });

    const overlayMaps = {
      "Snow Card Tirol": sctLayer,
      SuperSkiCard: sscLayer,
      "Überlappung (SCT & SSC)": overlapLayer,
      Gletschergebiete: glacierLayer,
      "Nahe München (&lt; 120 Min)": nearMucLayer,
    };

    L.control.layers(null, overlayMaps, { collapsed: false }).addTo(map);

    sctLayer.addTo(map);
    sscLayer.addTo(map);
    overlapLayer.addTo(map);
    glacierLayer.addTo(map);
    nearMucLayer.addTo(map);

    // ---------- Resorts & Marker ----------

    const resorts = {};
    const resortMarkers = {};
    let minHours = Infinity;
    let maxHours = 0;

    const travelTimeCache = {};
    let originMarker = null;

    // Gesamtzahl Resorts
    let totalResorts = 0;

    function updateResortCounter() {
      const box = document.getElementById("resort-counter");
      if (!box) return;

      let visible = 0;
      Object.values(resortMarkers).forEach((marker) => {
        if (map.hasLayer(marker)) {
          visible++;
        }
      });

      box.textContent = `${visible} / ${totalResorts}`;
    }

    function initResortsFromJson(list) {
      list.forEach((r) => {
        const key = norm(r.name);
        if (!key) return;

        if (!resorts[key]) {
          resorts[key] = {
            name: r.name,
            lat: r.lat,
            lon: r.lon,
            sct: !!r.sct,
            ssc: !!r.ssc,
            glacier: !!r.glacier,
            nearMuc: !!r.nearMuc,
            googleMapsLink: r.googleMapsLink || null,
            website: r.website || null,
            travelHours: null,
            travelDistance: null,
          };
        } else {
          resorts[key].sct = resorts[key].sct || !!r.sct;
          resorts[key].ssc = resorts[key].ssc || !!r.ssc;
          resorts[key].glacier = resorts[key].glacier || !!r.glacier;
          resorts[key].nearMuc = resorts[key].nearMuc || !!r.nearMuc;
          resorts[key].googleMapsLink = resorts[key].googleMapsLink || r.googleMapsLink || null;
          resorts[key].website = resorts[key].website || r.website || null;
        }
      });
    }

    const IconSCT = L.icon({
      iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    const IconSSC = L.icon({
      iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    const IconNearMUC = L.icon({
      iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    const IconGlacier = L.icon({
      iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    const IconOverlap = L.icon({
      iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png",
      iconSize: [30, 49],
      iconAnchor: [15, 49],
      popupAnchor: [1, -40],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    const IconOrigin = L.icon({
      iconUrl:
        "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
      shadowSize: [41, 41],
    });

    function chooseIcon(r) {
      if (r.glacier) {
        return IconGlacier;
      }
      if (r.nearMuc) {
        return IconNearMUC;
      }
      if (r.sct && r.ssc) {
        return IconOverlap;
      }
      if (r.sct) {
        return IconSCT;
      }
      if (r.ssc) {
        return IconSSC;
      }
      return IconSCT;
    }

    function buildMarkers() {
      Object.entries(resorts).forEach(([key, r]) => {
        if (typeof r.lat !== "number" || typeof r.lon !== "number") return;

        const marker = L.marker([r.lat, r.lon], {
          icon: chooseIcon(r),
        });

        resortMarkers[key] = marker;

        const popupContent = createPopupContent(r);
        marker.bindPopup(popupContent);

        if (r.sct && r.ssc) {
          overlapLayer.addLayer(marker);
        }
        if (r.sct) {
          sctLayer.addLayer(marker);
        }
        if (r.ssc) {
          sscLayer.addLayer(marker);
        }
        if (r.glacier) {
          glacierLayer.addLayer(marker);
        }
        if (r.nearMuc) {
          nearMucLayer.addLayer(marker);
        }
      });
    }

    function createPopupContent(r) {
      const timeText =
        r.travelHours != null && isFinite(r.travelHours)
          ? fmtTime(r.travelHours)
          : "<span class='no-time'>keine Fahrzeit vorhanden</span>";
      const distText =
        r.travelDistance != null && isFinite(r.travelDistance)
          ? fmtDistance(r.travelDistance)
          : "<span class='no-time'>–</span>";

      const tags = [];
      if (r.sct) tags.push("Snow Card Tirol");
      if (r.ssc) tags.push("SuperSkiCard");
      if (r.glacier) tags.push("Gletschergebiet");
      if (r.nearMuc) tags.push("&lt; 120 Min von München");

      const tagLine = tags.length ? `<div><strong>Pässe:</strong> ${tags.join(", ")}</div>` : "";

      let links = "";
      if (r.googleMapsLink) {
        links += `<div><a href="${r.googleMapsLink}" target="_blank" rel="noopener noreferrer">Google Maps</a></div>`;
      }
      if (r.website) {
        links += `<div><a href="${r.website}" target="_blank" rel="noopener noreferrer">Website</a></div>`;
      }

      return `
        <div>
          <strong>${r.name}</strong>
          ${tagLine}
          <div><strong>Fahrzeit:</strong> ${timeText}</div>
          <div><strong>Entfernung:</strong> ${distText}</div>
          ${links}
        </div>
      `;
    }

    function updateAllPopups() {
      Object.values(resortMarkers).forEach((marker) => {
        const pos = marker.getLatLng();
        let found = null;
        for (const r of Object.values(resorts)) {
          if (Math.abs(r.lat - pos.lat) < 1e-8 && Math.abs(r.lon - pos.lng) < 1e-8) {
            found = r;
            break;
          }
        }
        if (!found) return;
        marker.setPopupContent(createPopupContent(found));
      });
    }

    // ---------- Fahrzeit-Filter ----------

    function updateTimeLabel(pct) {
      const label = document.getElementById("time-label");
      if (!isFinite(minHours) || !isFinite(maxHours) || minHours === Infinity) {
        label.textContent = "keine Daten";
        return;
      }
      const limitHours = minHours + (pct / 100) * (maxHours - minHours);
      label.textContent = `bis ca. ${fmtTime(limitHours)}`;
    }

    function applyTimeFilter(pct) {
      const limitHours = minHours + (pct / 100) * (maxHours - minHours);

      Object.values(resorts).forEach((r) => {
        const key = norm(r.name);
        const marker = resortMarkers[key];
        if (!marker || r.travelHours == null) return;

        const inside = pct >= 99 || r.travelHours <= limitHours + 1e-6;

        if (r.sct) {
          if (inside) sctLayer.addLayer(marker);
          else sctLayer.removeLayer(marker);
        }
        if (r.ssc) {
          if (inside) sscLayer.addLayer(marker);
          else sscLayer.removeLayer(marker);
        }
        if (r.sct && r.ssc) {
          if (inside) overlapLayer.addLayer(marker);
          else overlapLayer.removeLayer(marker);
        }
        if (r.glacier) {
          if (inside) glacierLayer.addLayer(marker);
          else glacierLayer.removeLayer(marker);
        }
        if (r.nearMuc) {
          if (inside) nearMucLayer.addLayer(marker);
          else nearMucLayer.removeLayer(marker);
        }
      });

      updateResortCounter();
    }

    const timeSlider = document.getElementById("time-slider");
    timeSlider.addEventListener("input", () => {
      const pct = Number(timeSlider.value) || 0;
      updateTimeLabel(pct);
      applyTimeFilter(pct);
    });

    // ---------- Suchfeld-Logik ----------

    const searchInput = document.getElementById("resort-search");
    const datalist = document.getElementById("resort-datalist");

    function rebuildDatalist() {
      while (datalist.firstChild) {
        datalist.removeChild(datalist.firstChild);
      }
      Object.values(resorts)
        .sort((a, b) => a.name.localeCompare(b.name, "de"))
        .forEach((r) => {
          const opt = document.createElement("option");
          if (r.travelHours != null && isFinite(r.travelHours)) {
            opt.value = r.name + " – " + fmtTime(r.travelHours);
          } else {
            opt.value = r.name;
          }
          datalist.appendChild(opt);
        });
    }

    function focusResortByName(query) {
      if (!query) return;
      const qNorm = norm(query);
      const keys = Object.keys(resortMarkers);

      let bestKey = null;
      let bestScore = Infinity;

      for (const key of keys) {
        const score = levenshteinDistance(qNorm, key);
        if (score < bestScore) {
          bestScore = score;
          bestKey = key;
        }
      }

      if (bestKey == null) return;
      const marker = resortMarkers[bestKey];
      if (!marker) return;

      const latLng = marker.getLatLng();
      map.setView(latLng, 11);
      marker.openPopup();
    }

    function levenshteinDistance(a, b) {
      if (a === b) return 0;
      if (!a.length) return b.length;
      if (!b.length) return a.length;

      const dp = Array.from({ length: a.length + 1 }, () => new Array(b.length + 1).fill(0));
      for (let i = 0; i <= a.length; i++) dp[i][0] = i;
      for (let j = 0; j <= b.length; j++) dp[0][j] = j;

      for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost
          );
        }
      }
      return dp[a.length][b.length];
    }

    searchInput.addEventListener("change", () => {
      const val = searchInput.value || "";
      const m = val.match(/^(.+?)\s+–/);
      const name = m ? m[1] : val;
      focusResortByName(name);
    });

    searchInput.addEventListener("keydown", (ev) => {
      if (ev.key === "Enter") {
        ev.preventDefault();
        const val = searchInput.value || "";
        const m = val.match(/^(.+?)\s+–/);
        const name = m ? m[1] : val;
        focusResortByName(name);
      }
    });

    // ---------- Layer-Checkboxen ----------

    const layerSctCheckbox = document.getElementById("layer-sct");
    const layerSscCheckbox = document.getElementById("layer-ssc");
    const layerOverlapCheckbox = document.getElementById("layer-overlap");
    const layerGlacierCheckbox = document.getElementById("layer-glacier");
    const layerNearMucCheckbox = document.getElementById("layer-nearmuc");

    layerSctCheckbox.addEventListener("change", () => {
      if (layerSctCheckbox.checked) {
        map.addLayer(sctLayer);
      } else {
        map.removeLayer(sctLayer);
      }
      updateResortCounter();
    });

    layerSscCheckbox.addEventListener("change", () => {
      if (layerSscCheckbox.checked) {
        map.addLayer(sscLayer);
      } else {
        map.removeLayer(sscLayer);
      }
      updateResortCounter();
    });

    layerOverlapCheckbox.addEventListener("change", () => {
      if (layerOverlapCheckbox.checked) {
        map.addLayer(overlapLayer);
      } else {
        map.removeLayer(overlapLayer);
      }
      updateResortCounter();
    });

    layerGlacierCheckbox.addEventListener("change", () => {
      if (layerGlacierCheckbox.checked) {
        map.addLayer(glacierLayer);
      } else {
        map.removeLayer(glacierLayer);
      }
      updateResortCounter();
    });

    layerNearMucCheckbox.addEventListener("change", () => {
      if (layerNearMucCheckbox.checked) {
        map.addLayer(nearMucLayer);
      } else {
        map.removeLayer(nearMucLayer);
      }
      updateResortCounter();
    });

    // ---------- Startadresse / Fahrzeit-Berechnung ----------

    const homeInput = document.getElementById("home-address-input");
    const homeBtn = document.getElementById("home-address-btn");

    homeBtn.addEventListener("click", () => {
      const address = homeInput.value.trim();
      if (!address) {
        alert("Bitte eine Startadresse eingeben.");
        return;
      }
      recalcTravelTimes(address);
    });

    const OSRM_URL = "https://router.project-osrm.org/route/v1/driving";

    function buildCacheKey(origin, r) {
      return `${origin}__${r.lat.toFixed(5)},${r.lon.toFixed(5)}`;
    }

    function parseLatLonFromGMapsLink(link) {
      if (!link) return null;
      const m = link.match(/@(-?\d+\.\d+),(-?\d+\.\d+)[,z]/);
      if (!m) return null;
      const lat = parseFloat(m[1]);
      const lon = parseFloat(m[2]);
      if (!isFinite(lat) || !isFinite(lon)) return null;
      return [lat, lon];
    }

    async function recalcTravelTimes(originAddress) {
      try {
        const coords = await geocodeAddress(originAddress);
        if (!coords) {
          alert("Startadresse konnte nicht geocodiert werden.");
          return;
        }

        showOriginMarker(coords.lat, coords.lon, originAddress);
        await calcOsrmForAllResorts(coords.lat, coords.lon, originAddress);

        minHours = Infinity;
        maxHours = 0;
        for (const r of Object.values(resorts)) {
          if (r.travelHours != null && isFinite(r.travelHours)) {
            if (r.travelHours < minHours) minHours = r.travelHours;
            if (r.travelHours > maxHours) maxHours = r.travelHours;
          }
        }

        const sliderVal = Number(timeSlider.value) || 100;
        updateTimeLabel(sliderVal);
        applyTimeFilter(sliderVal);

        updateAllPopups();
      } catch (e) {
        console.error(e);
        alert("Fehler bei der Fahrzeitberechnung (Details in Konsole).");
      }
    }

    async function geocodeAddress(address) {
      const url =
        "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" +
        encodeURIComponent(address);

      const resp = await fetch(url, {
        headers: {
          "Accept-Language": "de",
        },
      });
      if (!resp.ok) {
        console.error("Fehler bei Nominatim:", resp.status);
        return null;
      }
      const data = await resp.json();
      if (!Array.isArray(data) || data.length === 0) {
        return null;
      }
      const obj = data[0];
      const lat = parseFloat(obj.lat);
      const lon = parseFloat(obj.lon);
      if (!isFinite(lat) || !isFinite(lon)) return null;
      return { lat, lon };
    }

    function showOriginMarker(lat, lon, label) {
      if (originMarker) {
        map.removeLayer(originMarker);
      }

      originMarker = L.marker([lat, lon], { icon: IconOrigin }).addTo(map);
      originMarker
        .bindPopup(
          `<div><strong>Startpunkt</strong><br>${label}</div>`
        )
        .openPopup();

      const bounds = L.latLngBounds([lat, lon]);
      Object.values(resortMarkers).forEach((m) => bounds.extend(m.getLatLng()));
      map.fitBounds(bounds, { padding: [40, 40] });
    }

    async function calcOsrmForAllResorts(originLat, originLon, originAddress) {
      const resortArray = Object.values(resorts);

      for (const r of resortArray) {
        const key = buildCacheKey(originAddress, r);
        if (travelTimeCache[key]) {
          const { hours, km } = travelTimeCache[key];
          r.travelHours = hours;
          r.travelDistance = km;
          continue;
        }

        let latDest = r.lat;
        let lonDest = r.lon;
        if (
          (latDest == null || lonDest == null) &&
          r.googleMapsLink &&
          typeof r.googleMapsLink === "string"
        ) {
          const altCoords = parseLatLonFromGMapsLink(r.googleMapsLink);
          if (altCoords) {
            latDest = altCoords[0];
            lonDest = altCoords[1];
          }
        }
        if (latDest == null || lonDest == null) {
          r.travelHours = null;
          r.travelDistance = null;
          continue;
        }

        const url = `${OSRM_URL}/${originLon},${originLat};${lonDest},${latDest}?overview=false`;

        try {
          const resp = await fetch(url);
          if (!resp.ok) {
            console.warn(
              "OSRM-Fehler für",
              r.name,
              "Status:",
              resp.status
            );
            r.travelHours = null;
            r.travelDistance = null;
            continue;
          }
          const data = await resp.json();
          if (
            !data ||
            !data.routes ||
            !data.routes[0] ||
            typeof data.routes[0].duration !== "number"
          ) {
            console.warn("OSRM: keine Route gefunden für", r.name);
            r.travelHours = null;
            r.travelDistance = null;
            continue;
          }
          const route = data.routes[0];
          const hours = route.duration / 3600;
          const km = (route.distance || 0) / 1000;

          r.travelHours = hours;
          r.travelDistance = km;
          travelTimeCache[key] = { hours, km };

          await new Promise((res) => setTimeout(res, 500));
        } catch (e) {
          console.error("OSRM-Request fehlgeschlagen für", r.name, e);
          r.travelHours = null;
          r.travelDistance = null;
        }
      }
    }

    // ---------- Laden der bestehenden travel_times.json (Fallback) ----------

    async function loadTravelTimesJson() {
      try {
        const resp = await fetch("travel_times.json", { cache: "no-store" });
        if (!resp.ok) {
          console.log(
            "travel_times.json konnte nicht geladen werden (Status",
            resp.status,
            ") – ist okay, falls es keine Datei gibt."
          );
          return;
        }
        const json = await resp.json();
        minHours = Infinity;
        maxHours = 0;
        Object.entries(json).forEach(([name, info]) => {
          const key = norm(name);
          const r = resorts[key];
          if (!r) return;
          r.travelHours = info.hours ?? null;
          r.travelDistance = info.distance_km ?? null;

          if (r.travelHours != null && isFinite(r.travelHours)) {
            if (r.travelHours < minHours) minHours = r.travelHours;
            if (r.travelHours > maxHours) maxHours = r.travelHours;
          }
        });

        if (!isFinite(minHours) || minHours === Infinity) {
          minHours = 0;
        }
        if (!isFinite(maxHours) || maxHours === 0) {
          maxHours = 3;
        }

        const sliderVal = Number(timeSlider.value) || 100;
        updateTimeLabel(sliderVal);
        applyTimeFilter(sliderVal);
      } catch (e) {
        console.error("Fehler beim Laden von travel_times.json:", e);
      }
    }

    // ---------- Initiales Laden von resorts.json ----------

    function loadResortsAndInit() {
      fetch("resorts.json")
        .then((resp) => {
          if (!resp.ok) {
            throw new Error("HTTP " + resp.status);
          }
          return resp.json();
        })
        .then((list) => {
          initResortsFromJson(list);

          totalResorts = Object.keys(resorts).length;

          buildMarkers();
          if (typeof rebuildDatalist === "function") {
            rebuildDatalist();
          }
          updateTimeLabel(100);
          applyTimeFilter(100);
          if (typeof loadTravelTimesJson === "function") {
            loadTravelTimesJson();
          }
        })
        .catch((err) => {
          console.error("Fehler beim Laden von resorts.json:", err);
          alert("Fehler beim Laden der Skigebiete (Details in Konsole).");
        });
    }

    loadResortsAndInit();
  </script>
</body>
</html>
